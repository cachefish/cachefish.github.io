<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cachefish.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="来世做春风，浪漫且自由">
<meta property="og:type" content="website">
<meta property="og:title" content="cachecatのBlog">
<meta property="og:url" content="https://cachefish.github.io/page/2/index.html">
<meta property="og:site_name" content="cachecatのBlog">
<meta property="og:description" content="来世做春风，浪漫且自由">
<meta property="og:locale" content="zh_CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://cachefish.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>cachecatのBlog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">cachecatのBlog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">localhost</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">11</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">11</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">38</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cachefish.github.io/2022/04/01/shortcut/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2229.jfif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="来世做春风，浪漫且自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cachecatのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/01/shortcut/" class="post-title-link" itemprop="url">shortcut</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-01 19:30:00" itemprop="dateCreated datePublished" datetime="2022-04-01T19:30:00+08:00">2022-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-07 09:58:28" itemprop="dateModified" datetime="2022-04-07T09:58:28+08:00">2022-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux-shell/" itemprop="url" rel="index"><span itemprop="name">linux shell</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">which <span class="literal">true</span></span><br><span class="line">which <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="literal">true</span> &amp;&amp; echo <span class="number">1</span> || echo <span class="number">2</span> &amp;&amp; echo <span class="number">3</span> || echo <span class="number">4</span></span><br><span class="line"><span class="literal">true</span> || echo <span class="number">1</span> &amp;&amp; echo <span class="number">2</span> || echo <span class="number">3</span> &amp;&amp; echo <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="literal">true</span>  &amp;&amp; <span class="literal">true</span>  &amp;&amp; <span class="literal">true</span>  &amp;&amp; <span class="literal">true</span>  &amp;&amp; echo <span class="literal">true</span></span><br><span class="line"><span class="literal">false</span> &amp;&amp; <span class="literal">true</span>  &amp;&amp; <span class="literal">true</span>  &amp;&amp; <span class="literal">true</span>  &amp;&amp; echo cannot <span class="literal">true</span></span><br><span class="line"><span class="literal">true</span>  &amp;&amp; <span class="literal">false</span> &amp;&amp; <span class="literal">true</span>  &amp;&amp; <span class="literal">true</span>  &amp;&amp; echo cannot <span class="literal">true</span></span><br><span class="line"><span class="literal">true</span>  &amp;&amp; <span class="literal">true</span>  &amp;&amp; <span class="literal">false</span> &amp;&amp; <span class="literal">true</span>  &amp;&amp; echo cannot <span class="literal">true</span></span><br><span class="line"><span class="literal">true</span>  &amp;&amp; <span class="literal">true</span>  &amp;&amp; <span class="literal">true</span>  &amp;&amp; <span class="literal">false</span> &amp;&amp; echo cannot <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="literal">false</span> || <span class="literal">false</span> || <span class="literal">false</span> || <span class="literal">false</span> || echo <span class="literal">false</span></span><br><span class="line"><span class="literal">true</span>  || <span class="literal">false</span> || <span class="literal">false</span> || <span class="literal">false</span> || echo cannot <span class="literal">false</span></span><br><span class="line"><span class="literal">false</span> || <span class="literal">true</span>  || <span class="literal">false</span> || <span class="literal">false</span> || echo cannot <span class="literal">false</span></span><br><span class="line"><span class="literal">false</span> || <span class="literal">false</span> || <span class="literal">true</span>  || <span class="literal">false</span> || echo cannot <span class="literal">false</span></span><br><span class="line"><span class="literal">false</span> || <span class="literal">false</span> || <span class="literal">false</span> || <span class="literal">true</span>  || echo cannot <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="literal">true</span>  &amp;&amp; <span class="literal">true</span>  &amp;&amp; echo <span class="string">&quot;cond1 &amp;&amp; true&quot;</span> || echo <span class="string">&quot;cond1 &amp;&amp; false&quot;</span></span><br><span class="line"><span class="literal">true</span>  &amp;&amp; <span class="literal">false</span> &amp;&amp; echo <span class="string">&quot;cond2 &amp;&amp; true&quot;</span> || echo <span class="string">&quot;cond2 &amp;&amp; false&quot;</span></span><br><span class="line"><span class="literal">false</span> &amp;&amp; <span class="literal">true</span>  &amp;&amp; echo <span class="string">&quot;cond3 &amp;&amp; true&quot;</span> || echo <span class="string">&quot;cond3 &amp;&amp; false&quot;</span></span><br><span class="line"><span class="literal">false</span> &amp;&amp; <span class="literal">false</span> &amp;&amp; echo <span class="string">&quot;cond4 &amp;&amp; true&quot;</span> || echo <span class="string">&quot;cond4 &amp;&amp; false&quot;</span></span><br><span class="line"><span class="literal">true</span>  || <span class="literal">true</span>  &amp;&amp; echo <span class="string">&quot;cond1 || true&quot;</span> || echo <span class="string">&quot;cond1 || false&quot;</span></span><br><span class="line"><span class="literal">true</span>  || <span class="literal">false</span> &amp;&amp; echo <span class="string">&quot;cond2 || true&quot;</span> || echo <span class="string">&quot;cond2 || false&quot;</span></span><br><span class="line"><span class="literal">false</span> || <span class="literal">true</span>  &amp;&amp; echo <span class="string">&quot;cond3 || true&quot;</span> || echo <span class="string">&quot;cond3 || false&quot;</span></span><br><span class="line"><span class="literal">false</span> || <span class="literal">false</span> &amp;&amp; echo <span class="string">&quot;cond4 || true&quot;</span> || echo <span class="string">&quot;cond4 || false&quot;</span></span><br><span class="line"></span><br><span class="line">echo fake</span><br><span class="line"><span class="literal">true</span>  &amp;&amp; <span class="literal">true</span>  || echo <span class="string">&quot;cond1 &amp;&amp; false&quot;</span> &amp;&amp; echo <span class="string">&quot;cond1 &amp;&amp; true&quot;</span></span><br><span class="line"><span class="literal">true</span>  &amp;&amp; <span class="literal">false</span> || echo <span class="string">&quot;cond2 &amp;&amp; false&quot;</span> &amp;&amp; echo <span class="string">&quot;cond2 &amp;&amp; true&quot;</span></span><br><span class="line"><span class="literal">false</span> &amp;&amp; <span class="literal">true</span>  || echo <span class="string">&quot;cond3 &amp;&amp; false&quot;</span> &amp;&amp; echo <span class="string">&quot;cond3 &amp;&amp; true&quot;</span></span><br><span class="line"><span class="literal">false</span> &amp;&amp; <span class="literal">false</span> || echo <span class="string">&quot;cond4 &amp;&amp; false&quot;</span> &amp;&amp; echo <span class="string">&quot;cond4 &amp;&amp; true&quot;</span></span><br><span class="line"><span class="literal">true</span>  || <span class="literal">true</span>  || echo <span class="string">&quot;cond1 || false&quot;</span> &amp;&amp; echo <span class="string">&quot;cond1 || true&quot;</span></span><br><span class="line"><span class="literal">true</span>  || <span class="literal">false</span> || echo <span class="string">&quot;cond2 || false&quot;</span> &amp;&amp; echo <span class="string">&quot;cond2 || true&quot;</span></span><br><span class="line"><span class="literal">false</span> || <span class="literal">true</span>  || echo <span class="string">&quot;cond3 || false&quot;</span> &amp;&amp; echo <span class="string">&quot;cond3 || true&quot;</span></span><br><span class="line"><span class="literal">false</span> || <span class="literal">false</span> || echo <span class="string">&quot;cond4 || false&quot;</span> &amp;&amp; echo <span class="string">&quot;cond4 || true&quot;</span></span><br><span class="line"></span><br><span class="line">echo <span class="number">1</span>;echo <span class="number">2</span>;echo <span class="number">1</span>;echo <span class="number">2</span>;</span><br><span class="line">echo same as</span><br><span class="line">echo <span class="number">1</span></span><br><span class="line">echo <span class="number">2</span></span><br><span class="line">echo <span class="number">1</span></span><br><span class="line">echo <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cachefish.github.io/2022/04/01/transform/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2229.jfif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="来世做春风，浪漫且自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cachecatのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/01/transform/" class="post-title-link" itemprop="url">tranform</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-01 19:30:00" itemprop="dateCreated datePublished" datetime="2022-04-01T19:30:00+08:00">2022-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-07 09:58:00" itemprop="dateModified" datetime="2022-04-07T09:58:00+08:00">2022-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux-shell/" itemprop="url" rel="index"><span itemprop="name">linux shell</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="结果变换-字符串处理"><a href="#结果变换-字符串处理" class="headerlink" title="结果变换  字符串处理"></a>结果变换  字符串处理</h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">#!<span class="regexp">/bin/</span>bash</span><br><span class="line"></span><br><span class="line">compile_result=$(cat &lt;&lt; EOF</span><br><span class="line">[<span class="number">221</span><span class="regexp">/2278] SOLINK hdf/</span>hdf/libcamera_buffer_manager.z.so</span><br><span class="line">[<span class="number">222</span><span class="regexp">/2278] SOLINK hdf/</span>hdf/libcamera_client.z.so</span><br><span class="line">[<span class="number">223</span><span class="regexp">/2278] CXX obj/</span>foundation<span class="regexp">/graphic/</span>standard<span class="regexp">/frameworks/</span>surface<span class="regexp">/test/u</span>nittest<span class="regexp">/buffer_queue_test/</span>buffer_queue_test.o</span><br><span class="line">FAILED: obj<span class="regexp">/foundation/g</span>raphic<span class="regexp">/standard/</span>frameworks<span class="regexp">/surface/</span>test<span class="regexp">/unittest/</span>buffer_queue_test/buffer_queue_test.o</span><br><span class="line">..<span class="regexp">/../</span>prebuilts<span class="regexp">/clang/</span>host<span class="regexp">/linux-x86/</span>clang-r353983c<span class="regexp">/bin/</span>clang++ -MMD -MF obj<span class="regexp">/foundation/g</span>raphic<span class="regexp">/standard/</span>frameworks<span class="regexp">/surface/</span>test<span class="regexp">/unittest/</span>buffer_queue_test<span class="regexp">/buffer_queue_test.o.d -DV8_DEPRECATION_WARNINGS -DNO_TCMALLOC -D_GNU_SOURCE -DHAVE_SYS_UIO_H -DANDROID -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D_FORTIFY_SOURCE=2 -DCOMPONENT_BUILD -DCR_LIBCXX_REVISION=344254 -DCR_LIBCXXABI_REVISION=344215 -D_LIBCPP_ENABLE_NODISCARD -D__GNU_SOURCE=1 -DCHROMIUM_CXX_TWEAK_INLINES -DNDEBUG -DNVALGRIND -DDYNAMIC_ANNOTATIONS_ENABLED=0 -I../</span>.. -Igen -I..<span class="regexp">/../</span>foundation<span class="regexp">/graphic/</span>standard<span class="regexp">/frameworks/</span>surface<span class="regexp">/include -I../</span>..<span class="regexp">/foundation/g</span>raphic<span class="regexp">/standard/i</span>nterfaces<span class="regexp">/innerkits/</span>surface -I..<span class="regexp">/../</span>foundation<span class="regexp">/graphic/</span>standard<span class="regexp">/interfaces/i</span>nnerkits<span class="regexp">/common -I../</span>..<span class="regexp">/utils/</span><span class="keyword">native</span><span class="regexp">/base/i</span>nclude -I..<span class="regexp">/../</span>developtools<span class="regexp">/liblog -I../</span>..<span class="regexp">/drivers/</span>peripheral<span class="regexp">/base -I../</span>..<span class="regexp">/drivers/</span>peripheral<span class="regexp">/display/i</span>nterfaces<span class="regexp">/include -I../</span>..<span class="regexp">/third_party/</span>bounds_checking_function<span class="regexp">/include -I../</span>..<span class="regexp">/foundation/</span>communication<span class="regexp">/ipc/i</span>nterfaces<span class="regexp">/innerkits/i</span>pc_core<span class="regexp">/include -I../</span>..<span class="regexp">/foundation/</span>communication<span class="regexp">/ipc/i</span>pc<span class="regexp">/native/</span>src<span class="regexp">/core/i</span>nclude -I..<span class="regexp">/../</span>foundation<span class="regexp">/communication/i</span>pc<span class="regexp">/ipc/</span><span class="keyword">native</span><span class="regexp">/src/m</span>ock<span class="regexp">/include -I../</span>..<span class="regexp">/utils/</span><span class="keyword">native</span><span class="regexp">/base/i</span>nclude -I..<span class="regexp">/../</span>foundation<span class="regexp">/graphic/</span>standard<span class="regexp">/utils/i</span>nclude -I..<span class="regexp">/../</span>drivers<span class="regexp">/peripheral/</span>base -I..<span class="regexp">/../</span>foundation<span class="regexp">/distributedschedule/</span>samgr<span class="regexp">/interfaces/i</span>nnerkits<span class="regexp">/samgr_proxy/i</span>nclude -I..<span class="regexp">/../</span>foundation<span class="regexp">/distributedschedule/</span>samgr<span class="regexp">/adapter/i</span>nterfaces<span class="regexp">/innerkits/i</span>nclude -I..<span class="regexp">/../</span>third_party<span class="regexp">/googletest/g</span>oogletest<span class="regexp">/include -I../</span>..<span class="regexp">/prebuilts/</span>aosp_prebuilt_libs<span class="regexp">/asdk_libs/</span>ndk<span class="regexp">/libcxx/i</span>nclude -fno-strict-aliasing --param=ssp-buffer-<span class="keyword">size</span>=<span class="number">4</span> -fstack-protector-strong -Wno-builtin-macro-redefined -D__DATE__= -D__TIME__= -D__TIMESTAMP__= -funwind-tables -fPIC -fcolor-diagnostics -fmerge-all-constants -Xclang -mllvm -Xclang -instcombine-lower-dbg-declare=<span class="number">0</span> -no-canonical-prefixes -fcomplete-member-pointers -ffunction-sections -fno-<span class="keyword">short</span>-enums --target=arm-linux-androideabi -isystem..<span class="regexp">/../</span>prebuilts<span class="regexp">/aosp_prebuilt_libs/</span>asdk_libs<span class="regexp">/ndk/</span>sysroot<span class="regexp">/usr/i</span>nclude<span class="regexp">/arm-linux-androideabi -D__ANDROID_API__=29 -march=armv7-a -mfloat-abi=softfp -mtune=generic-armv7-a -mfpu=neon -mthumb -Wall -Werror -Wextra -Wimplicit-fallthrough -Wthread-safety -Wno-missing-field-initializers -Wno-unused-parameter -Wno-c++11-narrowing -Wno-unneeded-internal-declaration -Wno-undefined-var-template -Wno-nonportable-include-path -Wno-user-defined-warnings -Wno-unused-lambda-capture -Wno-null-pointer-arithmetic -Wno-enum-compare-switch -O2 -fno-ident -fdata-sections -ffunction-sections -fomit-frame-pointer -gdwarf-3 -g2 -ggnu-pubnames -fno-common -Wheader-hygiene -Wstring-conversion -Wtautological-overlap-compare -fPIE -Wall -Werror -g3 -Dprivate=public -Dprotected=public -DBINDER_IPC_32BIT -DCONFIG_DUAL_FRAMEWORK -DBINDER_IPC_32BIT -DCONFIG_STANDARD_SYSTEM -DBUILD_PUBLIC_VERSION -std=c++17 -fno-exceptions -fno-rtti -nostdinc++ -isystem../</span>..<span class="regexp">/prebuilts/</span>aosp_prebuilt_libs<span class="regexp">/asdk_libs/</span>ndk<span class="regexp">/libcxx/i</span>nclude -isystem..<span class="regexp">/../</span>prebuilts<span class="regexp">/aosp_prebuilt_libs/</span>asdk_libs<span class="regexp">/ndk/</span>libcxxabi<span class="regexp">/include --sysroot=../</span>..<span class="regexp">/prebuilts/</span>aosp_prebuilt_libs<span class="regexp">/asdk_libs/</span>ndk<span class="regexp">/sysroot -fvisibility-inlines-hidden -c ../</span>..<span class="regexp">/foundation/g</span>raphic<span class="regexp">/standard/</span>frameworks<span class="regexp">/surface/</span>test<span class="regexp">/unittest/</span>buffer_queue_test.cpp -o obj<span class="regexp">/foundation/g</span>raphic<span class="regexp">/standard/</span>frameworks<span class="regexp">/surface/</span>test<span class="regexp">/unittest/</span>buffer_queue_test/buffer_queue_test.o</span><br><span class="line">..<span class="regexp">/../</span>foundation<span class="regexp">/graphic/</span>standard<span class="regexp">/frameworks/</span>surface<span class="regexp">/test/u</span>nittest/buffer_queue_test.cpp:<span class="number">71</span>:<span class="number">5</span>: error: no type named <span class="string">&#x27;RequestBufferReturnValue&#x27;</span> in <span class="string">&#x27;BufferQueue&#x27;</span>; did you mean <span class="string">&#x27;IBufferProducer::RequestBufferReturnValue&#x27;</span>?</span><br><span class="line">    BufferQueue::RequestBufferReturnValue retval;</span><br><span class="line">    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">    IBufferProducer::RequestBufferReturnValue</span><br><span class="line">..<span class="regexp">/../</span>foundation<span class="regexp">/graphic/</span>standard<span class="regexp">/interfaces/i</span>nnerkits<span class="regexp">/surface/i</span>buffer_producer.h:<span class="number">31</span>:<span class="number">12</span>: note: <span class="string">&#x27;IBufferProducer::RequestBufferReturnValue&#x27;</span> declared here</span><br><span class="line">    struct RequestBufferReturnValue &#123;</span><br><span class="line">           ^</span><br><span class="line">..<span class="regexp">/../</span>foundation<span class="regexp">/graphic/</span>standard<span class="regexp">/frameworks/</span>surface<span class="regexp">/test/u</span>nittest/buffer_queue_test.cpp:<span class="number">74</span>:<span class="number">63</span>: error: too few arguments to function <span class="keyword">call</span>, expected <span class="number">3</span>, have <span class="number">2</span></span><br><span class="line">    SurfaceError ret = bq-&gt;RequestBuffer(requestConfig, retval);</span><br><span class="line">                       ~~~~~~~~~~~~~~~~~                      ^</span><br><span class="line">..<span class="regexp">/../</span>foundation<span class="regexp">/graphic/</span>standard<span class="regexp">/frameworks/</span>surface<span class="regexp">/include/</span>buffer_queue.h:<span class="number">55</span>:<span class="number">5</span>: note: <span class="string">&#x27;RequestBuffer&#x27;</span> declared here</span><br><span class="line">    SurfaceError RequestBuffer(const BufferRequestConfig &amp;config, BufferExtraData &amp;bedata,</span><br><span class="line">    ^</span><br><span class="line">..<span class="regexp">/../</span>foundation<span class="regexp">/graphic/</span>standard<span class="regexp">/frameworks/</span>surface<span class="regexp">/test/u</span>nittest/buffer_queue_test.cpp:<span class="number">90</span>:<span class="number">29</span>: error: non-const lvalue reference to type <span class="string">&#x27;sptr&lt;SurfaceBufferImpl&gt;&#x27;</span> cannot bind to a value of unrelated type <span class="string">&#x27;sptr&lt;SurfaceBuffer&gt;&#x27;</span></span><br><span class="line">    ret = bq-&gt;AcquireBuffer(retval.buffer, retval.fence, timestamp, damage);</span><br><span class="line">                            ^~~~~~~~~~~~~</span><br><span class="line"><span class="number">3</span> errors generated.</span><br><span class="line">[<span class="number">224</span><span class="regexp">/2278] SOLINK hdf/</span>hdf/libcamera_pipeline_core.z.so</span><br><span class="line">[<span class="number">225</span><span class="regexp">/2278] CXX obj/</span>foundation<span class="regexp">/graphic/</span>standard<span class="regexp">/frameworks/</span>surface<span class="regexp">/test/</span>systemtest<span class="regexp">/surface_revert_ipc_test/</span>surface_revert_ipc_test.o</span><br><span class="line">[<span class="number">226</span><span class="regexp">/2278] CXX obj/</span>foundation<span class="regexp">/graphic/</span>standard<span class="regexp">/frameworks/</span>surface<span class="regexp">/test/</span>systemtest<span class="regexp">/surface_ipc_test/</span>surface_ipc_test.o</span><br><span class="line">[<span class="number">227</span><span class="regexp">/2278] CXX obj/</span>foundation<span class="regexp">/graphic/</span>standard<span class="regexp">/frameworks/</span>surface<span class="regexp">/test/u</span>nittest<span class="regexp">/buffer_manager_test/</span>buffer_manager_test.o</span><br><span class="line">[<span class="number">228</span><span class="regexp">/2278] CXX obj/</span>foundation<span class="regexp">/graphic/</span>standard<span class="regexp">/frameworks/</span>surface<span class="regexp">/test/u</span>nittest<span class="regexp">/consumer_surface_test/</span>consumer_surface_test.o</span><br><span class="line">ninja: build stopped: subcommand failed.</span><br><span class="line">build: ninja error</span><br><span class="line">used: <span class="number">49</span> seconds</span><br><span class="line">pycache statistics</span><br><span class="line">manage pycache contents</span><br><span class="line">pycache daemon exit</span><br><span class="line">EOF</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">crash_result=$(cat &lt;&lt; EOF</span><br><span class="line">audit: type=<span class="number">1400</span> audit(<span class="number">89.910</span>:<span class="number">313</span>): avc:  denied  &#123; ptrace &#125; <span class="keyword">for</span>  pid=<span class="number">508</span> comm=<span class="string">&quot;processdump&quot;</span> scontext=u:r:bootanim:s0 tcontext=u:r:bootanim:s0 tclass=process permissive=<span class="number">1</span></span><br><span class="line">audit: type=<span class="number">1400</span> audit(<span class="number">90.030</span>:<span class="number">314</span>): avc:  denied  &#123; <span class="keyword">write</span> &#125; <span class="keyword">for</span>  pid=<span class="number">508</span> comm=<span class="string">&quot;processdump&quot;</span> name=<span class="string">&quot;faultloggerd.server&quot;</span> dev=<span class="string">&quot;tmpfs&quot;</span> ino=<span class="number">10699</span> scontext=u:r:bootanim:s0 tcontext=u:object_r:socket_device:s0 tclass=sock_file permissive=<span class="number">1</span></span><br><span class="line">audit: type=<span class="number">1400</span> audit(<span class="number">90.030</span>:<span class="number">315</span>): avc:  denied  &#123; connectto &#125; <span class="keyword">for</span>  pid=<span class="number">508</span> comm=<span class="string">&quot;processdump&quot;</span> path=<span class="string">&quot;/dev/socket/faultloggerd.server&quot;</span> scontext=u:r:bootanim:s0 tcontext=u:r:faultloggerd:s0 tclass=unix_stream_socket permissive=<span class="number">1</span></span><br><span class="line">audit: type=<span class="number">1400</span> audit(<span class="number">90.030</span>:<span class="number">316</span>): avc:  denied  &#123; search &#125; <span class="keyword">for</span>  pid=<span class="number">355</span> comm=<span class="string">&quot;faultloggerd&quot;</span> name=<span class="string">&quot;faultlog&quot;</span> dev=<span class="string">&quot;mmcblk0p7&quot;</span> ino=<span class="number">102</span> scontext=u:r:faultloggerd:s0 tcontext=u:object_r:faultlogger_core_file:s0 tclass=dir permissive=<span class="number">1</span></span><br><span class="line">audit: type=<span class="number">1400</span> audit(<span class="number">90.030</span>:<span class="number">317</span>): avc:  denied  &#123; use &#125; <span class="keyword">for</span>  pid=<span class="number">508</span> comm=<span class="string">&quot;processdump&quot;</span> path=<span class="string">&quot;/data/log/faultlog/temp/cppcrash-360-90&quot;</span> dev=<span class="string">&quot;mmcblk0p7&quot;</span> ino=<span class="number">1002</span> scontext=u:r:bootanim:s0 tcontext=u:r:faultloggerd:s0 tclass=fd permissive=<span class="number">1</span></span><br><span class="line">DEBUG: *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***</span><br><span class="line">DEBUG: Build fingerprint: <span class="string">&#x27;10/QP1A.190711.020/.20210529.152153:userdebug/test-keys&#x27;</span></span><br><span class="line">DEBUG: Revision: <span class="string">&#x27;0&#x27;</span></span><br><span class="line">DEBUG: ABI: <span class="string">&#x27;arm&#x27;</span></span><br><span class="line">DEBUG: Timestamp: <span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">01</span>:<span class="number">30</span>+<span class="number">0000</span></span><br><span class="line">DEBUG: pid: <span class="number">360</span>, tid: <span class="number">360</span>, name: bootanimation  &gt;&gt;&gt; <span class="regexp">/system/</span>bin/bootanimation &lt;&lt;&lt;</span><br><span class="line">DEBUG: uid: <span class="number">0</span></span><br><span class="line">DEBUG: signal <span class="number">6</span> (SIGABRT), code -<span class="number">1</span> (SI_QUEUE), fault addr --------</span><br><span class="line">DEBUG: Abort message: <span class="string">&#x27;terminating&#x27;</span></span><br><span class="line">DEBUG:     r0  <span class="number">00000000</span>  r1  <span class="number">00000168</span>  r2  <span class="number">00000006</span>  r3  be916230</span><br><span class="line">DEBUG:     r4  be916244  r5  be916228  r6  <span class="number">00000168</span>  r7  <span class="number">0000016</span>b</span><br><span class="line">DEBUG:     r8  be916240  r9  be916230  r10 be916260  r11 be916250</span><br><span class="line">DEBUG:     ip  <span class="number">00000168</span>  sp  be916200  lr  af442c43  pc  af442c56</span><br><span class="line">DEBUG:</span><br><span class="line">DEBUG: backtrace:</span><br><span class="line">DEBUG:       #<span class="number">00</span> pc <span class="number">0005</span>ec56  <span class="regexp">/system/</span>lib/libc.so (abort+<span class="number">166</span>) (BuildId: <span class="number">1</span>e8dd9673cd9bca53ad6598c9241a872)</span><br><span class="line">DEBUG:       #<span class="number">01</span> pc <span class="number">0003606</span>d  <span class="regexp">/system/</span>lib/libc++.so (abort_message+<span class="number">88</span>) (BuildId: <span class="number">09</span>dfdb05bee9d1ae619e760b283fba69)</span><br><span class="line">DEBUG:       #<span class="number">02</span> pc <span class="number">00036161</span>  <span class="regexp">/system/</span>lib/libc++.so (demangling_terminate_handler()+<span class="number">24</span>) (BuildId: <span class="number">09</span>dfdb05bee9d1ae619e760b283fba69)</span><br><span class="line">DEBUG:       #<span class="number">03</span> pc <span class="number">00044</span>ecb  <span class="regexp">/system/</span>lib/libc++.so (std::__terminate(<span class="keyword">void</span> (*)())+<span class="number">2</span>) (BuildId: <span class="number">09</span>dfdb05bee9d1ae619e760b283fba69)</span><br><span class="line">DEBUG:       #<span class="number">04</span> pc <span class="number">00044</span>e69  <span class="regexp">/system/</span>lib/libc++.so (std::terminate()+<span class="number">28</span>) (BuildId: <span class="number">09</span>dfdb05bee9d1ae619e760b283fba69)</span><br><span class="line">DEBUG:       #<span class="number">05</span> pc <span class="number">0007</span>fedf  <span class="regexp">/system/</span>lib/libc++.so (std::__1::thread::~thread()+<span class="number">10</span>) (BuildId: <span class="number">09</span>dfdb05bee9d1ae619e760b283fba69)</span><br><span class="line">DEBUG:       #<span class="number">06</span> pc <span class="number">00008127</span>  <span class="regexp">/system/</span>lib/libwmservice.z.so (BuildId: <span class="number">9599</span>fc3faca5bb5b3e001aab2717d0fd)</span><br><span class="line">DEBUG:       #<span class="number">07</span> pc <span class="number">0000816</span>b  <span class="regexp">/system/</span>lib/libwmservice.z.so (BuildId: <span class="number">9599</span>fc3faca5bb5b3e001aab2717d0fd)</span><br><span class="line">DEBUG:       #<span class="number">08</span> pc <span class="number">0000701</span>b  <span class="regexp">/system/</span>lib/libwmservice.z.so (BuildId: <span class="number">9599</span>fc3faca5bb5b3e001aab2717d0fd)</span><br><span class="line">DEBUG:       #<span class="number">09</span> pc <span class="number">000</span>a83ad  <span class="regexp">/system/</span>lib/libc.so (__cxa_finalize+<span class="number">144</span>) (BuildId: <span class="number">1</span>e8dd9673cd9bca53ad6598c9241a872)</span><br><span class="line">DEBUG:       #<span class="number">10</span> pc <span class="number">000</span>a3921  <span class="regexp">/system/</span>lib/libc.so (exit+<span class="number">10</span>) (BuildId: <span class="number">1</span>e8dd9673cd9bca53ad6598c9241a872)</span><br><span class="line">DEBUG:       #<span class="number">11</span> pc <span class="number">00005</span>acb  <span class="regexp">/system/</span>bin/bootanimation (BuildId: <span class="number">1757</span>f806e491b8a26c075566e8d5a677)</span><br><span class="line">DEBUG:       #<span class="number">12</span> pc <span class="number">00005</span>aa3  <span class="regexp">/system/</span>bin/bootanimation (BuildId: <span class="number">1757</span>f806e491b8a26c075566e8d5a677)</span><br><span class="line">DEBUG:       #<span class="number">13</span> pc <span class="number">00005</span>a9d  <span class="regexp">/system/</span>bin/bootanimation (BuildId: <span class="number">1757</span>f806e491b8a26c075566e8d5a677)</span><br><span class="line">DEBUG:       #<span class="number">14</span> pc <span class="number">00005</span>a97  <span class="regexp">/system/</span>bin/bootanimation (BuildId: <span class="number">1757</span>f806e491b8a26c075566e8d5a677)</span><br><span class="line">DEBUG:       #<span class="number">15</span> pc <span class="number">00009</span>d85  <span class="regexp">/system/</span>lib/libeventhandler.z.so (AppExecFwk::EventHandler::DistributeEvent(std::__1::unique_ptr&lt;AppExecFwk::InnerEvent, <span class="keyword">void</span> (*)(AppExecFwk::InnerEvent*)&gt; const&amp;)+<span class="number">384</span>) (BuildId: <span class="number">19</span>d5f5844c6c7884d930e6249486696f)</span><br><span class="line">DEBUG:       #<span class="number">16</span> pc <span class="number">0000</span>f3d7  <span class="regexp">/system/</span>lib/libeventhandler.z.so (BuildId: <span class="number">19</span>d5f5844c6c7884d930e6249486696f)</span><br><span class="line">DEBUG:       #<span class="number">17</span> pc <span class="number">0000</span>e613  <span class="regexp">/system/</span>lib/libeventhandler.z.so (AppExecFwk::EventRunner::Run()+<span class="number">62</span>) (BuildId: <span class="number">19</span>d5f5844c6c7884d930e6249486696f)</span><br><span class="line">DEBUG:       #<span class="number">18</span> pc <span class="number">00005303</span>  <span class="regexp">/system/</span>bin/bootanimation (BuildId: <span class="number">1757</span>f806e491b8a26c075566e8d5a677)</span><br><span class="line">DEBUG:       #<span class="number">19</span> pc <span class="number">00059213</span>  <span class="regexp">/system/</span>lib/libc.so (__libc_init+<span class="number">66</span>) (BuildId: <span class="number">1</span>e8dd9673cd9bca53ad6598c9241a872)</span><br><span class="line">DEBUG:       #<span class="number">20</span> pc <span class="number">00005033</span>  <span class="regexp">/system/</span>bin/bootanimation (BuildId: <span class="number">1757</span>f806e491b8a26c075566e8d5a677)</span><br><span class="line">DEBUG:       #<span class="number">21</span> pc <span class="number">0002</span>ef2b  <span class="regexp">/system/</span>bin/linker (__dl__ZN6soinfoD1Ev+<span class="number">14</span>) (BuildId: bbc02384daaf0dda5631ee38f31bd6aa)</span><br><span class="line">DEBUG:       #<span class="number">22</span> pc <span class="number">00020</span>b37  [stack]</span><br><span class="line">init: Service <span class="string">&#x27;bootanimation&#x27;</span> (pid <span class="number">360</span>) received signal <span class="number">6</span></span><br><span class="line">init: Untracked pid <span class="number">512</span> exited with status <span class="number">0</span></span><br><span class="line">init: Untracked pid <span class="number">514</span> exited with status <span class="number">0</span></span><br><span class="line">EOF</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">log_result=$(cat &lt;&lt; EOF</span><br><span class="line">[<span class="number">2021</span>-<span class="number">05</span>-<span class="number">26</span> <span class="number">17</span>:<span class="number">11</span>:<span class="number">58</span>] <span class="number">01</span>-<span class="number">01</span> <span class="number">05</span>:<span class="number">54</span>:<span class="number">51.075</span>   <span class="number">262</span>   <span class="number">274</span> I <span class="number">02903</span>/BatterySrvClient: [battery_srv_client.cpp] GetChargingStatus#  Calling GetChargingStatus Success!</span><br><span class="line">[<span class="number">2021</span>-<span class="number">05</span>-<span class="number">26</span> <span class="number">17</span>:<span class="number">11</span>:<span class="number">58</span>] <span class="number">01</span>-<span class="number">01</span> <span class="number">05</span>:<span class="number">54</span>:<span class="number">51.075</span>   <span class="number">262</span>   <span class="number">274</span> D <span class="number">02907</span>/PowerMgrJSNAPI: [battery_info.cpp] GetChargingState# chargeState <span class="number">0</span></span><br><span class="line">[<span class="number">2021</span>-<span class="number">05</span>-<span class="number">26</span> <span class="number">17</span>:<span class="number">11</span>:<span class="number">58</span>] <span class="number">01</span>-<span class="number">01</span> <span class="number">05</span>:<span class="number">54</span>:<span class="number">51.075</span>   <span class="number">262</span>   <span class="number">274</span> I <span class="number">03</span>b00/JSApp: app Log: SystemUI_StatusBar tag:batteryStatus --&gt;Battery updateBattery checkBatteryStatus: <span class="number">0</span></span><br><span class="line">[<span class="number">2021</span>-<span class="number">05</span>-<span class="number">26</span> <span class="number">17</span>:<span class="number">11</span>:<span class="number">58</span>] <span class="number">01</span>-<span class="number">01</span> <span class="number">05</span>:<span class="number">54</span>:<span class="number">51.075</span>   <span class="number">262</span>   <span class="number">274</span> I <span class="number">03</span>b00/JSApp: app Log: SystemUI_StatusBar tag:batteryStatus --&gt;Battery updateBattery: <span class="number">100</span> charging: <span class="keyword">true</span></span><br><span class="line">[<span class="number">2021</span>-<span class="number">05</span>-<span class="number">26</span> <span class="number">17</span>:<span class="number">11</span>:<span class="number">58</span>] <span class="number">01</span>-<span class="number">01</span> <span class="number">05</span>:<span class="number">54</span>:<span class="number">51.075</span>   <span class="number">262</span>   <span class="number">274</span> I <span class="number">03</span>b00/JSApp: app Log: SystemUI_StatusBar tag:batteryStatus --&gt;Battery updateBattery mBackgroundColor: #<span class="number">00</span>ff21</span><br><span class="line">[<span class="number">2021</span>-<span class="number">05</span>-<span class="number">26</span> <span class="number">17</span>:<span class="number">11</span>:<span class="number">58</span>] <span class="number">01</span>-<span class="number">01</span> <span class="number">05</span>:<span class="number">54</span>:<span class="number">51.090</span>   <span class="number">202</span>   <span class="number">217</span> W <span class="number">01510</span>/IPCObjectProxy: no databus session attach to <span class="keyword">this</span> handle, maybe need update</span><br><span class="line">[<span class="number">2021</span>-<span class="number">05</span>-<span class="number">26</span> <span class="number">17</span>:<span class="number">11</span>:<span class="number">58</span>] <span class="number">01</span>-<span class="number">01</span> <span class="number">05</span>:<span class="number">54</span>:<span class="number">51.090</span>   <span class="number">262</span>   <span class="number">262</span> E <span class="number">01510</span>/IPCObjectStub: IPCObjectStub::ProcessProto called, type = <span class="number">0</span>, normal stub object</span><br><span class="line">[<span class="number">2021</span>-<span class="number">05</span>-<span class="number">26</span> <span class="number">17</span>:<span class="number">11</span>:<span class="number">58</span>] <span class="number">01</span>-<span class="number">01</span> <span class="number">05</span>:<span class="number">54</span>:<span class="number">51.090</span>   <span class="number">202</span>   <span class="number">217</span> W <span class="number">01510</span>/IPCObjectProxy: it is normal binder, not dbinder</span><br><span class="line">[<span class="number">2021</span>-<span class="number">05</span>-<span class="number">26</span> <span class="number">17</span>:<span class="number">11</span>:<span class="number">58</span>] <span class="number">01</span>-<span class="number">01</span> <span class="number">05</span>:<span class="number">54</span>:<span class="number">51.091</span>   <span class="number">262</span>   <span class="number">262</span> I <span class="number">00000</span>/VsyncHelperImpl: RequestNextVsync: Success, Way: ListenNextVsync</span><br><span class="line">[<span class="number">2021</span>-<span class="number">05</span>-<span class="number">26</span> <span class="number">17</span>:<span class="number">11</span>:<span class="number">58</span>] <span class="number">01</span>-<span class="number">01</span> <span class="number">05</span>:<span class="number">54</span>:<span class="number">51.091</span>   <span class="number">262</span>   <span class="number">262</span> I <span class="number">00000</span>/VsyncHelperImpl: RequestFrameCallback: Success, Way: RequestNextVsync time: <span class="number">0</span></span><br><span class="line">[<span class="number">2021</span>-<span class="number">05</span>-<span class="number">26</span> <span class="number">17</span>:<span class="number">11</span>:<span class="number">58</span>] <span class="number">01</span>-<span class="number">01</span> <span class="number">05</span>:<span class="number">54</span>:<span class="number">51.099</span>   <span class="number">262</span>   <span class="number">262</span> I <span class="number">00000</span>/VsyncHelperImpl: operator(): DispatchFrameCallback, time: <span class="number">21291099810</span>, timestamp: <span class="number">2559319676620</span></span><br><span class="line">[<span class="number">2021</span>-<span class="number">05</span>-<span class="number">26</span> <span class="number">17</span>:<span class="number">11</span>:<span class="number">58</span>] <span class="number">01</span>-<span class="number">01</span> <span class="number">05</span>:<span class="number">54</span>:<span class="number">51.100</span>   <span class="number">202</span>   <span class="number">219</span> W <span class="number">01510</span>/IPCObjectProxy: it is normal binder, <span class="keyword">try</span> to <span class="keyword">delete</span> handle to index</span><br><span class="line">[<span class="number">2021</span>-<span class="number">05</span>-<span class="number">26</span> <span class="number">17</span>:<span class="number">11</span>:<span class="number">58</span>] <span class="number">01</span>-<span class="number">01</span> <span class="number">05</span>:<span class="number">54</span>:<span class="number">51.100</span>   <span class="number">262</span>   <span class="number">267</span> W <span class="number">01510</span>/IPCObjectStub: IPCObjectStub destroyed</span><br><span class="line">[<span class="number">2021</span>-<span class="number">05</span>-<span class="number">26</span> <span class="number">17</span>:<span class="number">11</span>:<span class="number">58</span>] <span class="number">01</span>-<span class="number">01</span> <span class="number">05</span>:<span class="number">54</span>:<span class="number">51.100</span>   <span class="number">202</span>   <span class="number">219</span> W <span class="number">01510</span>/IPCObjectProxy: handle = <span class="number">1</span> destroyed</span><br><span class="line">[<span class="number">2021</span>-<span class="number">05</span>-<span class="number">26</span> <span class="number">17</span>:<span class="number">11</span>:<span class="number">58</span>] <span class="number">01</span>-<span class="number">01</span> <span class="number">05</span>:<span class="number">54</span>:<span class="number">51.130</span>   <span class="number">262</span>   <span class="number">274</span> I <span class="number">03900</span>/Ace: [&lt;<span class="keyword">private</span>&gt;(&lt;<span class="keyword">private</span>&gt;)] ace Log: [JS Framework] (debug)</span><br><span class="line">[<span class="number">2021</span>-<span class="number">05</span>-<span class="number">26</span> <span class="number">17</span>:<span class="number">11</span>:<span class="number">58</span>] <span class="number">01</span>-<span class="number">01</span> <span class="number">05</span>:<span class="number">54</span>:<span class="number">51.130</span>   <span class="number">262</span>   <span class="number">274</span> I <span class="number">03900</span>/Ace: [&lt;<span class="keyword">private</span>&gt;(&lt;<span class="keyword">private</span>&gt;)] ace Log: [JS Framework] (debug)</span><br><span class="line">[<span class="number">2021</span>-<span class="number">05</span>-<span class="number">26</span> <span class="number">17</span>:<span class="number">11</span>:<span class="number">58</span>] <span class="number">01</span>-<span class="number">01</span> <span class="number">05</span>:<span class="number">54</span>:<span class="number">51.150</span>   <span class="number">202</span>   <span class="number">217</span> W <span class="number">01510</span>/IPCObjectProxy: no databus session attach to <span class="keyword">this</span> handle, maybe need update</span><br><span class="line">EOF</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">echo -e <span class="string">&quot;\n\n&quot;</span><span class="string">&#x27;echo &quot;$compile_result&quot; | grep &quot;error:&quot;&#x27;</span></span><br><span class="line">echo <span class="string">&quot;$compile_result&quot;</span> | <span class="keyword">grep</span> <span class="string">&quot;error:&quot;</span></span><br><span class="line"></span><br><span class="line">echo -e <span class="string">&quot;\n\n&quot;</span><span class="string">&#x27;echo &quot;$crash_result&quot; | grep &quot; pc &quot;&#x27;</span></span><br><span class="line">echo <span class="string">&quot;$crash_result&quot;</span> | <span class="keyword">grep</span> <span class="string">&quot; pc 0&quot;</span></span><br><span class="line"></span><br><span class="line">echo -e <span class="string">&quot;\n\n&quot;</span><span class="string">&#x27;echo &quot;$log_result&quot; | egrep &quot;/(JSApp|Ace)&quot;&#x27;</span></span><br><span class="line">echo <span class="string">&quot;$log_result&quot;</span> | egrep <span class="string">&quot;/(JSApp|Ace)&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo -e <span class="string">&quot;\n\n&quot;</span><span class="string">&#x27;echo &quot;$crash_result&quot; | sed s/\([^(]*\)(.*\(BuildId\)/\1(\2/g&#x27;</span></span><br><span class="line">echo <span class="string">&quot;$crash_result&quot;</span> | sed <span class="string">&#x27;s/\([^(]*\)(.*\(BuildId\)/\1(\2/g&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo -e <span class="string">&quot;\n\n&quot;</span><span class="string">&#x27;echo &quot;$crash_result&quot; | grep &quot; pc 0&quot; | awk &#123;print $5&#125;&#x27;</span></span><br><span class="line">echo <span class="string">&quot;$crash_result&quot;</span> | <span class="keyword">grep</span> <span class="string">&quot; pc 0&quot;</span> | awk <span class="string">&#x27;&#123;print $5&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">echo -e <span class="string">&quot;\n\n&quot;</span><span class="string">&#x27;echo &quot;$crash_result&quot; | sed s/\([^(]*\)(.*\(BuildId\)/\1(\2/g | grep &quot; pc 0&quot; | awk &#123;print $6 $7&#125;&#x27;</span></span><br><span class="line">echo <span class="string">&quot;$crash_result&quot;</span> | sed <span class="string">&#x27;s/\([^(]*\)(.*\(BuildId\)/\1(\2/g&#x27;</span> | <span class="keyword">grep</span> <span class="string">&quot; pc 0&quot;</span> | awk <span class="string">&#x27;&#123;print $6 $7&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">echo -e <span class="string">&quot;\n\n&quot;</span><span class="string">&#x27;echo &quot;$crash_result&quot; | grep &quot; pc 0&quot; | awk &#123;print $(NF-1)$(NF)&#125;&#x27;</span></span><br><span class="line">echo <span class="string">&quot;$crash_result&quot;</span> | <span class="keyword">grep</span> <span class="string">&quot; pc 0&quot;</span> | awk <span class="string">&#x27;&#123;print $(NF-1)$(NF)&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">echo -e <span class="string">&quot;\n\n&quot;</span><span class="string">&#x27;echo &quot;$crash_result&quot; | grep &quot; pc 0&quot; | awk -F pc &#123;print $2&#125;&#x27;</span></span><br><span class="line">echo <span class="string">&quot;$crash_result&quot;</span> | <span class="keyword">grep</span> <span class="string">&quot; pc 0&quot;</span> | awk -F <span class="string">&#x27;pc&#x27;</span> <span class="string">&#x27;&#123;print $2&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo -e <span class="string">&quot;\n\n&quot;</span><span class="string">&#x27;echo &quot;$compile_result&quot; | grep &quot;error:&quot; | cut -d: -f1&#x27;</span></span><br><span class="line">echo <span class="string">&quot;$compile_result&quot;</span> | <span class="keyword">grep</span> <span class="string">&quot;error:&quot;</span> | cut -d: -f1</span><br><span class="line"></span><br><span class="line">echo -e <span class="string">&quot;\n\n&quot;</span><span class="string">&#x27;echo &quot;$compile_result&quot; | grep &quot;error:&quot; | cut -d: -f2&#x27;</span></span><br><span class="line">echo <span class="string">&quot;$compile_result&quot;</span> | <span class="keyword">grep</span> <span class="string">&quot;error:&quot;</span> | cut -d: -f2</span><br><span class="line"></span><br><span class="line">echo -e <span class="string">&quot;\n\n&quot;</span><span class="string">&#x27;echo &quot;$compile_result&quot; | grep &quot;error:&quot; | cut -d: -f3&#x27;</span></span><br><span class="line">echo <span class="string">&quot;$compile_result&quot;</span> | <span class="keyword">grep</span> <span class="string">&quot;error:&quot;</span> | cut -d: -f3</span><br><span class="line"></span><br><span class="line">echo -e <span class="string">&quot;\n\n&quot;</span><span class="string">&#x27;echo &quot;$compile_result&quot; | grep &quot;error:&quot; | cut -d: -f4&#x27;</span></span><br><span class="line">echo <span class="string">&quot;$compile_result&quot;</span> | <span class="keyword">grep</span> <span class="string">&quot;error:&quot;</span> | cut -d: -f4</span><br><span class="line"></span><br><span class="line">echo -e <span class="string">&quot;\n\n&quot;</span><span class="string">&#x27;echo &quot;$compile_result&quot; | grep &quot;error:&quot; | cut -d: -f5-&#x27;</span></span><br><span class="line">echo <span class="string">&quot;$compile_result&quot;</span> | <span class="keyword">grep</span> <span class="string">&quot;error:&quot;</span> | cut -d: -f5-</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cachefish.github.io/2022/04/01/while/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2229.jfif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="来世做春风，浪漫且自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cachecatのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/01/while/" class="post-title-link" itemprop="url">while</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-01 19:30:00" itemprop="dateCreated datePublished" datetime="2022-04-01T19:30:00+08:00">2022-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-07 09:58:16" itemprop="dateModified" datetime="2022-04-07T09:58:16+08:00">2022-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux-shell/" itemprop="url" rel="index"><span itemprop="name">linux shell</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> case.1: <span class="keyword">while</span>拥有改变变量的能力</span><br><span class="line">Array=()</span><br><span class="line"></span><br><span class="line">cnt=1</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$cnt</span> -le 5 ]; <span class="keyword">do</span></span><br><span class="line">    Array+=(<span class="variable">$cnt</span>)</span><br><span class="line">    ((cnt++))</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> before <span class="variable">$&#123;Array[@]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> case.2: 在管道里<span class="keyword">while</span>无法改变管道外的变量</span><br><span class="line">Array=()</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;1\n2\n3\n4\n5&quot;</span> | <span class="keyword">while</span> <span class="built_in">read</span> str; <span class="keyword">do</span></span><br><span class="line">    Array+=(<span class="variable">$str</span>)</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$&#123;Array[@]&#125;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> after <span class="variable">$&#123;Array[@]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> case.3: 逐行读取还改变变量的例子</span><br><span class="line">task_output=$(<span class="built_in">echo</span> -e <span class="string">&quot;1\n2\n3\n4\n5&quot;</span>)</span><br><span class="line">Array=()</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> str; <span class="keyword">do</span></span><br><span class="line">    Array+=(<span class="variable">$str</span>)</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$&#123;Array[@]&#125;</span></span><br><span class="line"><span class="keyword">done</span> &lt;&lt;&lt; <span class="string">&quot;<span class="variable">$task_output</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> final: <span class="variable">$&#123;Array[@]&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cachefish.github.io/2022/04/01/%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2229.jfif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="来世做春风，浪漫且自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cachecatのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/01/%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">thread</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-01 19:30:00" itemprop="dateCreated datePublished" datetime="2022-04-01T19:30:00+08:00">2022-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-07 09:57:50" itemprop="dateModified" datetime="2022-04-07T09:57:50+08:00">2022-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux-c/" itemprop="url" rel="index"><span itemprop="name">linux c++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h3><p>将类成员变量声明为static，则为静态成员变量，与一般的成员变量不同，无论建立多少对象，都只有一个静态成员变量的拷贝，静态成员变量属于一个类，所有对象共享。</p>
<p>静态变量在编译阶段就分配了空间，对象还没创建时就已经分配了空间，放到全局静态区。</p>
<h4 id="静态成员变量-1"><a href="#静态成员变量-1" class="headerlink" title="静态成员变量"></a>静态成员变量</h4><ul>
<li>最好是类内声明，类外初始化（以免类名访问静态成员访问不到）。</li>
<li>无论公有，私有，静态成员都可以在类外定义，但私有成员仍有访问权限。</li>
<li>非静态成员类外不能初始化。</li>
<li>静态成员数据是共享的。</li>
</ul>
<h5 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h5><p>将类成员函数声明为static，则为静态成员函数。</p>
<ul>
<li><p>静态成员函数</p>
<ul>
<li>静态成员函数可以直接访问静态成员变量，不能直接访问普通成员变量，但可以通过参数传递的方式访问。</li>
<li>普通成员函数可以访问普通成员变量，也可以访问静态成员变量。</li>
<li>静态成员函数没有this指针。非静态数据成员为对象单独维护，但静态成员函数为共享函数，无法区分是哪个对象，因此不能直接访问普通变量成员，也没有this指针。</li>
</ul>
</li>
</ul>
<h4 id="pthread-create陷阱"><a href="#pthread-create陷阱" class="headerlink" title="pthread_create陷阱"></a>pthread_create陷阱</h4><p>首先看一下该函数的函数原型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_create</span> <span class="params">(<span class="type">pthread_t</span> *thread_tid,                 <span class="comment">//返回新生成的线程的id</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,         <span class="comment">//指向线程属性的指针,通常设置为NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">void</span> * (*start_routine) (<span class="type">void</span> *),   <span class="comment">//处理线程函数的地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">void</span> *arg)</span></span>;                         <span class="comment">//start_routine()中的参数</span></span><br></pre></td></tr></table></figure>
<p>函数原型中的第三个参数，为函数指针，指向处理线程函数的地址。该函数，要求为静态函数。如果处理线程函数为类成员函数时，需要将其设置为静态成员函数。</p>
<h4 id="this指针的锅"><a href="#this指针的锅" class="headerlink" title="this指针的锅"></a>this指针的锅</h4><p>pthread_create的函数原型中第三个参数的类型为函数指针，指向的线程处理函数参数类型为(void <em>),若线程函数为类成员函数，则this指针会作为默认的参数被传进函数中，从而和线程函数参数(void</em>)不能匹配，不能通过编译。</p>
<p>静态成员函数就没有这个问题，里面没有this指针。</p>
<h5 id="线程池分析"><a href="#线程池分析" class="headerlink" title="线程池分析"></a>线程池分析</h5><p>线程池的设计模式为半同步&#x2F;半反应堆，其中反应堆具体为Proactor事件处理模式。</p>
<p>具体的，主线程为异步线程，负责监听文件描述符，接收socket新连接，若当前监听的socket发生了读写事件，然后将任务插入到请求队列。工作线程从请求队列中取出任务，完成读写数据的处理。</p>
<p>线程池类定义<br>线程处理函数和运行函数设置为私有属性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">threadpool</span>&#123;</span><br><span class="line">     <span class="keyword">public</span>:</span><br><span class="line">         <span class="comment">//thread_number是线程池中线程的数量</span></span><br><span class="line">        <span class="comment">//max_requests是请求队列中最多允许的、等待处理的请求的数量</span></span><br><span class="line">         <span class="comment">//connPool是数据库连接池指针</span></span><br><span class="line">         <span class="built_in">threadpool</span>(connection_pool *connPool, <span class="type">int</span> thread_number = <span class="number">8</span>, <span class="type">int</span> max_request = <span class="number">10000</span>);</span><br><span class="line">         ~<span class="built_in">threadpool</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//像请求队列中插入任务请求</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">append</span><span class="params">(T* request)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">//工作线程运行的函数</span></span><br><span class="line">        <span class="comment">//它不断从工作队列中取出任务并执行之</span></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">worker</span><span class="params">(<span class="type">void</span> *arg)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">//线程池中的线程数</span></span><br><span class="line">        <span class="type">int</span> m_thread_number;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//请求队列中允许的最大请求数</span></span><br><span class="line">        <span class="type">int</span> m_max_requests;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//描述线程池的数组，其大小为m_thread_number</span></span><br><span class="line">        <span class="type">pthread_t</span> *m_threads;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//请求队列</span></span><br><span class="line">        std::list&lt;T *&gt;m_workqueue;    </span><br><span class="line"></span><br><span class="line">        <span class="comment">//保护请求队列的互斥锁    </span></span><br><span class="line">        locker m_queuelocker;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//是否有任务需要处理</span></span><br><span class="line">        sem m_queuestat;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//是否结束线程</span></span><br><span class="line">        <span class="type">bool</span> m_stop;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数据库连接池</span></span><br><span class="line">        connection_pool *m_connPool;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="线程池创建与回收"><a href="#线程池创建与回收" class="headerlink" title="线程池创建与回收"></a>线程池创建与回收</h5><p>构造函数中创建线程池,pthread_create函数中将类的对象作为参数传递给静态函数(worker),在静态函数中引用这个对象,并调用其动态方法(run)。</p>
<p>具体的，类对象传递时用this指针，传递给静态函数后，将其转换为线程池类，并调用私有成员函数run。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line"> threadpool&lt;T&gt;::threadpool( connection_pool *connPool, <span class="built_in">int</span> thread_number, <span class="built_in">int</span> max_requests) : m<span class="constructor">_thread_number(<span class="params">thread_number</span>)</span>, m<span class="constructor">_max_requests(<span class="params">max_requests</span>)</span>, m<span class="constructor">_stop(<span class="params">false</span>)</span>, m<span class="constructor">_threads(NULL)</span>,m<span class="constructor">_connPool(<span class="params">connPool</span>)</span>&#123;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">if</span>(thread_number&lt;=<span class="number">0</span><span class="pattern-match"><span class="operator">||</span>max<span class="constructor">_requests</span>&lt;=0)</span></span><br><span class="line"><span class="pattern-match">         throw std::<span class="keyword">exception</span>();</span></span><br><span class="line"><span class="pattern-match"> </span></span><br><span class="line"><span class="pattern-match">     <span class="operator">/</span><span class="operator">/</span>线程id初始化</span></span><br><span class="line"><span class="pattern-match">     m<span class="constructor">_threads</span>=<span class="keyword">new</span> pthread<span class="constructor">_t</span>[m<span class="constructor">_thread_number</span>];</span></span><br><span class="line"><span class="pattern-match">     <span class="keyword">if</span>(!m<span class="constructor">_threads</span>)</span></span><br><span class="line"><span class="pattern-match">        throw std::<span class="keyword">exception</span>();</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">for</span>(<span class="built_in">int</span> i=0;i&lt;thread<span class="constructor">_number</span>;<span class="operator">++</span>i)</span></span><br><span class="line"><span class="pattern-match">    &#123;</span></span><br><span class="line"><span class="pattern-match">        <span class="operator">/</span><span class="operator">/</span>循环创建线程，并将工作线程按要求进行运行</span></span><br><span class="line"><span class="pattern-match">        <span class="keyword">if</span>(pthread<span class="constructor">_create(<span class="params">m_threads</span>+<span class="params">i</span>,NULL,<span class="params">worker</span>,<span class="params">this</span>)</span>!=0)&#123;</span></span><br><span class="line"><span class="pattern-match">            delete [] m<span class="constructor">_threads</span>;</span></span><br><span class="line"><span class="pattern-match">            throw std::<span class="keyword">exception</span>();</span></span><br><span class="line"><span class="pattern-match">        &#125;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">        <span class="operator">/</span><span class="operator">/</span>将线程进行分离后，不用单独对工作线程进行回收        <span class="keyword">if</span>(pthread<span class="constructor">_detach(<span class="params">m_threads</span>[<span class="params">i</span>])</span>)&#123;</span></span><br><span class="line"><span class="pattern-match">            delete[] m<span class="constructor">_threads</span>;</span></span><br><span class="line"><span class="pattern-match">            throw std::<span class="keyword">exception</span>();</span></span><br><span class="line"><span class="pattern-match">        &#125;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure>
<h5 id="向请求队列中添加任务"><a href="#向请求队列中添加任务" class="headerlink" title="向请求队列中添加任务"></a>向请求队列中添加任务</h5><p>通过list容器创建请求队列，向队列中添加时，通过互斥锁保证线程安全，添加完成后通过信号量提醒有任务要处理，最后注意线程同步。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line"> bool threadpool&lt;T&gt;::append(T* request)</span><br><span class="line"> &#123;</span><br><span class="line">     m_queuelocker<span class="selector-class">.lock</span>();</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//根据硬件，预先设置请求队列的最大值</span></span><br><span class="line">    <span class="built_in">if</span>(m_workqueue.size()&gt;m_max_requests)</span><br><span class="line">     &#123;</span><br><span class="line">         m_queuelocker<span class="selector-class">.unlock</span>();</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加任务</span></span><br><span class="line">    m_workqueue<span class="selector-class">.push_back</span>(request);</span><br><span class="line">    m_queuelocker<span class="selector-class">.unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//信号量提醒有任务要处理</span></span><br><span class="line">    m_queuestat<span class="selector-class">.post</span>();</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="线程处理函数"><a href="#线程处理函数" class="headerlink" title="线程处理函数"></a>线程处理函数</h5><p>内部访问私有成员函数run，完成线程处理要求。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span>* threadpool&lt;T&gt;::<span class="built_in">worker</span>(<span class="type">void</span>* arg)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将参数强转为线程池类，调用成员方法</span></span><br><span class="line">   threadpool* pool=(threadpool*)arg;</span><br><span class="line">    pool-&gt;<span class="built_in">run</span>();</span><br><span class="line">    <span class="keyword">return</span> pool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="run执行任务"><a href="#run执行任务" class="headerlink" title="run执行任务"></a>run执行任务</h5><p>主要实现，工作线程从请求队列中取出某个任务进行处理，注意线程同步。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line"> void threadpool&lt;T&gt;::run()</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">while</span>(!m_stop)</span><br><span class="line">     &#123;    </span><br><span class="line">         <span class="comment">//信号量等待</span></span><br><span class="line">         m_queuestat.wait();</span><br><span class="line"> </span><br><span class="line">         <span class="comment">//被唤醒后先加互斥锁</span></span><br><span class="line">        m_queuelocker.lock();</span><br><span class="line">        <span class="keyword">if</span>(m_workqueue.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            m_queuelocker.unlock();</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从请求队列中取出第一个任务</span></span><br><span class="line">        <span class="comment">//将任务从请求队列删除</span></span><br><span class="line">        T* request=m_workqueue.front();</span><br><span class="line">        m_workqueue.pop_front();</span><br><span class="line">        m_queuelocker.unlock();</span><br><span class="line">        <span class="keyword">if</span>(!request)</span><br><span class="line">            continue;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从连接池中取出一个数据库连接</span></span><br><span class="line">        <span class="function"><span class="title">request</span>-&gt;</span><span class="function"><span class="title">mysql</span> = m_connPool-&gt;</span>GetConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//process(模板类中的方法,这里是http类)进行处理</span></span><br><span class="line">        <span class="function"><span class="title">request</span>-&gt;</span>process();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将数据库连接放回连接池</span></span><br><span class="line">        <span class="function"><span class="title">m_connPool</span>-&gt;</span>R<span class="function"><span class="title">eleaseConnection</span>(request-&gt;</span>mysql);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cachefish.github.io/2022/04/01/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2229.jfif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="来世做春风，浪漫且自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cachecatのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/01/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/" class="post-title-link" itemprop="url">函数指针</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-01 19:30:00" itemprop="dateCreated datePublished" datetime="2022-04-01T19:30:00+08:00">2022-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-07 09:57:54" itemprop="dateModified" datetime="2022-04-07T09:57:54+08:00">2022-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-base/" itemprop="url" rel="index"><span itemprop="name">c++ base</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="函数指针的使用示例"><a href="#函数指针的使用示例" class="headerlink" title="函数指针的使用示例"></a>函数指针的使用示例</h4><h6 id="函数作为其他函数的参数"><a href="#函数作为其他函数的参数" class="headerlink" title="函数作为其他函数的参数"></a>函数作为其他函数的参数</h6><p>如果要编写排序例程，则可能需要允许函数的调用方选择数据的排序顺序。一些程序员可能需要按升序对数据进行排序，其他人可能更喜欢降序，而另一些程序员可能想要类似但不完全像这些选择之一的东西。让用户指定要执行的操作的一种方法是提供一个标志作为函数的参数，但这是不灵活的;排序函数仅允许一组固定的比较类型（例如，升序和降序）。</p>
<p>允许用户选择如何对数据进行排序的更好方法是让用户将函数传递给排序函数。此函数可能获取两条数据并对其执行比较。我们稍后将介绍一下它的语法。</p>
<h6 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h6><p>函数指针的另一个用途是设置在发生特定事件时调用的”侦听器”或”回调”函数。调用该函数，这会通知您的代码发生了一些感兴趣的操作。</p>
<p>为什么要用回调函数编写代码？在使用某人的库编写代码时，您经常会看到它。例如，当您为图形用户界面 （GUI） 编写代码时。大多数情况下，用户将与一个循环进行交互，该循环允许鼠标指针移动并重新绘制界面。但是，有时用户会单击按钮或在字段中输入文本。这些操作是”事件”，可能需要程序需要处理的响应。您的代码如何知道发生了什么？使用回调函数！用户的单击应导致接口调用您编写的函数来处理该事件。</p>
<p>要了解何时可以执行此操作，请考虑如果您使用的是具有”create_button”功能的 GUI 库，则可能发生的情况。它可能包含按钮在屏幕上应出现的位置、按钮的文本以及单击按钮时要调用的函数。假设目前 C（和C++）有一个名为 function 的泛型”函数指针”类型，这可能如下所示：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void create<span class="constructor">_button( <span class="params">int</span> <span class="params">x</span>, <span class="params">int</span> <span class="params">y</span>, <span class="params">const</span> <span class="params">char</span> <span class="operator">*</span><span class="params">text</span>, <span class="params">function</span> <span class="params">callback_func</span> )</span>;</span><br></pre></td></tr></table></figure>
<p>每当单击该按钮时，都会调用callback_func。callback_func究竟做了什么取决于按钮;这就是为什么允许create_button函数获取函数指针很有用的原因。<br>函数指针语法<br>声明函数指针的语法乍一看似乎很混乱，但在大多数情况下，一旦你理解了发生了什么，它真的非常简单。让我们看一个简单的例子：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> (*foo)(<span class="built_in">int</span>);</span><br></pre></td></tr></table></figure>
<p>在此示例中，foo 是指向一个函数的指针，该函数采用一个参数（一个整数），并返回 void。这就好像你正在声明一个名为”*foo”的函数，它采用int并返回void;现在，如果 *foo 是一个函数，那么 foo 必须是指向函数的指针。（类似 int *x 这样的声明可以读作 *x 是 int，因此 x 必须是指向 int 的指针。</p>
<p>为函数指针编写声明的关键是，您只是写出函数的声明，但使用（*func_name），通常只放置func_name。</p>
<h6 id="读取函数指针声明"><a href="#读取函数指针声明" class="headerlink" title="读取函数指针声明"></a>读取函数指针声明</h6><p>有时，当更多的星星被扔进去时，人们会感到困惑：</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *<span class="comment">(*foo)(int *)</span>;</span><br></pre></td></tr></table></figure>
<p>在这里，关键是要从内到外阅读;请注意，表达式的最内层元素是 <em>foo，否则它看起来像一个普通的函数声明。</em>foo 应该引用返回 void * 并采用 int * 的函数。因此，foo 是指向此类函数的指针。</p>
<h6 id="初始化函数指针"><a href="#初始化函数指针" class="headerlink" title="初始化函数指针"></a>初始化函数指针</h6><p>若要初始化函数指针，必须为其提供程序中函数的地址。语法类似于任何其他变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_int_func</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;%d\n&quot;</span>, x );</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">void</span> (*foo)(<span class="type">int</span>);</span><br><span class="line">    <span class="comment">/* the ampersand is actually optional */</span></span><br><span class="line">    foo = &amp;my_int_func;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（注意：所有示例都编写为与 C 和 C++兼容。<br>使用函数指针<br>若要调用函数指针所指向的函数，请将其视为函数指针，就好像它是要调用的函数的名称一样。调用它的行为执行取消引用;没有必要自己做：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_int_func</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;%d\n&quot;</span>, x );</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">void</span> (*foo)(<span class="type">int</span>);</span><br><span class="line">    foo = &amp;my_int_func;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* call my_int_func (note that you do not need to write (*foo)(2) ) */</span></span><br><span class="line">    <span class="built_in">foo</span>( <span class="number">2</span> );</span><br><span class="line">    <span class="comment">/* but if you want to, you may */</span></span><br><span class="line">    (*foo)( <span class="number">2</span> );</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，函数指针语法是灵活的;它可以看起来像大多数其他用途的指针，带有 &amp;和 *，或者您可以省略语法的这一部分。这类似于数组的处理方式，其中裸数组衰减为指针，但您也可以在数组前面加上 &amp;请求其地址。<br>野外功能指针<br>让我们回到排序示例，我建议使用函数指针编写一个通用排序例程，其中确切的顺序可以由调用排序函数的程序员指定。事实证明，C 函数 qsort 就是这样做的。</p>
<p>在 Linux 手册页中，我们有以下 qsort 声明（来自 stdlib.h）：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">qsort</span><span class="params">(<span class="type">void</span> *base, <span class="type">size_t</span> nmemb, <span class="type">size_t</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">int</span>(*compar)(<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *))</span></span>;</span><br></pre></td></tr></table></figure>
<p>请注意使用 void<em>s 来允许 qsort 对任何类型的数据进行操作（C++，您通常会为此任务使用模板，但C++也允许使用 void</em> 指针），因为 void* 指针可以指向任何内容。因为我们不知道 void* 数组中各个元素的大小，所以除了给出输入的长度、大小这一标准要求之外，我们还必须给 qsort 提供要排序的数组的元素数量 nmb。</p>
<p>但我们真正感兴趣的是与 qsort 的比较参数：它是一个函数指针，它采用两个 void *s 并返回一个 int。这允许任何人指定如何对数组库的元素进行排序，而无需编写专门的排序算法。另请注意，该比较返回一个int;如果第一个参数小于第二个参数，则指向的函数应返回 -1;如果它们相等，则返回 0;如果第二个参数小于第一个参数，则应返回 1。</p>
<p>例如，要按升序对数字数组进行排序，我们可以编写如下代码：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">int</span> <span class="built_in">int</span>_sorter( <span class="keyword">const</span> <span class="built_in">void</span> *first_arg, <span class="keyword">const</span> <span class="built_in">void</span> *second_arg )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> first = *(<span class="built_in">int</span>*)first_arg;</span><br><span class="line">    <span class="built_in">int</span> second = *(<span class="built_in">int</span>*)second_arg;</span><br><span class="line">    <span class="keyword">if</span> ( first &lt; second )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( first == second )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">array</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">int</span> i;</span><br><span class="line">    <span class="comment">/* fill array */</span></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">array</span>[ i ] = <span class="number">10</span> - i;</span><br><span class="line">    &#125;</span><br><span class="line">    qsort( <span class="built_in">array</span>, <span class="number">10</span> , sizeof( <span class="built_in">int</span> ), <span class="built_in">int</span>_sorter );</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        printf ( <span class="string">&quot;%d\n&quot;</span> ,<span class="built_in">array</span>[ i ] );</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用多态性和虚函数而不是函数指针 （C++）<br>通常，通过使用虚函数，可以避免需要显式函数指针。例如，您可以编写一个排序例程，该例程将指针指向一个类，该类提供名为 compare 的虚函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sorter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">compare</span> <span class="params">(<span class="type">const</span> <span class="type">void</span> *first, <span class="type">const</span> <span class="type">void</span> *second)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; cpp_qsort, a qsort using C++ features like virtual functions<br>void cpp_qsort(void *base, size_t nmemb, size_t size, Sorter *compar);<br>在cpp_qsort，每当需要比较时，应调用比较&gt;比较。对于重写此虚函数的类，排序例程将获得该函数的新行为。例如：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AscendSorter</span> : <span class="keyword">public</span> Sorter</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    virtual <span class="type">int</span> <span class="title function_">compare</span> (<span class="keyword">const</span> <span class="keyword">void</span>*, <span class="keyword">const</span> <span class="keyword">void</span>*)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> first = *(<span class="type">int</span>*)first_arg;</span><br><span class="line">        <span class="type">int</span> <span class="built_in">second</span> = *(<span class="type">int</span>*)second_arg;</span><br><span class="line">        <span class="keyword">if</span> ( first &lt; <span class="built_in">second</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( first == <span class="built_in">second</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后，您可以传入指向 AscendSorter 实例的指针，以cpp_qsort按升序对整数进行排序。<br>但是你真的没有使用函数指针吗？<br>虚拟函数是在幕后使用函数指针实现的，因此您实际上是在使用函数指针 - 碰巧编译器使工作更轻松。使用多态性可能是一种合适的策略（例如，Java使用它），但它确实会导致必须创建对象而不是简单地传入函数指针的开销。<br>函数指针摘要<br>语法<br>声明<br>声明函数指针，就像声明函数一样，除了使用类似 *foo 而不是 foo 的名称：<br>1<br>void (*foo)(int);<br>初始 化<br>您只需命名函数即可获取该函数的地址：<br>1<br>2<br>void foo();<br>func_pointer &#x3D; foo;<br>或者通过在函数名称前面加上 &amp; 符号：<br>1<br>2<br>void foo();<br>func_pointer &#x3D; &amp;foo;<br>调用<br>调用指向的函数，就像调用函数一样。<br>1<br>func_pointer( arg1, arg2 );<br>或者，您可以选择在调用函数指针指向的函数之前取消引用它：<br>1<br>(*func_pointer)( arg1, arg2 );<br>函数指针的优点<br>函数指针提供了一种传递有关如何执行某些操作的指令的方法<br>您可以编写灵活的函数和库，允许程序员通过将函数指针作为参数传递来选择行为<br>这种灵活性也可以通过使用具有虚函数的类来实现。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cachefish.github.io/2022/03/14/systemctl/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2229.jfif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="来世做春风，浪漫且自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cachecatのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/14/systemctl/" class="post-title-link" itemprop="url">linux</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-14 19:30:00" itemprop="dateCreated datePublished" datetime="2022-03-14T19:30:00+08:00">2022-03-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-02 09:32:09" itemprop="dateModified" datetime="2022-04-02T09:32:09+08:00">2022-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/systemctl/" itemprop="url" rel="index"><span itemprop="name">systemctl</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="systemctl是什么？"><a href="#systemctl是什么？" class="headerlink" title="systemctl是什么？"></a>systemctl是什么？</h3><p>在Centos 中 systemctl 是设置系统服务的命令，即 service,   它融合之前service和chkconfig的功能于一体。可以使用它永久性或只在当前会话中启用&#x2F;禁用服务。</p>
<h3 id="systemctl的功能"><a href="#systemctl的功能" class="headerlink" title="systemctl的功能"></a>systemctl的功能</h3><p>作为系统启动和服务器守护进程管理器，负责在系统启动或运行时，激活系统资源，服务器进程和其它进程<br>新特性：<br> &#x3D;&#x3D;系统引导时实现服务并行启动&#x3D;&#x3D;<br> &#x3D;&#x3D;按需启动守护进程&#x3D;&#x3D;<br> &#x3D;&#x3D;自动化的服务依赖关系管理&#x3D;&#x3D;</p>
<h4 id="systemd核心概念unit（单元）类型"><a href="#systemd核心概念unit（单元）类型" class="headerlink" title="systemd核心概念unit（单元）类型"></a>systemd核心概念unit（单元）类型</h4><p>unit表示不同类型的systemd对象，通过配置文件进行标识和配置；<br> 文件中主要包含了系统服务、监听socket、保存的系统快照以及其它与init相关的信息</p>
<h5 id="unit类型-："><a href="#unit类型-：" class="headerlink" title="unit类型  ："></a>unit类型  ：</h5><p>service ：文件扩展名为.service, 用于定义系统服务<br>target ：文件扩展名为.target，用于模拟实现运行级别<br>device  ：用于定义内核识别的设备<br>mount：定义文件系统挂载点<br>socket：用于标识进程间通信用的socket文件，也可在系统启动时，延迟启动服务，实现按需启动<br>snapshot ：管理系统快照<br>swap：用于标识swap设备<br>automount ：文件系统的自动挂载点<br>path：用于定义文件系统中的一个文件或目录使用,常用于当文件系统变化时，延迟激活服务<br>那么如何查看这些类型呢?<br>我们以target为例：<br> <img src="https://note.youdao.com/yws/res/3666/WEBRESOURCEff108212b0d8a904dc1d91e8100f4968" alt="image.png"><br>命令中的systemctl是什么呢？其实systemctl就是centos7中systemd的管理工具<br>systemctl命令的格式：systemctl COMMAND name.service     service可以省略不写<br><img src="https://note.youdao.com/yws/res/3667/WEBRESOURCE186f49f03e24dd339827df6546abbecb" alt="image.png"></p>
<ul>
<li>关闭服务    systemctl stop 服务名</li>
<li>查看服务状态    systemctl status 服务名</li>
<li>查看某服务当前的激活状态    systemctl is-active 服务名</li>
<li>查看已经激活的服务    systemctl list-units -t service</li>
<li>查看所有的服务包括开启和关闭的    systemctl list-units -t service a</li>
<li>显示当前服务的状态    systemctl list-unit-files -t service -a</li>
</ul>
<p>以上就是systemctl的一些常用命令和功能，下面是一些其他的命令以供参考：</p>
<figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">显示所有单元状态</span><br><span class="line"> <span class="string">systemctl</span> 或 <span class="string">systemctl</span> <span class="built_in">list-units</span></span><br><span class="line">只显示服务单元的状态</span><br><span class="line"> <span class="string">systemctl</span> <span class="built_in">--type=service</span></span><br><span class="line">显示<span class="string">sshd</span>服务单元</span><br><span class="line"> <span class="string">systemctl</span> –<span class="string">l</span> <span class="string">status</span> <span class="string">sshd</span>.<span class="string">service</span></span><br><span class="line">验证<span class="string">sshd</span>服务当前是否活动</span><br><span class="line"> <span class="string">systemctl</span> <span class="string">is-active</span> <span class="string">sshd</span></span><br><span class="line">启动，停止和重启<span class="string">sshd</span>服务</span><br><span class="line"> <span class="string">systemctl</span> <span class="string">start</span> <span class="string">sshd</span>.<span class="string">service</span></span><br><span class="line"> <span class="string">systemctl</span> <span class="string">stop</span> <span class="string">sshd</span>.<span class="string">service</span></span><br><span class="line"> <span class="string">systemctl</span> <span class="string">restart</span> <span class="string">sshd</span>.<span class="string">service</span></span><br><span class="line">重新加载配置</span><br><span class="line"> <span class="string">systemctl</span> <span class="string">reload</span> <span class="string">sshd</span>.<span class="string">service</span></span><br><span class="line">列出活动状态的所有服务单元</span><br><span class="line"> <span class="string">systemctl</span> <span class="built_in">list-units</span> <span class="built_in">--type=service</span></span><br><span class="line">列出所有服务单元</span><br><span class="line"> <span class="string">systemctl</span> <span class="built_in">list-units</span> <span class="built_in">--type=service</span> <span class="built_in">--all</span></span><br><span class="line">查看服务单元的启用和禁用状态</span><br><span class="line"> <span class="string">systemctl</span> <span class="built_in">list-unit-files</span> <span class="built_in">--type=service</span></span><br><span class="line">列出失败的服务</span><br><span class="line"> <span class="string">systemctl</span> <span class="built_in">--failed</span> <span class="built_in">--type=service</span></span><br><span class="line">列出依赖的单元</span><br><span class="line"> <span class="string">systemctl</span> <span class="built_in">list-dependencies</span> <span class="string">sshd</span></span><br><span class="line">验证<span class="string">sshd</span>服务是否开机启动</span><br><span class="line"> <span class="string">systemctl</span> <span class="string">is-enabled</span> <span class="string">sshd</span></span><br><span class="line">禁用<span class="string">network</span>，使之不能自动启动,但手动可以</span><br><span class="line"> <span class="string">systemctl</span> <span class="string">disable</span> <span class="string">network</span></span><br><span class="line">启用<span class="string">network</span></span><br><span class="line"> <span class="string">systemctl</span> <span class="string">enable</span> <span class="string">network</span></span><br><span class="line">禁用<span class="string">network</span>，使之不能手动或自动启动</span><br><span class="line"> <span class="string">systemctl</span> <span class="string">mask</span> <span class="string">network</span></span><br><span class="line">启用<span class="string">network</span></span><br><span class="line"> <span class="string">systemctl</span> <span class="string">unmask</span> <span class="string">network</span></span><br><span class="line">其它常用命令：</span><br><span class="line"> 传统命令<span class="string">init</span>，<span class="string">poweroff</span>，<span class="string">halt</span>，<span class="string">reboot</span>都成为</span><br><span class="line">       <span class="string">systemctl</span>的软链接</span><br><span class="line"> 关机：<span class="string">systemctl</span> <span class="string">halt</span>、<span class="string">systemctl</span> <span class="string">poweroff</span></span><br><span class="line"> 重启：<span class="string">systemctl</span> <span class="string">reboot</span></span><br><span class="line"> 挂起：<span class="string">systemctl</span> <span class="string">suspend</span></span><br><span class="line"> 休眠：<span class="string">systemctl</span> <span class="string">hibernate</span></span><br><span class="line"> 休眠并挂起：<span class="string">systemctl</span> <span class="string">hybrid-sleep</span></span><br></pre></td></tr></table></figure>
<p>三、将自己的程序注册为服务<br>将 服务脚本放置到  &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;  即可 </p>
<p>[Unit]区块：设置管理启动顺序与依赖关系。<br>  <img src="https://note.youdao.com/yws/res/3668/WEBRESOURCE911e21a102fe6874dc57ea2c3b0bc180" alt="image.png"><br>[Service]区块：<br> <img src="https://note.youdao.com/yws/res/3669/WEBRESOURCE77c9501ad141241c559598c1474acf3a" alt="image.png"><br>所有的启动设置之前，都可以加上一个连词号（-），表示”抑制错误”，即发生错误的时候，不影响其他命令的执行。例如：ExecStop&#x3D;-&#x2F;bin&#x2F;sh &#x2F;server&#x2F;scripts&#x2F;xx.sh</p>
<p>[Install]区块：定义如何安装这个配置文件，即怎样做到开机启动<br> <img src="https://note.youdao.com/yws/res/3670/WEBRESOURCE0b0df6ac6cf9a8842412e36194585b28" alt="image.png"></p>
<p> <img src="https://note.youdao.com/yws/res/3671/WEBRESOURCE6a9999621169169958f59ca021e85469" alt="image.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cachefish.github.io/2022/03/11/STL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2229.jfif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="来世做春风，浪漫且自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cachecatのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/11/STL/" class="post-title-link" itemprop="url">c++ stl</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-11 19:30:00" itemprop="dateCreated datePublished" datetime="2022-03-11T19:30:00+08:00">2022-03-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-02 09:31:41" itemprop="dateModified" datetime="2022-04-02T09:31:41+08:00">2022-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-base/" itemprop="url" rel="index"><span itemprop="name">c++ base</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
</blockquote>
<p> <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5</a></p>
<p>• STL库是用模板（template）写出来的，模板是STL库的基础。STL大致由以下几部分组成：</p>
<pre><code>• 容器（container）
• 迭代器（iterator） ---&gt; 指针
• 适配器（Adapter）
• 算法（algorithm）
• 函数对象（functor）
• 配置器（allocator） ---  透明的
</code></pre>
<p>容器、迭代器、容器适配器都是用类模板实现的，迭代器用于遍历容器中的每一个元素，&#x3D;&#x3D;算法用于操作数据&#x3D;&#x3D;</p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>• 如果没有STL的支持，在处理一些复杂问题时，要自行设计存储模式，如数组管理，插入删除操作等，这不但很繁琐，而且bug频出，是程序出问题最多的地方。STL运用模板类库机制，为数据存储，查找和其他操作提供了一整套方案，大大提高了程序的正确性。不仅如此，类库对常用的很多操作进行了优化处理，大大提高了程序的效率。<br>• 容器是可容纳一些数据的类模板，STL中有vector、list、deque、set&#x2F;multiset、map&#x2F;multimap等容器。</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><ul>
<li>在有的专业书籍中，迭代器也称游标，可以将迭代器初步理解为广义指针，迭代器和指针功能很像，迭代器是通过重载一元的”*”和”-&gt;”来从容器中间接地返回一个值。</li>
<li>迭代器有5种，依次为:<ul>
<li><pre><code> 随机访问迭代器（Random Access Iterator）
</code></pre>
</li>
<li><pre><code> 双向迭代器（Bidirectional Iterator）
</code></pre>
</li>
<li><pre><code>前向迭代器（Forward Iterator）
</code></pre>
</li>
<li><pre><code> 输入迭代器（Input Iterator）
</code></pre>
</li>
<li><pre><code> 输出迭代器（Output Iterator）
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h3><p>• 适配器就是Interface(接口)，&#x3D;&#x3D;对容器、迭代器和算法进行包装&#x3D;&#x3D;，但其实质还是容器、迭代器和算法，只是不依赖于具体的标准容器、迭代器和算法类型，容器适配器可以理解为容器的模板，迭代器适配器可理解为迭代器的模板，算法适配器可理解为算法的模板。<br>• 常见的容器适配器有：<br>    stack、queue、priority_queue<br>    （不支持迭代器访问）</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul>
<li>STL包含了很多对容器进行处理的函数，它们的处理思路大体相同：使用迭代器来标识要处理的数据或数据段、以及结果的存放位置，有的函数还作为对象参数传递给另一个函数，实现数据的处理。</li>
</ul>
<h4 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h4><p>vector，字面翻译为向量(动态数组)，其用法类似于数组，但其功能比数组更强大。简单地说，vector是数组的类表示，它提供了自动管理内存的功能，可以动态改变vector对象的长度，并随着元素的增删而增大或缩小(?)，提供了对元素的随机访问，和数组一样，在vector尾部添加和删除元素（push_back和pop_back）的时间是固定的，但在vector中间或头部增删元素(insert,erase)的时间和复杂度线性正比于vector容器对象中元素的多少。</p>
<h4 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a>deque容器</h4><ul>
<li>deque表示双端队列（double-ended queue），deque容器对象支持下标随机访问，在deque头部和尾部添加删除元素时的时间都是固定的，因此，如果有很多操作是针对序列的头部位置的，建议使用deque容器。但是，如果是在deque的中间进行元素的增删处理，操作的复杂度和时间正比于deque对象中元素的多少。</li>
</ul>
<h4 id="list容器"><a href="#list容器" class="headerlink" title="list容器"></a>list容器</h4><ul>
<li>list类模板表示双向链表，除了首尾元素外，list容器对象中的每个元素都和前面的元素相链接，list不支持下标随机访问，只能通过迭代器双向遍历。</li>
<li>和vector和deque不同的是，在list的任何位置增删元素的时间都是固定的。</li>
</ul>
<h4 id="set容器"><a href="#set容器" class="headerlink" title="set容器"></a>set容器</h4><ul>
<li>使用set容器必须#include <set>。</li>
<li>其使用形式如下：<br>  set&lt;存储类型[,排序函数或对象]&gt; 容器对象名;<br>  第1个参数用以指定存储类型，第2个参数是可选的，用来指定对关键字进行排序的函数或函数对象(函数对象后面介绍)，在默认情况下，将使用less&lt;&gt;类模板，字面意义上可理解为按从小到大进行排列。可以自己设定排序方式：set&lt;int, greater<int>&gt;</li>
<li>根据set的特点，STL提供了3种创建set的方式：<ul>
<li>创建空set容器对象，如：<br>  set<int> obS;</li>
<li>将迭代器的区间作为参数的构造函数，如：<br>  int sz[9]&#x3D;{1,2,3,4,5,6,3,5,6};<br>  set<int> A(sz,sz+9);</li>
<li>根据已有同类型的容器创建新容器，如<br>  set<int> B(A);<br>• set不支持[]下标式的随机访问，必须通过迭代器访问元素。</li>
</ul>
</li>
</ul>
<h4 id="map容器"><a href="#map容器" class="headerlink" title="map容器"></a>map容器</h4><ul>
<li><p>使用map必须包括头文件<map>。</p>
</li>
<li><p>map的元素是一对对的“关键字-值”组合，“关键字”用于搜寻，而“值”用来表示我们要存取的数据。</p>
</li>
<li><p>在map容器中，每个关键字只能出现一次，不能重复。</p>
</li>
<li><p>可使用类模板pair&lt;class T1,class T2&gt;来表示map容器中形如“关键字-值”的每个元素。如下述语句就生成了map容器对象的一个元素t：</p>
<ul>
<li>pair&lt;const int, string&gt; t(600036,”招商银行”);<br>  ○ cout &lt;&lt; t.first &lt;&lt; t.second &lt;&lt; endl;<br>t.first表示600036，t.second表示,”招商银行”<br>   也可创建pair&lt;class T1,class T2&gt;的匿名元素：<br>  • pair&lt;const int, string&gt;(600036,”招商银行”);<br>  • const表示关键字是只读的。</li>
</ul>
</li>
<li><p>创建map容器对象的格式如下，各参数含义和set的类似：<br>  map&lt;关键字类型,值类型[,排序函数或对象]&gt; 容器对象名;</p>
</li>
<li><p>创建方式也是3种：</p>
<ul>
<li>1.创建空map容器对象，如：<br>  map&lt;int,string&gt; obM;</li>
<li>2.将迭代器的区间作为参数的构造函数，如<br>  pair&lt;int,string&gt; sz[4]&#x3D;{<br>  pair&lt;int,string&gt;(1,”北京”),pair&lt;int,string&gt;(2,”深圳”),<br>  pair&lt;int,string&gt;(3,”广州”),pair&lt;int,string&gt;(2,”苏州”)};<br>   map&lt;int,string&gt; obM(sz,sz+4);</li>
<li>3.根据已有同类型的容器创建新容器<br>  map&lt;int,string&gt; B(A);</li>
</ul>
</li>
<li><p>map支持[]下标式的随机访问，也支持迭代器访问元素。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cachefish.github.io/2022/03/10/c-11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2229.jfif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="来世做春风，浪漫且自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cachecatのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/10/c-11/" class="post-title-link" itemprop="url">c++ 11</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-10 19:30:00" itemprop="dateCreated datePublished" datetime="2022-03-10T19:30:00+08:00">2022-03-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-02 09:31:09" itemprop="dateModified" datetime="2022-04-02T09:31:09+08:00">2022-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-base/" itemprop="url" rel="index"><span itemprop="name">c++ base</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-nullptr"><a href="#1-nullptr" class="headerlink" title="1. nullptr"></a>1. nullptr</h3><hr>
<p>实际开发中，避免产生“野指针”最有效的方法，就是在定义指针的同时完成初始化操作，即便该指针的指向尚未明确，也要将其初始化为空指针。<br>所谓“野指针”，又称“悬挂指针”，指的是没有明确指向的指针。野指针往往指向的是那些不可用的内存区域，这就意味着像操作普通指针那样使用野指针（例如 &amp;p），极可能导致程序发生异常。</p>
<hr>
<p>C++98&#x2F;03 标准中，将一个指针初始化为空指针的方式有 2 种：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int *p <span class="operator">=</span> <span class="number">0</span><span class="comment">;</span></span><br><span class="line">int *p <span class="operator">=</span> NULL<span class="comment">; //推荐使用</span></span><br></pre></td></tr></table></figure>
<p>例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">isnull</span><span class="params">(<span class="type">void</span> *c)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;void*c&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">isnull</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int n&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">isnull</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">isnull</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">程序执行结果为：</span><br><span class="line"><span class="type">int</span> n</span><br><span class="line"><span class="type">int</span> n</span><br></pre></td></tr></table></figure>
<p>对于这两个函数来说，如果 NULL 又被定义为了 0 那么 foo(NULL); 这个语句将会去调用 foo(int)，从而导致代码混乱。</p>
<p>为了解决这个问题，C++11 引入了 nullptr 关键字，专门用来区分空指针、0。</p>
<p>&#x3D;&#x3D;nullptr 的类型为nullptr_t&#x3D;&#x3D;，专用于初始化空类型指针，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * a1 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">char</span> * a2 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">double</span> * a3 = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">编译器分别将 <span class="literal">nullptr</span> 隐式转换成 <span class="type">int</span>*、<span class="type">char</span>* 以及 <span class="type">double</span>* 指针类型。</span><br></pre></td></tr></table></figure>
<p>&#x3D;&#x3D;当需要使用 NULL 时候，养成直接使用 nullptr的习惯。&#x3D;&#x3D;</p>
<h3 id="2-auto类型推导"><a href="#2-auto类型推导" class="headerlink" title="2. auto类型推导"></a>2. auto类型推导</h3><p>c+98之前，定义变量或者声明变量之前都必须指明它的类型，比如 int、char 等；<br>auto 关键字基本的使用语法如下：<br>auto name &#x3D; value;<br>&#x2F;&#x2F;auto 仅仅是一个占位符，在编译器期间它会被真正的类型所替代。或者说，C++ 中的变量必须是有明确类型的，只是这个类型是由编译器自己推导出来的。</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">auto n = 10;  //int</span><br><span class="line">auto f = 12.8;  //double</span><br><span class="line"><span class="section">auto p = &amp;n; //int*</span></span><br><span class="line"><span class="section">-------</span></span><br><span class="line">int n = 20; </span><br><span class="line"><span class="section">auto *p = &amp;n, m = 99; //int  </span></span><br><span class="line"><span class="section">-------</span></span><br><span class="line">int  x = 0;</span><br><span class="line">auto <span class="strong">*p1 = &amp;x;   //p1 为 int *，auto 推导为 int</span></span><br><span class="line"><span class="strong">auto  p2 = &amp;x;   //p2 为 int*，auto 推导为 int*</span></span><br><span class="line">auto &amp;r1  = x;   //r1 为 int&amp;，auto 推导为 int</span><br><span class="line"><span class="section">auto r2 = r1;    //r2 为  int，auto 推导为 int</span></span><br><span class="line"><span class="section">-------</span></span><br><span class="line">int  x = 0;</span><br><span class="line">const  auto n = x;  //n 为 const int ，auto 被推导为 int</span><br><span class="line">auto f = n;      //f 为 const int，auto 被推导为 int（const 属性被抛弃）</span><br><span class="line">const auto &amp;r1 = x;  //r1 为 const int&amp; 类型，auto 被推导为 int</span><br><span class="line">auto &amp;r2 = r1;  //r1 为 const int&amp; 类型，auto 被推导为 const int 类型(当 const 和引用结合时，auto 的推导将保留表达式的 const 类型。)</span><br><span class="line"></span><br><span class="line">使用 auto 类型推导的变量必须马上初始化</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>具体类型推导可看c++培训文档-&gt;类型推导一栏</p>
<h5 id="auto-的限制"><a href="#auto-的限制" class="headerlink" title="auto 的限制"></a>auto 的限制</h5><ol>
<li>auto 不能在函数的参数中使用</li>
<li>auto 不能作用于类的非静态成员变量（也就是没有 static 关键字修饰的成员变量）中</li>
<li>auto 关键字不能定义数组 <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char url[] <span class="operator">=</span> <span class="string">&quot;hello&quot;</span><span class="comment">;</span></span><br><span class="line">auto  str[] <span class="operator">=</span> url<span class="comment">;  //arr 为数组，不能使用 auto</span></span><br></pre></td></tr></table></figure></li>
<li>auto 不能作用于模板参数 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A&lt;<span class="type">int</span>&gt; C1;</span><br><span class="line">    A&lt;<span class="keyword">auto</span>&gt; C2 = C1;  <span class="comment">//错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>auto并不是一个真正的类型。auto仅仅是一个占位符。不能使用sizeof来测试大小。<h5 id="auto最常用使用"><a href="#auto最常用使用" class="headerlink" title="auto最常用使用"></a>auto最常用使用</h5><h6 id="使用-auto-定义迭代器"><a href="#使用-auto-定义迭代器" class="headerlink" title="使用 auto 定义迭代器"></a>使用 auto 定义迭代器</h6><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vector&lt; vector&lt;<span class="type">int</span>&gt; &gt; v;</span><br><span class="line">vector&lt; vector&lt;<span class="type">int</span>&gt; &gt;::iterator i = v.<span class="built_in">begin</span>();</span><br><span class="line">------</span><br><span class="line">vector&lt; vector&lt;<span class="type">int</span>&gt; &gt; v;</span><br><span class="line"><span class="keyword">auto</span> i = v.<span class="built_in">begin</span>();  <span class="comment">//使用 auto 代替具体的类型</span></span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; map_;  </span><br><span class="line">map&lt;<span class="type">int</span>, map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;::const_iterator itr1 = map_.<span class="built_in">begin</span>();  </span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> itr2 = map_.<span class="built_in">begin</span>(); </span><br></pre></td></tr></table></figure></li>
</ol>
<h6 id="范围for"><a href="#范围for" class="headerlink" title="范围for"></a>范围for</h6><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">int</span> array[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="attribute">for</span> (auto&amp; e : array)</span><br><span class="line">	<span class="attribute">e</span> *= <span class="number">2</span>;</span><br><span class="line"><span class="attribute">for</span> (auto e : array)</span><br><span class="line">	<span class="attribute">cout</span> &lt;&lt; e &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure>

<h6 id="泛型编程-用于类型推导"><a href="#泛型编程-用于类型推导" class="headerlink" title="泛型编程(用于类型推导)"></a>泛型编程(用于类型推导)</h6><p>使用模板技术时，如果某个变量的类型依赖于模板参数，<br>不使用auto将很难确定变量的类型（使用auto后，将由编译器自动进行确定）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">U</span>&gt;  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Multiply</span><span class="params">(T t, U u)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">auto</span> v = t * u;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">get</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> val = T::<span class="built_in">get</span>();</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>&lt;A&gt;();</span><br><span class="line">    <span class="built_in">func</span>&lt;B&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">get</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;http://c.biancheng.net/cplus/&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;  <span class="comment">//额外增加一个模板参数 T2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    T2 val = T1::<span class="built_in">get</span>();</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//调用时也要手动给模板参数赋值</span></span><br><span class="line">    <span class="built_in">func</span>&lt;A, <span class="type">int</span>&gt;();</span><br><span class="line">    <span class="built_in">func</span>&lt;B, <span class="type">const</span> <span class="type">char</span>*&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-decltype类型推导"><a href="#3-decltype类型推导" class="headerlink" title="3. decltype类型推导"></a>3. decltype类型推导</h3><p>decltype 和 auto 的功能一样，都用来在&#x3D;&#x3D;编译时期进行自动类型推导&#x3D;&#x3D;<br>auto 和 decltype 关键字都可以自动推导出变量的类型，但它们的用法是有区别的：<br>auto 根据&#x3D;右边的初始值 value 推导出变量的类型，而 decltype 根据 exp 表达式推导出变量的类型，跟&#x3D;右边的 value 没有关系。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto varname <span class="operator">=</span> value<span class="comment">;</span></span><br><span class="line">decltype(exp) varname <span class="operator">=</span> value<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>例如:</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="attribute">decltype</span>(a) b = <span class="number">1</span>;  //b 被推导成了 int</span><br><span class="line"><span class="attribute">decltype</span>(<span class="number">10</span>.<span class="number">8</span>) x = <span class="number">5</span>.<span class="number">5</span>;  //x 被推导成了 double</span><br><span class="line"><span class="attribute">decltype</span>(x + <span class="number">100</span>) y;  //y 被推导成了 double</span><br></pre></td></tr></table></figure>

<h4 id="decltype-推导规则"><a href="#decltype-推导规则" class="headerlink" title="decltype 推导规则"></a>decltype 推导规则</h4><p>当使用 decltype(exp)获取类型时，编译器将根据以下三条规则得出结果：</p>
<ul>
<li>如果 exp 是一个不被括号()包围的表达式，或者是一个类成员访问表达式，或者是一个单独的变量，那么 decltype(exp) 的类型就和 exp 一致，这是最普遍最常见的情况。</li>
<li>如果 exp 是函数调用，那么 decltype(exp) 的类型就和函数返回值的类型一致。</li>
<li>如果 exp 是一个左值，或者被括号( )包围，那么 decltype(exp) 的类型就是 exp 的引用；假设 exp 的类型为 T，那么 decltype(exp) 的类型就是 T&amp;。</li>
</ul>
<p>【实例1】exp 是一个普通表达式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> total;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> scores;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Student::total = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;r = n;</span><br><span class="line">    Student stu;</span><br><span class="line">    <span class="keyword">decltype</span>(n) a = n;  <span class="comment">//n 为 int 类型，a 被推导为 int 类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(r) b = n;     <span class="comment">//r 为 const int&amp; 类型, b 被推导为 const int&amp; 类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(Student::total) c = <span class="number">0</span>;  <span class="comment">//total 为类 Student 的一个 int 类型的成员变量，c 被推导为 int 类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(stu.name) url = <span class="string">&quot;hello&quot;</span>;  <span class="comment">//total 为类 Student 的一个 string 类型的成员变量， url 被推导为 string 类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【实例2】exp 为函数调用：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="built_in">int</span>&amp; func<span class="constructor">_int_r(<span class="params">int</span>, <span class="params">char</span>)</span>;  <span class="comment">//返回值为 int&amp;</span></span><br><span class="line"><span class="built_in">int</span>&amp;&amp; func<span class="constructor">_int_rr(<span class="params">void</span>)</span>;  <span class="comment">//返回值为 int&amp;&amp;</span></span><br><span class="line"><span class="built_in">int</span> func<span class="constructor">_int(<span class="params">double</span>)</span>;  <span class="comment">//返回值为 int</span></span><br><span class="line"></span><br><span class="line">const <span class="built_in">int</span>&amp; <span class="keyword">fun</span><span class="constructor">_cint_r(<span class="params">int</span>, <span class="params">int</span>, <span class="params">int</span>)</span>;  <span class="comment">//返回值为 const int&amp;</span></span><br><span class="line">const <span class="built_in">int</span>&amp;&amp; func<span class="constructor">_cint_rr(<span class="params">void</span>)</span>;  <span class="comment">//返回值为 const int&amp;&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//decltype类型推导</span></span><br><span class="line"><span class="built_in">int</span> n = <span class="number">100</span>;</span><br><span class="line">decltype(func<span class="constructor">_int_r(100, &#x27;A&#x27;)</span>) a = n;  <span class="comment">//a 的类型为 int&amp;</span></span><br><span class="line">decltype(func<span class="constructor">_int_rr()</span>) b = <span class="number">0</span>;  <span class="comment">//b 的类型为 int&amp;&amp;</span></span><br><span class="line">decltype(func<span class="constructor">_int(10.5)</span>) c = <span class="number">0</span>;   <span class="comment">//c 的类型为 int</span></span><br><span class="line"></span><br><span class="line">decltype(<span class="keyword">fun</span><span class="constructor">_cint_r(1,2,3)</span>)  x = n;    <span class="comment">//x 的类型为 const int &amp;</span></span><br><span class="line">decltype(func<span class="constructor">_cint_rr()</span>) y = <span class="number">0</span>;  <span class="comment">// y 的类型为 const int&amp;&amp;</span></span><br></pre></td></tr></table></figure>
<p>exp 中调用函数时需要带上括号和参数，这仅仅是形式，并不会真的去执行函数代码。</p>
<p>【实例3】exp 是左值，或者被( )包围：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> Base obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//带有括号的表达式</span></span><br><span class="line">    <span class="keyword">decltype</span>(obj.x) a = <span class="number">0</span>;  <span class="comment">//obj.x 为类的成员访问表达式，符合推导规则一，a 的类型为 int</span></span><br><span class="line">    <span class="keyword">decltype</span>((obj.x)) b = a;  <span class="comment">//obj.x 带有括号，符合推导规则三，b 的类型为 int&amp;。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//加法表达式</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(n + m) c = <span class="number">0</span>;  <span class="comment">//n+m 得到一个右值，符合推导规则一，所以推导结果为 int</span></span><br><span class="line">    <span class="keyword">decltype</span>(n = n + m) d = c;  <span class="comment">//n=n+m 得到一个左值，符号推导规则三，所以推导结果为 int&amp;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">左值是指那些在表达式执行结束后依然存在的数据，也就是持久性的数据；右值是指那些在表达式执行结束后不再存在的数据，也就是临时性的数据。</span><br></pre></td></tr></table></figure>

<h5 id="decltype最常使用"><a href="#decltype最常使用" class="headerlink" title="decltype最常使用"></a>decltype最常使用</h5><h6 id="用于推到类的非静态成员"><a href="#用于推到类的非静态成员" class="headerlink" title="用于推到类的非静态成员"></a>用于推到类的非静态成员</h6><p>auto 只能用于类的静态成员，不能用于类的非静态成员（普通成员），如果我们想推导非静态成员的类型，这个时候就必须使用 decltype 了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp; container)</span> </span>&#123;</span><br><span class="line">        m_it = container.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typename</span> T::iterator m_it;  <span class="comment">//注意这里</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    Base&lt;<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&gt; obj;</span><br><span class="line">    obj.<span class="built_in">func</span>(v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">-----------</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp; container)</span> </span>&#123;</span><br><span class="line">        m_it = container.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">decltype</span>(<span class="built_in">T</span>().<span class="built_in">begin</span>()) m_it;  <span class="comment">//注意这里</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>单独看 Base 类中 m_it 成员的定义，很难看出会有什么错误，但在使用 Base 类的时候，如果传入一个 const 类型的容器，编译器马上就会弹出一大堆错误信息。原因就在于，T::iterator并不能包括所有的迭代器类型，当 T 是一个 const 容器时，应当使用 const_iterator。</p>
<h3 id="4-返回值类型后置"><a href="#4-返回值类型后置" class="headerlink" title="4. 返回值类型后置"></a>4. 返回值类型后置</h3><p>在泛型编程中，可能需要通过参数的运算来得到返回值的类型。考虑下面这个场景：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">R <span class="title">add</span><span class="params">(T t, U u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t+u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>; <span class="type">float</span> b = <span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">auto</span> c = <span class="built_in">add</span>&lt;<span class="keyword">decltype</span>(a + b)&gt;(a, b);</span><br></pre></td></tr></table></figure>
<p>我们并不关心 a+b 的类型是什么，因此，只需要通过 decltype(a+b) 直接得到返回值类型即可。但是像上面这样使用十分不方便，因为外部其实并不知道参数之间应该如何运算，只有 add 函数才知道返回值应当如何推导<br>可行的写法如下：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, typename U&gt;</span><br><span class="line">decltype(T() + U()) <span class="keyword">add</span>(T t, U u)</span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    return t + u;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line">考虑到 T、U 可能是没有无参构造函数的类</span><br><span class="line">template &lt;typename T, typename U&gt;</span><br><span class="line">decltype(<span class="comment">(*(T*)</span><span class="number">0</span>) + <span class="comment">(*(U*)</span><span class="number">0</span>)) <span class="keyword">add</span>(T t, U u)</span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    return t + u;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
<p>虽然成功地使用 decltype 完成了返回值的推导，但写法过于晦涩，会大大增加 decltype 在返回值类型推导上的使用难度并降低代码的可读性。</p>
<p>返回类型后置语法是通过 auto 和 decltype 结合起来使用的。上面的 add 函数，使用新的语法可以写成：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, typename U&gt;</span><br><span class="line">auto <span class="built_in">add</span>(T t, U u) -&gt; <span class="built_in">decltype</span>(t + u)</span><br><span class="line">&#123;</span><br><span class="line">    return t + u;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------</span><br><span class="line">int&amp; <span class="built_in">foo</span>(int&amp; i);</span><br><span class="line"><span class="attribute">float</span> <span class="built_in">foo</span>(float&amp; f);</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">auto <span class="built_in">func</span>(T&amp; val) -&gt; <span class="built_in">decltype</span>(foo(val))</span><br><span class="line">&#123;</span><br><span class="line">    return <span class="built_in">foo</span>(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 decltype 结合返回值后置语法很容易推导出了 foo(val) 可能出现的返回值类型，并将其用到了 func 上。</p>
<p>返回值类型后置语法，是为了解决函数返回值类型依赖于参数而导致难以确定返回值类型的问题。有了这种语法以后，对返回值类型的推导就可以用清晰的方式（直接通过参数做运算）描述出来，而不需要像 C++98&#x2F;03 那样使用晦涩难懂的写法。</p>
<h3 id="5-使用using定义别名"><a href="#5-使用using定义别名" class="headerlink" title="5. 使用using定义别名"></a>5. 使用using定义别名</h3><p>在 C++ 中可以通过 typedef 重定义一个类型：<br>typedef unsigned int uint_t;</p>
<p>被重定义的类型并不是一个新的类型，仅仅只是原有的类型取了一个新的名字</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">uint_t</span>)</span></span>;  <span class="comment">// error: redefinition</span></span><br></pre></td></tr></table></figure>
<p>使用 typedef 重定义类型是很方便的，但它也有一些限制，比如，无法重定义一个模板。<br>比如:<br>需要一个以key为string，value为int或string或其他类型的map<br>c98需要这样操作</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Val&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str_map</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> std::map&lt;std::string, Val&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">str_map&lt;<span class="type">int</span>&gt;::type map1;</span><br></pre></td></tr></table></figure>
<p>c++11</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Val&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">str_map_t</span> = std::map&lt;std::string, Val&gt;;</span><br><span class="line"></span><br><span class="line"><span class="type">str_map_t</span>&lt;<span class="type">int</span>&gt; map1;</span><br></pre></td></tr></table></figure>
<p>using 的别名语法覆盖了 typedef 的全部功能。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重定义unsigned int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint_t</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="type">uint_t</span> = <span class="type">unsigned</span> <span class="type">int</span>;</span><br><span class="line"><span class="comment">// 重定义std::map</span></span><br><span class="line"><span class="keyword">typedef</span> std::map&lt;std::string, <span class="type">int</span>&gt; <span class="type">map_int_t</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="type">map_int_t</span> = std::map&lt;std::string, <span class="type">int</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>typedef 的定义方法和变量的声明类似：像声明一个变量一样，声明一个重定义类型，之后在声明之前加上 typedef 即可。这种写法凸显了 C&#x2F;C++ 中的语法一致性，但有时却会增加代码的阅读难度。比如重定义一个函数指针时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="type">func_t</span>)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>与之相比，using 后面总是立即跟随新标识符（Identifier），之后使用类似赋值的语法，把现有的类型（type-id）赋给新类型：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="type">func_t</span> = <span class="built_in">void</span> (*)(<span class="type">int</span>, <span class="type">int</span>);</span><br></pre></td></tr></table></figure>
<p>通过 using 定义模板别名的语法，只是在普通类型别名语法的基础上增加 template 的参数列表。使用 using 可以轻松地创建一个新的模板别名，而不需要像 C++98&#x2F;03 那样使用烦琐的外敷模板。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* C++98/03 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">func_t</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*type)</span><span class="params">(T, T)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用 func_t 模板</span></span><br><span class="line"><span class="type">func_t</span>&lt;<span class="type">int</span>&gt;::type xx_1;</span><br><span class="line"><span class="comment">/* C++11 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">func_t</span> = <span class="built_in">void</span> (*)(T, T);</span><br><span class="line"><span class="comment">// 使用 func_t 模板</span></span><br><span class="line"><span class="type">func_t</span>&lt;<span class="type">int</span>&gt; xx_2;</span><br></pre></td></tr></table></figure>
<p>using 重定义的 func_t是一个模板，但它既不是类模板也不是函数模板（函数模板实例化后是一个函数），而是一种新的模板形式：模板别名（alias template）。<br>通过 using 可以轻松定义任意类型的模板表达方式。比如下面这样：<br>template <typename T><br>using type_t &#x3D; T;<br>type_t<int> i;<br>&#x3D;&#x3D;type_t 实例化后的类型和它的模板参数类型等价。这里，type_t<int> 将等价于 int。&#x3D;&#x3D;</p>
<h3 id="6-支持函数模板的默认模板参数"><a href="#6-支持函数模板的默认模板参数" class="headerlink" title="6. 支持函数模板的默认模板参数"></a>6. 支持函数模板的默认模板参数</h3><h3 id="7-tuple元组"><a href="#7-tuple元组" class="headerlink" title="7. tuple元组"></a>7. tuple元组</h3><p>&#x3D;&#x3D;实例化的对象可以存储任意数量、任意类型的数据。&#x3D;&#x3D;<br>当函数需要返回多个数据时，可以将这些数据存储在 tuple 中，函数只需返回一个 tuple 对象即可。<br>tuple 本质是一个以可变模板参数定义的类模板，它定义在 <tuple> 头文件并位于 std 命名空间中。因此要想使用 tuple 类模板，程序中需要首先引入以下代码：<br>#include <tuple><br>using std::tuple;</p>
<h5 id="实例化tuple模板类对象"><a href="#实例化tuple模板类对象" class="headerlink" title="实例化tuple模板类对象"></a>实例化tuple模板类对象</h5><ol>
<li><p>类的构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) 默认构造函数</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">tuple</span><span class="params">()</span></span>;</span><br><span class="line"><span class="number">2</span>) 拷贝构造函数</span><br><span class="line"><span class="built_in">tuple</span> (<span class="type">const</span> tuple&amp; tpl);</span><br><span class="line"><span class="number">3</span>) 移动构造函数</span><br><span class="line"><span class="built_in">tuple</span> (tuple&amp;&amp; tpl);</span><br><span class="line"><span class="number">4</span>) 隐式类型转换构造函数</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... UTypes&gt;</span><br><span class="line">    <span class="built_in">tuple</span> (<span class="type">const</span> tuple&lt;UTypes...&gt;&amp; tpl); <span class="comment">//左值方式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... UTypes&gt;</span><br><span class="line">    <span class="built_in">tuple</span> (tuple&lt;UTypes...&gt;&amp;&amp; tpl);      <span class="comment">//右值方式</span></span><br><span class="line"><span class="number">5</span>) 支持初始化列表的构造函数</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">tuple</span> <span class="params">(<span class="type">const</span> Types&amp;... elems)</span></span>;  <span class="comment">//左值方式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... UTypes&gt;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">tuple</span> <span class="params">(UTypes&amp;&amp;... elems)</span></span>;  <span class="comment">//右值方式</span></span><br><span class="line"><span class="number">6</span>) 将pair对象转换为tuple对象</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U1</span>, <span class="keyword">class</span> <span class="title class_">U2</span>&gt;</span><br><span class="line">    <span class="built_in">tuple</span> (<span class="type">const</span> pair&lt;U1,U2&gt;&amp; pr);       <span class="comment">//左值方式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U1</span>, <span class="keyword">class</span> <span class="title class_">U2</span>&gt;</span><br><span class="line">    <span class="built_in">tuple</span> (pair&lt;U1,U2&gt;&amp;&amp; pr);            <span class="comment">//右值方式</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span>        </span></span><br><span class="line"><span class="keyword">using</span> std::tuple;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; first;                             <span class="comment">// 1)   first&#123;&#125;</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title">second</span><span class="params">(first)</span></span>;                     <span class="comment">// 2)   second&#123;&#125;</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title">third</span><span class="params">(std::make_tuple(<span class="number">20</span>, <span class="string">&#x27;b&#x27;</span>))</span></span>;   <span class="comment">// 3)   third&#123;20,&#x27;b&#x27;&#125;</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">long</span>, <span class="type">char</span>&gt; <span class="title">fourth</span><span class="params">(third)</span></span>;                    <span class="comment">// 4)的左值方式, fourth&#123;20,&#x27;b&#x27;&#125;</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title">fifth</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;                    <span class="comment">// 5)的右值方式, fifth&#123;10.&#x27;a&#x27;&#125;</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title">sixth</span><span class="params">(std::make_pair(<span class="number">30</span>, <span class="string">&#x27;c&#x27;</span>))</span></span>;    <span class="comment">// 6)的右值方式, sixth&#123;30,&#x27;&#x27;c&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>make_tuple()函数</p>
<figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">auto</span> first = std::make_tuple (<span class="number">10</span>,&#x27;a&#x27;);   // <span class="keyword">tuple</span> &lt; <span class="type">int</span>, <span class="type">char</span> &gt;</span><br><span class="line"><span class="keyword">const</span> <span class="type">int</span> a = <span class="number">0</span>; <span class="type">int</span> b[<span class="number">3</span>];</span><br><span class="line"><span class="type">auto</span> second = std::make_tuple (a,b);     // <span class="keyword">tuple</span> &lt; <span class="type">int</span>, <span class="type">int</span>* &gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<table>
<thead>
<tr>
<th>函数或类模板</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>tup1.swap(tup2); swap(tup1, tup2)</td>
<td>tup1 和 tup2 表示类型相同的两个 tuple 对象，tuple 模板类中定义有一个 swap() 成员函数，<tuple> 头文件还提供了一个同名的 swap() 全局函数。swap() 函数的功能是交换两个 tuple 对象存储的内容。</td>
</tr>
<tr>
<td>get<num>(tup)</td>
<td>tup 表示某个 tuple 对象，num 是一个整数，get() 是 <tuple> 头文件提供的全局函数，功能是返回 tup 对象中第 num+1 个元素。</td>
</tr>
<tr>
<td>tuple_size<type>::value</td>
<td>tuple_size 是定义在 <tuple> 头文件的类模板，它只有一个成员变量 value，功能是获取某个 tuple 对象中元素的个数，type 为该tuple 对象的类型。</td>
</tr>
<tr>
<td>tuple_element&lt;I, type&gt;::type</td>
<td>tuple_element 是定义在 <tuple> 头文件的类模板，它只有一个成员变量 type，功能是获取某个 tuple 对象第 I+1 个元素的类型。</td>
</tr>
<tr>
<td>forward_as_tuple&lt;args…&gt;</td>
<td>args… 表示 tuple 对象存储的多个元素，该函数的功能是创建一个 tuple 对象，内部存储的 args… 元素都是右值引用形式的。</td>
</tr>
<tr>
<td>tie(args…) &#x3D; tup</td>
<td>tup 表示某个 tuple 对象，tie() 是 <tuple> 头文件提供的，功能是将 tup 内存储的元素逐一赋值给 args… 指定的左值变量。</td>
</tr>
<tr>
<td>tuple_cat(args…)</td>
<td>args… 表示多个 tuple 对象，该函数是 <tuple> 头文件提供的，功能是创建一个 tuple 对象，此对象包含 args… 指定的所有 tuple 对象内的元素。</td>
</tr>
</tbody></table>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">//创建一个 tuple 对象存储 10 和 &#x27;x&#x27;</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title">mytuple</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;x&#x27;</span>)</span></span>;</span><br><span class="line">    <span class="comment">//计算 mytuple 存储元素的个数</span></span><br><span class="line">    size = std::tuple_size&lt;<span class="keyword">decltype</span>(mytuple)&gt;::value;</span><br><span class="line">    <span class="comment">//输出 mytuple 中存储的元素</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(mytuple) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(mytuple) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//修改指定的元素</span></span><br><span class="line">    std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(mytuple) = <span class="number">100</span>;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(mytuple) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//使用 makde_tuple() 创建一个 tuple 对象</span></span><br><span class="line">    <span class="keyword">auto</span> bar = std::<span class="built_in">make_tuple</span>(<span class="string">&quot;test&quot;</span>, <span class="number">3.1</span>, <span class="number">14</span>);</span><br><span class="line">    <span class="comment">//拆解 bar 对象，分别赋值给 mystr、mydou、myint</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* mystr = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">double</span> mydou;</span><br><span class="line">    <span class="type">int</span> myint;</span><br><span class="line">    <span class="comment">//使用 tie() 时，如果不想接受某个元素的值，实参可以用 std::ignore 代替</span></span><br><span class="line">    std::<span class="built_in">tie</span>(mystr, mydou, myint) = bar;</span><br><span class="line">    <span class="comment">//std::tie(std::ignore, std::ignore, myint) = bar;  //只接收第 3 个整形值</span></span><br><span class="line">    <span class="comment">//将 mytuple 和 bar 中的元素整合到 1 个 tuple 对象中</span></span><br><span class="line">    <span class="keyword">auto</span> mycat = std::<span class="built_in">tuple_cat</span>(mytuple, bar);</span><br><span class="line">    size = std::tuple_size&lt;<span class="keyword">decltype</span>(mycat)&gt;::value;</span><br><span class="line">    std::cout &lt;&lt; size &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-列表初始化（统一初始化方式）"><a href="#8-列表初始化（统一初始化方式）" class="headerlink" title="8. 列表初始化（统一初始化方式）"></a>8. 列表初始化（统一初始化方式）</h3><p>c++98中对象初始化有很多方式。如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化列表</span></span><br><span class="line"><span class="type">int</span> i_arr[<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;  <span class="comment">//普通数组</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">    &#125; b;</span><br><span class="line">&#125; a = &#123; <span class="number">1</span>, &#123; <span class="number">2</span>, <span class="number">3</span> &#125; &#125;;  <span class="comment">//POD类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝初始化（copy-initialization）</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span>) &#123;&#125;</span><br><span class="line">&#125; foo = <span class="number">123</span>;  <span class="comment">//需要拷贝构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//直接初始化（direct-initialization）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">j</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">Foo <span class="title">bar</span><span class="params">(<span class="number">123</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这些不同的初始化方法，都有各自的适用范围和作用。最关键的是，这些种类繁多的初始化方法，没有一种可以通用所有情况。为了统一初始化方式，并且让初始化行为具有确定的效果，C++11 中提出了列表初始化（List-initialization）的概念。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Foo <span class="title">a1</span><span class="params">(<span class="number">123</span>)</span></span>;</span><br><span class="line">    Foo a2 = <span class="number">123</span>;  <span class="comment">//error: &#x27;Foo::Foo(const Foo &amp;)&#x27; is private</span></span><br><span class="line">    Foo a3 = &#123; <span class="number">123</span> &#125;;  <span class="comment">//列表初始化</span></span><br><span class="line">    Foo a4 &#123; <span class="number">123</span> &#125;;    <span class="comment">//列表初始化</span></span><br><span class="line">    <span class="type">int</span> a5 = &#123; <span class="number">3</span> &#125;;    <span class="comment">//基本数据类型的列表初始化方式</span></span><br><span class="line">    <span class="type">int</span> a6 &#123; <span class="number">3</span> &#125;;      <span class="comment">//基本数据类型的列表初始化方式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> i_arr[<span class="number">3</span>] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;  <span class="comment">//普通数组初始化</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">    &#125; b;</span><br><span class="line">&#125; a &#123; <span class="number">1</span>, &#123; <span class="number">2</span>, <span class="number">3</span> &#125; &#125;;  <span class="comment">//POD类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> 操作符等可以用圆括号进行初始化的地方，也可以使用初始化列表：</span><br><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span> &#123; <span class="number">123</span> &#125;;</span><br><span class="line"><span class="type">double</span> b = <span class="type">double</span> &#123; <span class="number">12.12</span> &#125;;</span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line">列表初始化还可以直接使用在函数的返回值上</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span>, <span class="type">double</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Foo <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="number">123</span>, <span class="number">321.0</span> &#125;;  <span class="comment">//返回了一个 Foo(123, 321.0)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在初始化时，{}前面的等于号是否书写对初始化行为没有影响。</p>
<h3 id="9-lambda表达式"><a href="#9-lambda表达式" class="headerlink" title="9. lambda表达式"></a>9. lambda表达式</h3><p>匿名函数</p>
<h5 id="lambda匿名函数的定义"><a href="#lambda匿名函数的定义" class="headerlink" title="lambda匿名函数的定义"></a>lambda匿名函数的定义</h5><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[外部变量访问方式说明符] <span class="function"><span class="params">(参数)</span> <span class="title">mutable</span> <span class="title">noexcept</span>/<span class="title">throw</span><span class="params">()</span> -&gt;</span> 返回值类型</span><br><span class="line">&#123;</span><br><span class="line">   函数体;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>[外部变量方位方式说明符] [ ] 方括号用于向编译器表明当前是一个 lambda 表达式，其不能被省略。在方括号内部，可以注明当前 lambda 函数的函数体中可以使用哪些“外部变量”。<br>所谓外部变量，指的是和当前 lambda 表达式位于同一作用域内的所有局部变量。</li>
</ol>
<ol start="2">
<li><p>(参数)<br>和普通函数的定义一样，lambda 匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，如果不需要传递参数，可以连同 () 小括号一起省略；</p>
</li>
<li><p>mutable<br>此关键字可以省略，如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解为这部分变量都是 const 常量）。而如果想修改它们，就必须使用 mutable 关键字。</p>
</li>
</ol>
<p>注意，对于以值传递方式引入的外部变量，lambda 表达式修改的是拷贝的那一份，并不会修改真正的外部变量；</p>
<ol start="4">
<li>noexcept&#x2F;throw()<br>可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型。</li>
</ol>
<p>值得一提的是，如果 lambda 函数标有 noexcept 而函数体内抛出了异常，又或者使用 throw() 限定了异常类型而函数体内抛出了非指定类型的异常，这些异常无法使用 try-catch 捕获，会导致程序执行失败（本节后续会给出实例）。</p>
<ol start="5">
<li><p>-&gt; 返回值类型<br>指明 lambda 匿名函数的返回值类型。值得一提的是，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略-&gt; 返回值类型。</p>
</li>
<li><p>函数体<br>和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。该函数体内除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量。</p>
</li>
</ol>
<p>需要注意的是，外部变量会受到以值传递还是以引用传递方式引入的影响，而全局变量则不会。换句话说，在 lambda 表达式内可以使用任意一个全局变量，必要时还可以直接修改它们的值。</p>
<h5 id="lambda匿名函数中的-外部变量"><a href="#lambda匿名函数中的-外部变量" class="headerlink" title="lambda匿名函数中的[外部变量]"></a>lambda匿名函数中的[外部变量]</h5><table>
<thead>
<tr>
<th>外部变量格式</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>[]</td>
<td>空方括号表示当前 lambda 匿名函数中不导入任何外部变量。</td>
</tr>
<tr>
<td>[&#x3D;]</td>
<td>只有一个 &#x3D; 等号，表示以值传递的方式导入所有外部变量；</td>
</tr>
<tr>
<td>[&amp;]</td>
<td>只有一个 &amp; 符号，表示以引用传递的方式导入所有外部变量；</td>
</tr>
<tr>
<td>[val1,val2,…]</td>
<td>表示以值传递的方式导入 val1、val2 等指定的外部变量，同时多个变量之间没有先后次序；</td>
</tr>
<tr>
<td>[&amp;val1,&amp;val2,…]</td>
<td>表示以引用传递的方式导入 val1、val2等指定的外部变量，多个变量之间没有前后次序；</td>
</tr>
<tr>
<td>[val,&amp;val2,…]</td>
<td>以上 2 种方式还可以混合使用，变量之间没有前后次序。</td>
</tr>
<tr>
<td>[&#x3D;,&amp;val1,…]</td>
<td>表示除 val1 以引用传递的方式导入外，其它外部变量都以值传递的方式导入。</td>
</tr>
<tr>
<td>[this]</td>
<td>表示以值传递的方式导入当前的 this 指针。</td>
</tr>
</tbody></table>
<p>示例:<br>lambda 匿名函数的定义和使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num[<span class="number">4</span>] = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">//对 a 数组中的元素进行排序</span></span><br><span class="line">    <span class="built_in">sort</span>(num, num+<span class="number">4</span>, [=](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">bool</span>&#123; <span class="keyword">return</span> x &lt; y; &#125; );</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n : num)&#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//自定义的升序排序规则</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">sort_up</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span>  x &lt; y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num[<span class="number">4</span>] = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">//对 a 数组中的元素进行排序</span></span><br><span class="line">    <span class="built_in">sort</span>(num, num+<span class="number">4</span>, sort_up);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n : num)&#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 auto 关键字为 lambda 匿名函数设定了一个函数名，由此我们即可在作用域内调用该函数。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//display 即为 lambda 匿名函数的函数名</span></span><br><span class="line">    <span class="keyword">auto</span> display = [](<span class="type">int</span> a,<span class="type">int</span> b) -&gt; <span class="type">void</span>&#123;cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b;&#125;;</span><br><span class="line">    <span class="comment">//调用 lambda 函数</span></span><br><span class="line">    <span class="built_in">display</span>(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用值传递和引用传递</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> all_num = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//局部变量</span></span><br><span class="line">    <span class="type">int</span> num_1 = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> num_2 = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> num_3 = <span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lambda1:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> lambda1 = [=]&#123;</span><br><span class="line">        <span class="comment">//全局变量可以访问甚至修改</span></span><br><span class="line">        all_num = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//函数体内只能使用外部变量，而无法对它们进行修改</span></span><br><span class="line">        cout &lt;&lt; num_1 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">             &lt;&lt; num_2 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">             &lt;&lt; num_3 &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">lambda1</span>();</span><br><span class="line">    cout &lt;&lt; all_num &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lambda2:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> lambda2 = [&amp;]&#123;</span><br><span class="line">        all_num = <span class="number">100</span>;</span><br><span class="line">        num_1 = <span class="number">10</span>;</span><br><span class="line">        num_2 = <span class="number">20</span>;</span><br><span class="line">        num_3 = <span class="number">30</span>;</span><br><span class="line">        cout &lt;&lt; num_1 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">             &lt;&lt; num_2 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">             &lt;&lt; num_3 &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">lambda2</span>();</span><br><span class="line">    cout &lt;&lt; all_num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想在 lambda1 匿名函数的基础上修改外部变量的值，可以借助 mutable 关键字</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">auto lambda1 <span class="operator">=</span> [<span class="operator">=</span>]() mutable&#123;</span><br><span class="line">    num_1 <span class="operator">=</span> <span class="number">10</span><span class="comment">;</span></span><br><span class="line">    num_2 <span class="operator">=</span> <span class="number">20</span><span class="comment">;</span></span><br><span class="line">    num_3 <span class="operator">=</span> <span class="number">30</span><span class="comment">;</span></span><br><span class="line">    //函数体内只能使用外部变量，而无法对它们进行修改</span><br><span class="line">    cout &lt;&lt; num_1 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">         &lt;&lt; num_2 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">         &lt;&lt; num_3 &lt;&lt; endl<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>执行抛出异常类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> except = []()<span class="built_in">throw</span>(<span class="type">int</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">10</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">except</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">int</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;捕获到了整形异常&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-constexpr-验证是否为常量表达式"><a href="#10-constexpr-验证是否为常量表达式" class="headerlink" title="10. constexpr 验证是否为常量表达式"></a>10. constexpr 验证是否为常量表达式</h3><p>constexpr 关键字的功能是使指定的常量表达式获得在程序编译阶段计算出结果的能力，而不必等到程序运行阶段。C++ 11 标准中，constexpr 可用于修饰普通变量、函数（包括模板函数）以及类的构造函数。</p>
<p>所谓常量表达式，指的就是由多个（≥1）常量组成的表达式。换句话说，如果表达式中的成员都是常量，那么该表达式就是一个常量表达式。这也意味着，常量表达式一旦确定，其值将无法修改。</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1)</span></span><br><span class="line"><span class="built_in">int</span> <span class="built_in">url</span>[<span class="number">10</span>];<span class="comment">//正确</span></span><br><span class="line"><span class="comment">// 2)</span></span><br><span class="line"><span class="built_in">int</span> <span class="built_in">url</span>[<span class="number">6</span> + <span class="number">4</span>];<span class="comment">//正确</span></span><br><span class="line"><span class="comment">// 3)</span></span><br><span class="line"><span class="built_in">int</span> length = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">int</span> <span class="built_in">url</span>[length];<span class="comment">//错误，length是变量,无法表示数组的长度。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="constexpr修饰普通变量"><a href="#constexpr修饰普通变量" class="headerlink" title="constexpr修饰普通变量"></a>constexpr修饰普通变量</h5><p>变量必须经过初始化且初始值必须是常量表达式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> num = <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> url[num] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    couts&lt;&lt; url[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">编译器就可以在编译时期对 num 这个表达式进行计算，因为 num 可以作为定义数组时的长度。</span><br></pre></td></tr></table></figure>
<h5 id="constexpr修饰函数"><a href="#constexpr修饰函数" class="headerlink" title="constexpr修饰函数"></a>constexpr修饰函数</h5><p>constexpr 还可以用于修饰函数的返回值，这样的函数又称为“常量表达式函数”。<br>一个函数要想成为常量表达式函数，必须满足如下 4 个条件。</p>
<ol>
<li>整个函数的函数体中，除了可以包含 using 指令、typedef 语句以及 static_assert 断言外，只能包含一条 return 返回语句。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个函数是无法通过编译的，因为该函数的返回值用 constexpr 修饰，但函数内部包含多条语句。</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;  </span><br><span class="line">    <span class="type">int</span> ret = <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//display() 函数的返回值是用 constexpr 修饰的 int 类型值，且该函数的函数体中只包含一个 return 语句。</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;   <span class="comment">// √</span></span><br><span class="line">    <span class="comment">//可以添加 using 执行、typedef 语句以及 static_assert 断言</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>该函数必须有返回值，即函数的返回值类型不能是 void。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">不属于常量表达式函数</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>函数在使用之前，必须有对应的定义语句。我们知道，函数的使用分为“声明”和“定义”两部分，普通的函数调用只需要提前写好该函数的声明部分即可（函数的定义部分可以放在调用位置之后甚至其它文件中），但常量表达式函数在使用前，必须要有该函数的定义。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//普通函数的声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">noconst_dis</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"><span class="comment">//常量表达式函数的声明</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"><span class="comment">//常量表达式函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用常量表达式函数</span></span><br><span class="line">    <span class="type">int</span> a[<span class="built_in">display</span>(<span class="number">3</span>)] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    cout &lt;&lt; a[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//调用普通函数</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">noconst_dis</span>(<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通函数的定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">noconst_dis</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="constexpr修饰模板函数"><a href="#constexpr修饰模板函数" class="headerlink" title="constexpr修饰模板函数"></a>constexpr修饰模板函数</h5>C++11 语法中，constexpr 可以修饰模板函数，但由于模板中类型的不确定性，因此模板函数实例化后的函数是否符合常量表达式函数的要求也是不确定的。</li>
</ol>
<p>针对这种情况下，C++11 标准规定，如果 constexpr 修饰的模板函数实例化结果不满足常量表达式函数的要求，则 constexpr 会被自动忽略，即该函数就等同于一个普通函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myType</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T <span class="title">dispaly</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">myType</span> stu&#123;<span class="string">&quot;zhangsan&quot;</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="comment">//普通函数</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">myType</span> ret = <span class="built_in">dispaly</span>(stu);</span><br><span class="line">    cout &lt;&lt; ret.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ret.age &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//常量表达式函数</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> ret1 = <span class="built_in">dispaly</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; ret1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-右值引用"><a href="#11-右值引用" class="headerlink" title="11. 右值引用"></a>11. 右值引用</h3><p>C++左值和右值<br>在 C++ 或者 C 语言中，一个表达式（可以是字面量、变量、对象、函数的返回值等）根据其使用场景不同，分为左值表达式和右值表达式。确切的说 C++ 中左值和右值的概念是从 C 语言继承过来的。<br>值得一提的是，左值的英文简写为“lvalue”，右值的英文简写为“rvalue”。很多人认为它们分别是”left value”、”right value” 的缩写，其实不然。lvalue 是“loactor value”的缩写，可意为存储在内存中、有明确存储地址（可寻址）的数据，而 rvalue 译为 “read value”，指的是那些可以提供数据值的数据（不一定可以寻址，例如存储于寄存器中的数据）。<br>通常情况下，判断某个表达式是左值还是右值，最常用的有以下 2 种方法。</p>
<ol>
<li>可位于赋值号（&#x3D;）左侧的表达式就是左值；反之，只能位于赋值号右侧的表达式就是右值。举个例子：<br>int a &#x3D; 5;<br>5 &#x3D; a; &#x2F;&#x2F;错误，5 不能为左值</li>
</ol>
<p>其中，变量 a 就是一个左值，而字面量 5 就是一个右值。值得一提的是，C++ 中的左值也可以当做右值使用，例如：<br>int b &#x3D; 10; &#x2F;&#x2F; b 是一个左值<br>a &#x3D; b; &#x2F;&#x2F; a、b 都是左值，只不过将 b 可以当做右值使用</p>
<ol start="2">
<li>有名称的、可以获取到存储地址的表达式即为左值；反之则是右值。</li>
</ol>
<p>以上面定义的变量 a、b 为例，a 和 b 是变量名，且通过 &amp;a 和 &amp;b 可以获得他们的存储地址，因此 a 和 b 都是左值；反之，字面量 5、10，它们既没有名称，也无法获取其存储地址（字面量通常存储在寄存器中，或者和代码存储在一起），因此 5、10 都是右值。 </p>
<h4 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h4><p>C++98标准中使用 “&amp;” 表示。只能操作 C++ 中的左值，无法对右值添加引用。举个例子</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="built_in">num</span> = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">int</span> &amp;b = <span class="built_in">num</span>; <span class="comment">//正确</span></span><br><span class="line"><span class="built_in">int</span> &amp;c = <span class="number">10</span>; <span class="comment">//错误</span></span><br><span class="line">编译器允许我们为 <span class="built_in">num</span> 左值建立一个引用，但不可以为 <span class="number">10</span> 这个右值建立引用。因此，C++<span class="number">98</span>/<span class="number">03</span> 标准中的引用又称为左值引用。</span><br></pre></td></tr></table></figure>
<p>虽然 C++98&#x2F;03 标准不支持为右值建立非常量左值引用，但允许使用常量左值引用操作右值。也就是说，常量左值引用既可以操作左值，也可以操作右值，例如</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="built_in">num</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> &amp;b = <span class="built_in">num</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> &amp;c = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>C++11 标准新引入了另一种引用方式，称为右值引用，用 “&amp;&amp;” 表示。<br>和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int num = <span class="number">10</span>;</span><br><span class="line"><span class="regexp">//i</span>nt &amp;&amp; a = num;  <span class="regexp">//</span>右值引用不能初始化为左值</span><br><span class="line">int &amp;&amp; a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>和c98 常量左值引用不同的是，右值引用还可以对右值进行修改</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">int</span> &amp;&amp; a = <span class="number">10</span>;</span><br><span class="line"><span class="attribute">a</span> = <span class="number">100</span>;</span><br><span class="line"><span class="attribute">cout</span> &lt;&lt; a &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>C++ 语法上是支持定义常量右值引用的<br>const int&amp;&amp; a &#x3D; 10;&#x2F;&#x2F;编译器不会报错<br><img src="https://note.youdao.com/yws/res/3471/WEBRESOURCEec66cfb2022348421dc78b2135ee241d" alt="image.png"></p>
<h3 id="move函数-将左值强制转换为右值"><a href="#move函数-将左值强制转换为右值" class="headerlink" title="move函数 将左值强制转换为右值"></a>move函数 将左值强制转换为右值</h3><p>C++11 标准中借助右值引用可以为指定类添加移动构造函数，这样当使用该类的右值对象（可以理解为临时对象）初始化同类对象时，编译器会优先选择移动构造函数。</p>
<p>移动构造函数的调用时机是：用同类的右值对象初始化新对象。那么，用当前类的左值对象（有名称，能获取其存储地址的实例对象）初始化同类对象时，是否就无法调用移动构造函数了呢？当然不是，C++11 标准中已经给出了解决方案，即调用 move() 函数。</p>
<p>move 本意为 “移动”，但该函数并不能移动任何数据，它的功能很简单，就是将某个左值强制转化为右值。<br>基于 move() 函数特殊的功能，其常用于实现移动语义。</p>
<p>move() 函数的用法也很简单，其语法格式如下：<br>move( arg )</p>
<p>move() 函数的基础应用。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">movedemo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">movedemo</span>():<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="built_in">movedemo</span>(<span class="type">const</span> movedemo &amp;d):<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*d.num))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;copy construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动构造函数</span></span><br><span class="line">    <span class="built_in">movedemo</span>(movedemo &amp;&amp;d):<span class="built_in">num</span>(d.num)&#123;</span><br><span class="line">        d.num = <span class="literal">NULL</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;move construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:     <span class="comment">//这里应该是 private，使用 public 是为了更方便说明问题</span></span><br><span class="line">    <span class="type">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    movedemo demo;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;demo2:\n&quot;</span>;</span><br><span class="line">    movedemo demo2 = demo;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; *demo2.num &lt;&lt; endl;   //可以执行</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;demo3:\n&quot;</span>;</span><br><span class="line">    movedemo demo3 = std::<span class="built_in">move</span>(demo);</span><br><span class="line">    <span class="comment">//此时 demo.num = NULL，因此下面代码会报运行时错误</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; *demo.num &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">程序执行结果为：</span><br><span class="line">construct!</span><br><span class="line">demo2:</span><br><span class="line">copy construct!</span><br><span class="line">demo3:</span><br><span class="line">move construct!</span><br></pre></td></tr></table></figure>
<p>通过观察程序的输出结果，以及对比 demo2 和 demo3 初始化操作不难得知，demo 对象作为左值，直接用于初始化 demo2 对象，其底层调用的是拷贝构造函数；而通过调用 move() 函数可以得到 demo 对象的右值形式，用其初始化 demo3 对象，编译器会优先调用移动构造函数。</p>
<p>灵活使用 move() 函数。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">first</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">first</span>() :<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动构造函数</span></span><br><span class="line">    <span class="built_in">first</span>(first &amp;&amp;d) :<span class="built_in">num</span>(d.num) &#123;</span><br><span class="line">        d.num = <span class="literal">NULL</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;first move construct!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:    <span class="comment">//这里应该是 private，使用 public 是为了更方便说明问题</span></span><br><span class="line">    <span class="type">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">second</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">second</span>() :<span class="built_in">fir</span>() &#123;&#125;</span><br><span class="line">    <span class="comment">//用 first 类的移动构造函数初始化 fir</span></span><br><span class="line">    <span class="built_in">second</span>(second &amp;&amp; sec) :<span class="built_in">fir</span>(<span class="built_in">move</span>(sec.fir)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;second move construct&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:    <span class="comment">//这里也应该是 private，使用 public 是为了更方便说明问题</span></span><br><span class="line">    first fir;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    second oth;</span><br><span class="line">    second oth2 = <span class="built_in">move</span>(oth);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; *oth.fir.num &lt;&lt; endl;   //程序报运行时错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">程序执行结果为：</span><br><span class="line">construct!</span><br><span class="line">first move construct!</span><br><span class="line">second move construct</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>程序中分别构建了 first 和 second 这 2 个类，其中 second 类中包含一个 first 类对象。如果读者仔细观察不难发现，程序中使用了 2 此 move() 函数：<br>程序第 31 行：由于 oth 为左值，如果想调用移动构造函数为 oth2 初始化，需先利用 move() 函数生成一个 oth 的右值版本；<br>程序第 22 行：oth 对象内部还包含一个 first 类对象，对于 oth.fir 来说，其也是一个左值，所以在初始化 oth.fir 时，还需要再调用一次 move() 函数。</p>
<h3 id="引用限定符"><a href="#引用限定符" class="headerlink" title="引用限定符"></a>引用限定符</h3><p>左值的类对象称为左值对象，将右值的类对象称为右值对象。</p>
<p>默认情况下，对于类中用 public 修饰的成员函数，既可以被左值对象调用，也可以被右值对象调用。举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">demo</span>(<span class="type">int</span> num):<span class="built_in">num</span>(num)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_num</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">demo <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">get_num</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">move</span>(a).<span class="built_in">get_num</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，demo 类中的 get_num() 成员函数既可以被 a 左值对象调用，也可以被 move(a) 生成的右值 demo 对象调用，运行程序会输出两个 10。</p>
<p>某些场景中，我们可能需要限制调用成员函数的对象的类型（左值还是右值），为此 C++11 新添加了引用限定符。所谓引用限定符，就是在成员函数的后面添加 “&amp;” 或者 “&amp;&amp;”，从而限制调用者的类型（左值还是右值）。</p>
<p>修改上面程序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">demo</span>(<span class="type">int</span> num):<span class="built_in">num</span>(num)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_num</span><span class="params">()</span>&amp;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">demo <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">get_num</span>() &lt;&lt; endl;          <span class="comment">// 正确</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; move(a).get_num() &lt;&lt; endl;  // 错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和之前的程序相比，我们仅在 get_num()成员函数的后面添加了 “&amp;”，它可以限定调用该函数的对象必须是左值对象。因此第 16 行代码中，move(a) 生成的右值对象是不允许调用 get_num() 函数的。</p>
<p>同理，修改程序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">demo</span>(<span class="type">int</span> num):<span class="built_in">num</span>(num)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_num</span><span class="params">()</span>&amp;&amp;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">demo <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; a.get_num() &lt;&lt; endl;      // 错误</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">move</span>(a).<span class="built_in">get_num</span>() &lt;&lt; endl;  <span class="comment">// 正确</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和先前程序不同的是，get_num() 函数后根有 “&amp;&amp;” 限定符，它可以限定调用该函数的对象必须是一个右值对象。<br>注意，引用限定符不适用于静态成员函数和友元函数。</p>
<p>const和引用限定符<br>我们知道，const 也可以用于修饰类的成员函数，我们习惯称为常成员函数，例如：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">demo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">int</span> <span class="title">get_num</span>() <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">这里的 get_num() 就是一个常成员函数。</span><br></pre></td></tr></table></figure>
<p>const 和引用限定符修饰类的成员函数时，都位于函数的末尾。C++11 标准规定，当引用限定符和 const 修饰同一个类的成员函数时，const 必须位于引用限定符前面。</p>
<p>需要注意的一点是，当 const &amp;&amp; 修饰类的成员函数时，调用它的对象只能是右值对象；当 const &amp; 修饰类的成员函数时，调用它的对象既可以是左值对象，也可以是右值对象。无论是 const &amp;&amp; 还是 const &amp; 限定的成员函数，内部都不允许对当前对象做修改操作。</p>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">demo</span>(<span class="type">int</span> num,<span class="type">int</span> num2) :<span class="built_in">num</span>(num),<span class="built_in">num2</span>(num2) &#123;&#125;</span><br><span class="line">    <span class="comment">//左值和右值对象都可以调用</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_num</span><span class="params">()</span> <span class="type">const</span> &amp;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//仅供右值对象调用</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_num2</span><span class="params">()</span> <span class="type">const</span> &amp;&amp; </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num2;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> num2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">demo <span class="title">a</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">get_num</span>() &lt;&lt; endl;        <span class="comment">// 正确</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">move</span>(a).<span class="built_in">get_num</span>() &lt;&lt; endl;  <span class="comment">// 正确</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//cout &lt;&lt; a.get_num2() &lt;&lt; endl;     // 错误 </span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">move</span>(a).<span class="built_in">get_num2</span>() &lt;&lt; endl; <span class="comment">// 正确</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>C++ 开发中，我们经常会遇到诸如程序运行中突然崩溃、程序运行所用内存越来越多最终不得不重启等问题，这些问题往往都是内存资源管理不当造成的。比如：</p>
<ul>
<li>有些内存资源已经被释放，但指向它的指针并没有改变指向（成为了野指针），并且后续还在使用；</li>
<li>有些内存资源已经被释放，后期又试图再释放一次（重复释放同一块内存会导致程序运行崩溃）；</li>
<li>没有及时释放不再使用的内存资源，造成内存泄漏，程序占用的内存资源越来越多。</li>
</ul>
<p>使用智能指针可以很好地避免“忘记释放内存而导致内存泄漏”问题出现。</p>
<h5 id="shared-ptr智能指针原理"><a href="#shared-ptr智能指针原理" class="headerlink" title="shared_ptr智能指针原理"></a>shared_ptr智能指针原理</h5><p>多个 shared_ptr 智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）。</p>
<h5 id="1、shared-ptr智能指针的创建"><a href="#1、shared-ptr智能指针的创建" class="headerlink" title="1、shared_ptr智能指针的创建"></a>1、shared_ptr智能指针的创建</h5><p>shared_ptr<T> 类模板中，提供了多种实用的构造函数，这里给读者列举了几个常用的构造函数（以构建指向 int 类型数据的智能指针为例）。</p>
<ol>
<li>通过如下 2 种方式，可以构造出 shared_ptr<T> 类型的空智能指针：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p1;             <span class="comment">//不传入任何实参</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;    <span class="comment">//传入空指针 nullptr</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="2">
<li>在构建 shared_ptr 智能指针，也可以明确其指向。例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>std::make_shared<T> 模板函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p3 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br></pre></td></tr></table></figure></li>
<li>shared_ptr<T> 模板还提供有相应的拷贝构造函数和移动构造函数<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用拷贝构造函数</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p4</span><span class="params">(p3)</span></span>;<span class="comment">//或者 std::shared_ptr&lt;int&gt; p4 = p3;</span></span><br><span class="line"><span class="comment">//调用移动构造函数</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p5</span><span class="params">(std::move(p4))</span></span>; <span class="comment">//或者 std::shared_ptr&lt;int&gt; p5 = std::move(p4);</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>同一普通指针不能同时为多个 shared_ptr 对象赋值，否则会导致程序发生异常。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(ptr)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(ptr)</span></span>;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p>shared_ptr<T>模板类提供的成员方法<br><img src="https://note.youdao.com/yws/res/3472/WEBRESOURCE8af2d6d5afe86404603b3b0d59e01559" alt="image.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//构建 2 个智能指针</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">    <span class="comment">//输出 p2 指向的数据</span></span><br><span class="line">    cout &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">    p1.<span class="built_in">reset</span>();<span class="comment">//引用计数减 1,p1为空指针</span></span><br><span class="line">    <span class="keyword">if</span> (p1) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p1 不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p1 为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以上操作，并不会影响 p2</span></span><br><span class="line">    cout &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//判断当前和 p2 同指向的智能指针有多少个</span></span><br><span class="line">    cout &lt;&lt; p2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">10</span></span><br><span class="line">p1 为空</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>unique_ptr”唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）</p>
<p>unique_ptr指针本身的生命周期：从unique_ptr指针创建时开始，直到离开作用域。离开作用域时，若其指向对象，则将其所指对象销毁(默认使用delete操作符，用户可指定其他操作)。</p>
<p>unique_ptr指针与其所指对象的关系：在智能指针生命周期内，可以改变智能指针所指对象，如创建智能指针时通过构造函数指定、</p>
<p>通过reset方法重新指定、通过release方法释放所有权、通过移动语义转移所有权。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//动态绑定对象</span></span><br><span class="line">        <span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span> <span class="params">(<span class="keyword">new</span> <span class="type">int</span>(a))</span></span>;</span><br><span class="line">        std::cout&lt;&lt;*p&lt;&lt;std::endl;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//move转移所有权,转移之后指针p就变得无效了</span></span><br><span class="line">        std::unique_ptr&lt;<span class="type">int</span>&gt; q=std::<span class="built_in">move</span>(p);</span><br><span class="line">        std::cout&lt;&lt;*q&lt;&lt;std::endl;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//release释放所有权，释放之后指针q变的无效</span></span><br><span class="line">        q.<span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p3</span> <span class="params">(<span class="keyword">new</span> string (<span class="string">&quot;auto&quot;</span>))</span></span>;   <span class="comment">//#4</span></span><br><span class="line">unique_ptr&lt;string&gt; p4；                       <span class="comment">//#5</span></span><br><span class="line">p4 = p3;<span class="comment">//此时会报错！！</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">pu1</span><span class="params">(<span class="keyword">new</span> string (<span class="string">&quot;hello world&quot;</span>))</span></span>; </span><br><span class="line">unique_ptr&lt;string&gt; pu2; </span><br><span class="line">pu2 = pu1;                                      <span class="comment">// #1 不允许</span></span><br><span class="line">unique_ptr&lt;string&gt; pu3; </span><br><span class="line">pu3 = <span class="built_in">unique_ptr</span>&lt;string&gt;(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">&quot;You&quot;</span>));   <span class="comment">// #2 允许</span></span><br><span class="line">其中#<span class="number">1</span>留下悬挂的<span class="built_in">unique_ptr</span>(pu1)，这可能导致危害。而#<span class="number">2</span>不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。</span><br></pre></td></tr></table></figure>

<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr()"></a>weak_ptr()</h3><p>share_ptr虽然已经很好用了，但是有一点share_ptr智能指针还是有内存泄露的情况，当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。</p>
<p>weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的shared_ptr， weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;	<span class="comment">//声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	shared_ptr&lt;B&gt; pb_;</span><br><span class="line">	~<span class="built_in">A</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;A delete\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	shared_ptr&lt;A&gt; pa_;</span><br><span class="line">	~<span class="built_in">B</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;B delete\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">shared_ptr&lt;B&gt; <span class="title">pb</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line">	<span class="function">shared_ptr&lt;A&gt; <span class="title">pa</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">	cout &lt;&lt; pb.<span class="built_in">use_count</span>() &lt;&lt; endl;	<span class="comment">//1</span></span><br><span class="line">	cout &lt;&lt; pa.<span class="built_in">use_count</span>() &lt;&lt; endl;	<span class="comment">//1</span></span><br><span class="line">	pb-&gt;pa_ = pa;</span><br><span class="line">	pa-&gt;pb_ = pb;</span><br><span class="line">	cout &lt;&lt; pb.<span class="built_in">use_count</span>() &lt;&lt; endl;	<span class="comment">//2</span></span><br><span class="line">	cout &lt;&lt; pa.<span class="built_in">use_count</span>() &lt;&lt; endl;	<span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fun</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减1，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A、B的析构函数没有被调用）运行结果没有输出析构函数的内容，造成内存泄露。如果把其中一个改为weak_ptr就可以了，我们把类A里面的shared_ptr pb_，改为weak_ptr pb_ ，运行结果如下：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">B <span class="keyword">delete</span></span><br><span class="line">A <span class="keyword">delete</span></span><br></pre></td></tr></table></figure>
<p>这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减1，同时pa析构时使A的计数减1，那么A的计数为0，A得到释放。</p>
<p>注意：我们不能通过weak_ptr直接访问对象的方法，比如B对象中有一个方法print()，我们不能这样访问，pa-&gt;pb_-&gt;print()，因为pb_是一个weak_ptr，应该先把它转化为shared_ptr，如：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">shared_ptr</span>&lt;B&gt; p = pa-&gt;</span>pb_.lock();</span><br><span class="line"><span class="function"><span class="title">p</span>-&gt;</span>print();</span><br></pre></td></tr></table></figure>
<p>weak_ptr 没有重载*和-&gt;但可以使用 lock 获得一个可用的 shared_ptr 对象. 注意, weak_ptr 在使用前需要检查合法性.</p>
<p>&#x3D;&#x3D;expired&#x3D;&#x3D;用于检测所管理的对象是否已经释放, 如果已经释放, 返回 true; 否则返回 false.</p>
<p>&#x3D;&#x3D;lock&#x3D;&#x3D; 用于获取所管理的对象的强引用(shared_ptr). 如果 expired 为 true, 返回一个空的 shared_ptr; 否则返回一个 shared_ptr, 其内部对象指向与 weak_ptr 相同.</p>
<p>&#x3D;&#x3D;use_count&#x3D;&#x3D; 返回与 shared_ptr 共享的对象的引用计数.</p>
<p>&#x3D;&#x3D;reset&#x3D;&#x3D; 将 weak_ptr 置空.</p>
<p>weak_ptr 支持拷贝或赋值, 但不会影响对应的 shared_ptr 内部对象的计数.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cachefish.github.io/2022/03/07/14-%E5%A3%B0%E6%98%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2229.jfif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="来世做春风，浪漫且自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cachecatのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/07/14-%E5%A3%B0%E6%98%8E/" class="post-title-link" itemprop="url">c++ 声明</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-07 19:30:00 / 修改时间：10:13:23" itemprop="dateCreated datePublished" datetime="2022-03-07T19:30:00+08:00">2022-03-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-base/" itemprop="url" rel="index"><span itemprop="name">c++ base</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>声明将名字引入（或再引入）到C++程序中。每种实体的声明方式都不同。<br>定义是足以使该名字所标识的实体被使用的声明。</p>
<h2 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h2><p>顶层CV修饰符（Top-Level cv-Qualifiers）<br>◆C  +中的类型可以由一层或多层组成。<br>例如int *p, p的类型是 pointer to int, 是由2层组成，第1层是“pointer to”,第2层是 “int”。</p>
<p>◆ cv修饰符可以出现在任何层次上。<br>例如 int * const p， 申明了p是“constant pointer to int”, const修饰的是第一层。<br>又比如 volatile int * p， p是 “pointer to volatile int”, volatile修饰的是第二层。</p>
<p>● 在C++中修饰第1层的cv修饰符被称为顶层cv修饰符(top-level cv-qualifier)</p>
<p>再比如：<br>const int * volatile p , 顶层cv修饰符是volatile<br>int * const p, 顶层cv修饰符是const<br>int const volatile * p, 没有顶层修饰符</p>
<p>基本类型例如char, int只由一层构成，因此如下的申明<br>const int x &#x3D; 1;<br>顶层cv修饰符是const.</p>
<p>◆ 小知识：<br>C++函数签名包括所有出现在参数列表中的cv修饰符，除了那些出现在参数列表中的顶层cv修饰符。<br>因此如下2个函数拥有相同的函数签名，认为是同一个函数。<br>虽然函数签名的参数列表中忽略了顶层cv修饰符，但是但函数体内，顶层cv修饰符还是起作用的。比如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">pp</span><span class="params">(<span class="type">int</span> *<span class="type">const</span> p)</span></span>&#123;</span><br><span class="line">   p = … <span class="comment">// error不能对常量指针进行赋值。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="转发引用（forwarding-reference"><a href="#转发引用（forwarding-reference" class="headerlink" title="转发引用（forwarding reference)"></a>转发引用（forwarding reference)</h2><p>转发引用是一种能够保留函数参数值类型的一种特殊引用，这使它能够通过std::forward进行转发。转发引用由2中形式</p>
<p>1.它是函数模板的函数参数，该参数是对同一函数模板的无cv修饰符的类型模板参数的右值引用。(Function parameter of a function template declared as rvalue reference to cv-unqualified type template parameter of that same function template。)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(T&amp;&amp; x)</span> </span>&#123;    <span class="comment">// x is a forwarding reference</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">g</span>(std::forward&lt;T&gt;(x)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">(<span class="type">const</span> T&amp;&amp; x)</span></span>; <span class="comment">// x is not a forwarding reference:</span></span><br><span class="line">                              <span class="comment">// const T is not cv-unqualified</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="title">A</span><span class="params">(T&amp;&amp; x, U&amp;&amp; y, <span class="type">int</span>* p)</span></span>; </span><br><span class="line">    <span class="comment">// x is not a forwarding reference: T is not a</span></span><br><span class="line">    <span class="comment">// type template parameter of the constructor,</span></span><br><span class="line">    <span class="comment">// but y is a forwarding reference</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.auto&amp;&amp;</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">auto<span class="meta">&amp;&amp; vec = foo();       </span></span><br><span class="line"><span class="comment">// foo() may be lvalue or rvalue, </span></span><br><span class="line"><span class="comment">// vec is a forwarding reference</span></span><br><span class="line"></span><br><span class="line">for (auto<span class="meta">&amp;&amp; x: f()) &#123; <span class="comment">// x is a forwarding reference; </span></span></span><br><span class="line"><span class="comment">// this is the safest way to use range for loops</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模板类型推导"><a href="#模板类型推导" class="headerlink" title="模板类型推导"></a>模板类型推导</h2><p>现代C++最引人注目的特性之一就是atuo，它是建立在模板类型推导基础之上的。但模板类型推导应用于auto上有时候不如应用于模板那么直观，所以我们有必要真正的理解模板类型推导, 这样才能更好的理解auto推导。</p>
<p>我们把函数模板表示为如下形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>;</span><br></pre></td></tr></table></figure>
<p>对它的调用表示为：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(expr); // <span class="keyword">call</span> f <span class="keyword">with</span> <span class="keyword">some</span> expression</span><br></pre></td></tr></table></figure>
<p>编译期间，编译器使用expr去推导T和ParamType这两个类型。这两个类型通常是不同的，因为ParamType通常会有cv或引用修饰。<br>例如模板申明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp; param)</span></span>; / / ParamType is <span class="type">const</span> T&amp;</span><br></pre></td></tr></table></figure>
<p>调用如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">f(x);   <span class="operator">/</span><span class="operator">/</span> <span class="keyword">call</span> f <span class="keyword">with</span> an <span class="type">int</span></span><br></pre></td></tr></table></figure>
<p>T被推导为int， ParamType被推导为const int&amp;.<br>在这个例子中T和x的类型都是int，然而并不是所有情况都是如此，T的类型不仅取决于expr的类型还取决于ParamType的形式。</p>
<h3 id="推导规则：（并非C-标准定义的规则，而是易于理解记忆的规则）"><a href="#推导规则：（并非C-标准定义的规则，而是易于理解记忆的规则）" class="headerlink" title="推导规则：（并非C++标准定义的规则，而是易于理解记忆的规则）"></a>推导规则：（并非C++标准定义的规则，而是易于理解记忆的规则）</h3><p>★ 忽略expr的引用类型<br>★ 如果ParamType是非引用类型：<br>■ 如果expr是数组会转化为指向数组第一项元素的指针<br>■ 如果expr是函数会转化为函数指针<br>■ expr的顶级cv修饰符会被忽略掉<br>★ expr 未被忽略掉的且在ParamType中没有出现的cv修饰符能在T中能得到保留。<br>★如果ParamType是转发引用且expr为左值，那么T和ParamType都为左值引用。其余场景将T直接替换到ParamType中去就是param的类型。</p>
<p>下面根据ParamType的如下三种常见形式进行举例说明。</p>
<ol>
<li>aramType是普通引用类型（非转发引用）。</li>
<li>aramType是转发引用</li>
<li>aramType 不是引用类型</li>
</ol>
<p>场景1 : ParamType是普通引用类型（非转发引用）</p>
<h4 id="例1：ParamType是左值引用"><a href="#例1：ParamType是左值引用" class="headerlink" title="例1：ParamType是左值引用"></a>例1：ParamType是左值引用</h4><p>template<typename T><br>void f(T&amp; param);<br>expr定义如下，本章所有场景的例子都使用如下定义，不再特别说明。<br>int x &#x3D; 1;<br>in&amp; rx &#x3D;x;<br>const int cx &#x3D; x;<br>const int&amp; rcx &#x3D; x;<br>volatile int vx &#x3D; x;<br>volatile int&amp; rvx &#x3D; x;<br>const volatile int cvx &#x3D; x;<br>const volatile int&amp; rcvx &#x3D; x;<br>int* px &#x3D; &amp;x;<br>int*&amp; rpx &#x3D; px;<br>int *const cpx &#x3D; &amp;x;<br>const int *pcx &#x3D; &amp;x;<br>const int *const cpcx &#x3D; &amp;xl;<br>int ar[] &#x3D; {1,2,3};<br>void ff(int v){}<br>对于各种情况的调用，T和param的类型如下</p>
<p><img src="https://img-blog.csdnimg.cn/298676bd18034ac58a4e1f473aa3e69e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2FjaGVmaXNo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="image"></p>
<p>要点：<br>●expr中的const和volatile都在T中得到了保留<br>●f(rcx), f(rvx)中，T都不是引用类型，因为rcx和rvx的引用类型都在推导过程中被忽略了。<br>●对于const和volatile的处理都是一样的。</p>
<p>例2：ParamType是cv左值引用<br>对前面的例子稍加改动，ParaType从T&amp;变为const T&amp;<br>template<typename T><br>void f(const T&amp; param);<br>对于各种情况的调用，T和param的类型如下<br><img src="https://img-blog.csdnimg.cn/ff2d4e927aa24e0285aa3213b7dbcf7a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2FjaGVmaXNo,size_19,color_FFFFFF,t_70,g_se,x_16" alt="image"></p>
<p>要点：<br>●因为ParaType中有了const，因此const不必包含在T中（对于volatile同理）。（对于实参为指针类型，ParaType中的const修饰的是指针本身而非指针指向的内容。）<br>●f(vx), f(rvx), f(cvx)中因为ParaType中没有volatile，因此volatile仍在T中得到保留。<br>●expr是指针类型和值类型并无处理上的不同。</p>
<h3 id="例3：ParamType是右值引用"><a href="#例3：ParamType是右值引用" class="headerlink" title="例3：ParamType是右值引用"></a>例3：ParamType是右值引用</h3><p>template<typename T><br>void f(const T&amp;&amp; param);<br>注意：若果没有const修饰，就是转发引用了，后面会特别讨论。</p>
<p>此种情况expr只能是右值。</p>
<p>对于各种情况的调用，T和param的类型如下:<br><img src="https://img-blog.csdnimg.cn/8cf76cd0dcdc4c538f120ba6a67a5a7e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2FjaGVmaXNo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="image"></p>
<p>要点：<br>●move 不改变cv<br>●除了函数只接受右值和前面的情况不没有啥不同。</p>
<p>场景2 : ParamType是转发引用类型<br>ParamType是转发引用只有如下一种情况<br>template<typename T><br>void f(T&amp;&amp; param);</p>
<p>推导规则补充说明：<br>1.如果expr是左值，T和ParamType都推导为左值引用。<br>2.如果expr是右值，根据普通引用的规则进行推导。</p>
<p>对于传入右值的调用，T和param的类型如下:<br><img src="https://img-blog.csdnimg.cn/66e2a725edc1412eacf3ed1e1abfd015.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2FjaGVmaXNo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="image"></p>
<p>要点：<br>●para都是右值引用</p>
<p>对于传入左值的调用，T和param的类型如下:<br><img src="https://img-blog.csdnimg.cn/c97e62bb5c494330be1cc834c0cddc8b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2FjaGVmaXNo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="image"></p>
<p>要点：<br>●如果expr是左值T被推导为左值引用，这是模板类型推导唯一会推导出T为引用类型的场景。<br>●expr中的const和volatile都在T中得到了保留</p>
<p>场景3: ParamType不是引用类型（指针或值）<br>推导要点：忽略expr的顶级cv修饰符，数组和函数会退化为指针类型。<br>例1：ParamType是值<br>template<typename T><br>void f(T param);<br>对于各种情况的调用，T和param的类型如下:<br><img src="https://img-blog.csdnimg.cn/26c2e61c8ae94050a9577d69a5557603.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2FjaGVmaXNo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="image"></p>
<p>例2：ParamType是指针<br>template<typename T><br>void f(T* param); </p>
<p>对于各种情况的调用，T和param的类型如下<br><img src="https://img-blog.csdnimg.cn/9d536ce3fff04e7c8377b576cdebea75.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2FjaGVmaXNo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="image"><br>备注：T都不为指针类型，因为ParamType中已经有指针了，指针类型不必包含在T中了。（和cv的处理同理）</p>
<p>auto类型推导<br>auto类型和推导同模板类型推导基本有一样的规则，只有一个例外，后面会讲到。虽然形式上2者看起来不一样但是2者存在直接的映射关系。</p>
<p>前一节中我们把函数模板表示为如下形式：<br>template<typename T><br>void f(ParamType param);<br>对它的调用表示为：<br>f(expr); &#x2F;&#x2F; call f with some expression<br>当调用f, 编译器使用expr推断T和ParamType的类型。<br>当一个变量定义时使用auto，auto的作用相当于T，变量的类型说明符相当于ParamType, 变量名相当于param, 右边的初始化表达式相当于expr, 例如：</p>
<p><img src="https://img-blog.csdnimg.cn/bef2217e10c84e5898c7ebe14cee839b.png" alt="image"></p>
<p>如下例子是一些例子，和模板类型推导没有任何区别：</p>
<figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">auto</span> x = <span class="number">1</span>;                //<span class="keyword">case</span> <span class="number">3</span>, x <span class="keyword">is</span> <span class="type">int</span></span><br><span class="line"><span class="type">auto</span>* px = &amp;x;             //<span class="keyword">case</span> <span class="number">3</span>, px <span class="keyword">is</span> *<span class="type">int</span></span><br><span class="line"><span class="keyword">const</span> <span class="type">auto</span> cx = x;         //<span class="keyword">case</span> <span class="number">3</span>, cx <span class="keyword">is</span> <span class="keyword">const</span> <span class="type">int</span></span><br><span class="line"><span class="keyword">const</span> <span class="type">auto</span>&amp; rx = x;        //<span class="keyword">case</span> <span class="number">1</span>, rx <span class="keyword">is</span> <span class="keyword">const</span> <span class="type">int</span>&amp;</span><br><span class="line"><span class="type">auto</span>&amp;&amp; fr1 = x;            //<span class="keyword">case</span> <span class="number">2</span>, fr1 <span class="keyword">is</span> <span class="type">int</span>&amp;</span><br><span class="line"><span class="type">auto</span>&amp;&amp; fr2 = cx;           //<span class="keyword">case</span> <span class="number">2</span>, fr2 <span class="keyword">is</span> <span class="keyword">const</span> <span class="type">int</span>&amp;</span><br><span class="line"><span class="type">auto</span>&amp;&amp; fr3 = <span class="number">27</span>;           //<span class="keyword">case</span> <span class="number">2</span>, fr3 <span class="keyword">is</span> <span class="type">int</span>&amp;&amp;</span><br></pre></td></tr></table></figure>

<p>和模板类型推导的唯一例外<br>前面看到的都是auto类型推导和模板类型推导的相同之处，这里要介绍他们唯一的不同。<br>C++11之前定义并初始化一个变量可以按照如下方式：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int x1 <span class="operator">=</span> <span class="number">1</span><span class="comment">;</span></span><br><span class="line">int x2(<span class="number">1</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>C++11开始支持统一初始化,支持如下形式：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int x3&#123;<span class="number">1</span>&#125;</span><br><span class="line">int x4 <span class="operator">=</span> &#123;<span class="number">1</span>&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>如果使用auto来从写上面4个定义</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto x1 <span class="operator">=</span> <span class="number">1</span><span class="comment">;</span></span><br><span class="line">auto x2(<span class="number">1</span>)<span class="comment">;</span></span><br><span class="line">auto x3&#123;<span class="number">1</span>&#125;<span class="comment">;</span></span><br><span class="line">auto x4<span class="operator">=</span>&#123;<span class="number">1</span>&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>上面4个auto定义的变量类型并不都是int， x4为std::initializer_list. (C++11中x3也为std::initializer_list，之后的标准中为int).<br>★这就是auto类型推导的特别之处，对于&#x3D;{}形式的初始化特别处理了。<br>★函数模板不支持对{}的推导。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">auto</span> x = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125; // x的类型为std::initializer_list&lt;int&gt;</span><br><span class="line"><span class="attribute">template</span>&lt;typename T&gt;</span><br><span class="line"><span class="attribute">void</span> f(T param);</span><br><span class="line"><span class="attribute">f</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;)         //error! 不能推导T的类型</span><br></pre></td></tr></table></figure>
<p>但是模板类型推导支持 param 是std::initializer_list<T>的形式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::initializer_list&lt;T&gt; init_list)</span></span>;</span><br><span class="line"><span class="built_in">f</span>(&#123; <span class="number">11</span>, <span class="number">23</span>, <span class="number">9</span> &#125;); </span><br><span class="line"><span class="comment">// T为 int,init_list类型为 std::initializer_list&lt;int&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>auto也能推导函数返回值，此时应用的是也模板类型推导规则<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">create_initlist</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;  <span class="comment">// error: can&#x27;t deduce type  for </span></span><br><span class="line">                     <span class="comment">// &#123; 1, 2, 3 &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>auto 应用于lambda也是模板类型推导规则<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">auto</span> reset_v = [&amp;v](<span class="type">const</span> <span class="keyword">auto</span>&amp; new_value) &#123; </span><br><span class="line">v = new_value; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">reset_v</span>(&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;); <span class="comment">// error! can&#x27;t deduce type for</span></span><br><span class="line">                      <span class="comment">//&#123; 1, 2, 3 &#125;</span></span><br></pre></td></tr></table></figure>
decltype(auto)<br>decltype 总是返回实体的准确类型， auto使用模板类型推导的规则(比如会去掉引用等）。</li>
</ul>
<p>decltype示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">0</span>;           <span class="comment">// decltype(i) is const int</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">f</span><span class="params">(<span class="type">const</span> Widget&amp; w)</span></span>;   <span class="comment">// decltype(w) is const Widget&amp;</span></span><br><span class="line">                           <span class="comment">// decltype(f) is bool(const Widget&amp;)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="type">int</span> x, y;                <span class="comment">// decltype(Point::x) is int</span></span><br><span class="line">&#125;;                         <span class="comment">// decltype(Point::y) is int</span></span><br><span class="line">Widget w;                  <span class="comment">// decltype(w) is Widget</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">f</span>(w)) ...              <span class="comment">// decltype(f(w)) is bool</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;       <span class="comment">// simplified version of std::vector</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  T&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> index);</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;             <span class="comment">// decltype(v) is vector&lt;int&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (v[<span class="number">0</span>] == <span class="number">0</span>) ...         <span class="comment">// decltype(v[0]) is int&amp;</span></span><br></pre></td></tr></table></figure>

<p>◆Decltype可以和auto组合使用，使auto应用decltype的规则。<br>单纯使用auto</p>
<figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Widget</span> w;</span><br><span class="line"><span class="keyword">const</span> <span class="type">Widget</span>&amp; cw = w;</span><br><span class="line"><span class="type">auto</span> mw = cw;  // <span class="type">auto</span> <span class="keyword">type</span> deduction, mw&#x27;s <span class="keyword">type</span> <span class="keyword">is</span> <span class="type">Widget</span></span><br></pre></td></tr></table></figure>
<p>使用decltype(auto)</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">decltype(auto) mw = cw; // decltype <span class="keyword">type</span> <span class="type">deduction:</span></span><br><span class="line"><span class="type">                        </span>// mw<span class="symbol">&#x27;s</span> <span class="keyword">type</span> <span class="type">is </span>const Widget&amp;</span><br></pre></td></tr></table></figure>

<h3 id="如何查看推导得出的类型"><a href="#如何查看推导得出的类型" class="headerlink" title="如何查看推导得出的类型"></a>如何查看推导得出的类型</h3><h4 id="通过编译错误信息"><a href="#通过编译错误信息" class="headerlink" title="通过编译错误信息"></a>通过编译错误信息</h4><p>可以让编译器使用推导出的类型时产生编译错误，从而在输出的错误信息中看到推导出的类型。比如我们只申明但不定义一个类模板，然后使用这类模板。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TD</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">f1</span><span class="params">(T&amp; param)</span></span>&#123;</span><br><span class="line">    TD&lt;<span class="keyword">decltype</span>(param)&gt; pt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(deduce, <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">f1</span>(ff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在vc2019下有如下输出：<br>error C2079: “pt”使用未定义的 class“TD&lt;T (__cdecl &amp;)&gt;”<br>message : 查看对正在编译的函数 模板 实例化“void f1&lt;void(int)&gt;(T (__cdecl &amp;))”的引用</p>
<p>在g++ 11下有如下输出：<br>In instantiation of ‘void f1(T&amp;) [with T &#x3D; void(int)]’:<br>error: ‘TD&lt;void (&amp;)(int)&gt; pt’ has incomplete type</p>
<p>从中我们都可以看出T的类型为void(int), param的类型为void(&amp;)(int)</p>
<p>使用Boost.Type‐Index<br>该库是头文件形式的库，不需要编译，下载boost后直接include就可以使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">f1</span><span class="params">(T&amp; param)</span></span>&#123;</span><br><span class="line"><span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;T=&quot;</span> &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;T&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;param=&quot;</span> &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(param)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">f1</span>(ff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>G++11编译输出如下：<br>T&#x3D;void (int)<br>param&#x3D;void (&amp;)(int)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cachefish.github.io/2022/03/07/15-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2229.jfif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="来世做春风，浪漫且自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cachecatのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/07/15-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" class="post-title-link" itemprop="url">c++ 字符编码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-07 19:30:00 / 修改时间：10:13:28" itemprop="dateCreated datePublished" datetime="2022-03-07T19:30:00+08:00">2022-03-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-base/" itemprop="url" rel="index"><span itemprop="name">c++ base</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="字符编码概述"><a href="#字符编码概述" class="headerlink" title="字符编码概述"></a>字符编码概述</h2><p>字符集就是一系列用于显示的字符的集合。<br>编码就是这些字符如何用字节流进行表示。一个字符集可能有多种编码方式.</p>
<h3 id="ANSI编码"><a href="#ANSI编码" class="headerlink" title="ANSI编码"></a>ANSI编码</h3><p>世界各国针对ASCII的扩展方案（如欧洲的ISO&#x2F;IEC 8859，中国的GB系列等），这些ASCII扩展编码方案的特点是：他们都兼容ASCII编码，但他们彼此之间是不兼容的。微软将这些编码方案统称为ANSI编码。</p>
<h3 id="代码页"><a href="#代码页" class="headerlink" title="代码页"></a>代码页</h3><p>在windows操作系统上，默认使用ANSI来保存文件。那么操作系统是如何知道ANSI到底应该表示哪种编码了，是GBK，还是ASCII，或者还是EUC-KR了？ windows通过一个叫”Code Page”（翻译为中文就叫代码页）的东西来判断系统的默认编码。<br>ANSI编码可以理解为非Unicode编码的统称</p>
<p>各种编码的字符串能强制转换为char类型的字符串来操作？<br>UTF16,UTF32编码不行，因为中间bytes存在大量0。<br>UTF8和其它ANSI编码可以，因为本来就是多字节编码没必要在中间添加0来浪费空间。</p>
<h2 id="源字符集，执行字符集"><a href="#源字符集，执行字符集" class="headerlink" title="源字符集，执行字符集"></a>源字符集，执行字符集</h2><p>源字符集(source character set)：<br>源字符集中的字符就是源程序的字符，编译器读取源文件时需要理解的编码方式（注意没有编辑器什么关系）。<br>执行字符集(execution character set)：<br>执行字符集表示可出现在已编译程序中的字符，程序运行时字符的编码方式。 这些字符集由源文件中允许的所有字符以及表示警报、退格符、回车符和 null 字符的控制字符组成。</p>
<h3 id="vc-源字符集"><a href="#vc-源字符集" class="headerlink" title="vc 源字符集"></a>vc 源字符集</h3><p>1.若文件开始处有BOM(EF BB BF)，则判定为UTF-8编码；<br>2.若没有BOM，则试图从文件的前8个字节来判断文件是否像UTF-16编码，如果像，则就判断为UTF-16编码。<br>3.如果既没BOM，也不是UTF-16编码，则使用系统当前的代码页。<br>&#x2F;source-charset or &#x2F;utf-8  </p>
<h3 id="gcc-源字符集"><a href="#gcc-源字符集" class="headerlink" title="gcc 源字符集"></a>gcc 源字符集</h3><p>默认UTF-8<br>-finput-charset</p>
<h3 id="vc-执行字符集"><a href="#vc-执行字符集" class="headerlink" title="vc 执行字符集"></a>vc 执行字符集</h3><p>1.对于宽字符串（即C&#x2F;C++中以L标记的串，如L”abc”, L’中’），执行字符集为UTF-16编码。<br>2.u8，u, U前缀字符串，分别UTF8, UTF16, UTF32编码<br>3.对于未带前缀的字符串，执行字符集为系统当前的代码页。<br>&#x2F;execution-charset or &#x2F;utf-8 </p>
<h3 id="gcc执行字符集"><a href="#gcc执行字符集" class="headerlink" title="gcc执行字符集"></a>gcc执行字符集</h3><p>1.对于宽字符串UTF-32<br>2.u8，u, U前缀字符串，分别UTF8, UTF16, UTF32编码<br>3.对于未带前缀的字符串，默认UTF-8<br>-fexec-charset<br>-fwide-exec-charset</p>
<h3 id="VC"><a href="#VC" class="headerlink" title="VC"></a>VC</h3><p>VC默认情况下，Visual Studio会检测字节顺序标记，以确定源文件是否是编码过的Unicode格式，例如UTF-16或UTF-8。如果没有找到字节顺序标记，它假定源文件是使用当前用户代码页编码的，除非您通过使用&#x2F;source-charset选项或&#x2F;utf-8选项指定了字符集名称或代码页。Visual Studio允许你通过使用几种字符编码来保存你的c++源代码。有关源代码和执行字符集的信息，请参阅语言文档中的字符集。如果您希望将源字符集和执行字符集都设置为UTF-8，您可以使用&#x2F; UTF-8编译器选项作为快捷方式。它相当于在命令行上指定&#x2F;sourcecharset:utf-8 &#x2F; execute -charset:utf-8。默认情况下，这些选项都启用&#x2F;validate-charset选项。</p>
<h3 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h3><ul>
<li>-finput-charset&#x3D;charset<br> 设置输入字符集，用于将输入文件的字符集转换为GCC使用的源字符集。如果区域设置没有指定，或者GCC无法从区域设置获取此信息，则默认为UTF-8。这可以被区域设置或命令行选项覆盖。目前，如果有冲突，命令行选项优先。Charset可以是系统iconv库例程支持的任何编码。</li>
<li>-fexec-charset&#x3D;charset<br>设置执行字符集，用于字符串和字符常量。默认为UTF-8。Charset可以是系统iconv库例程支持的任何编码。</li>
<li>-fwide-exec-charset&#x3D;charset<br>设置宽执行字符集，用于宽字符串和字符常量。默认值是UTF-32或UTF-16，两者都对应于wchar_t的宽度。和’-fex -charset’一样，charset可以是系统iconv库例程支持的任何编码;但是，编码不完全适合wchar_t会有问题。</li>
</ul>
<h2 id="字符文本"><a href="#字符文本" class="headerlink" title="字符文本"></a>字符文本</h2><p>字符字面值由常量字符组成。它由单引号包围的字符表示。字符字面值有五种:</p>
<ol>
<li>char类型的普通字符字面值，例如’a’</li>
<li>char类型的UTF-8字符字面值(c++20中的char8_t)，例如u8’a’．</li>
<li>wchar_t类型的宽字符字面值，例如L’a’</li>
<li>char16_t类型的UTF-16字符字面值，例如u’a’</li>
<li>char32 t类型的UTF-32字符字面值，例如U’a’</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> s3 = <span class="string">u&quot;hello&quot;</span>; <span class="type">const</span> <span class="type">char16_t</span>*</span><br><span class="line"><span class="keyword">auto</span> s4 = <span class="string">U&quot;heelo&quot;</span>; <span class="type">const</span> <span class="type">char32_t</span>*</span><br><span class="line"><span class="type">const</span> <span class="type">wchar_t</span> wide = <span class="string">L&quot;zyxw&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">wchar_t</span> newline=<span class="string">L&quot;hello\ngood&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//c++20 -&gt;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char8_t</span> u8str1 = <span class="string">u8&quot;hello world&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char8_t</span> u8str2 = <span class="string">u8&quot;\U0001F607 is 0:-&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="std-string-文本"><a href="#std-string-文本" class="headerlink" title="std::string 文本"></a>std::string 文本</h2><p>string字面值是用户定义的字面值(见下文)的标准库实现，表示为“xyz”(带有s后缀)。这种字符串字面值产生一个临时对象，类型为std::string、std::wstring、std::u32string或std::u16string，这取决于所指定的前缀。如果没有使用任何前缀，就会产生一个std::string。L”xyz”生成一个std::wstring。u”xyz”s生成一个std:u16string, u”xyz”s生成一个std:u32string。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str&#123;<span class="string">&quot;hello&quot;</span>s&#125;;</span><br><span class="line"><span class="built_in">string</span> str2&#123;u8<span class="string">&quot;&quot;</span>Hello world<span class="string">&quot;&#125;;</span></span><br><span class="line"><span class="string">u8string u8str2&#123;u8&quot;</span>Hello World<span class="string">&quot;&#125;;</span></span><br><span class="line"><span class="string">wstring str3&#123;L&quot;</span>hello<span class="string">&quot;s&#125;;</span></span><br><span class="line"><span class="string">u16string str4&#123;u&quot;</span>hello<span class="string">&quot;s&#125;;</span></span><br><span class="line"><span class="string">u32string str5&#123;U&quot;</span>hello<span class="string">&quot;s&#125;;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<h3 id="字符文本的执行期编码："><a href="#字符文本的执行期编码：" class="headerlink" title="字符文本的执行期编码："></a>字符文本的执行期编码：</h3><p>除了普通字符和宽字符由编译器决定，其余字符文本都给予前缀表示的方式进行编码。可见同一个编译单元中字符的执行期编码可以有多种。</p>
<p>对于程序运行过程的和外界交互（网络收发，文件读写，数据库读写等）涉及到的字符，则要规定好编码方式，然后进行处理。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt=""
      src="/images/2229.jfif">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description">来世做春风，浪漫且自由</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">38</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/cachefish" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cachefish" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/cachefish@163g.com" title="E-Mail → cachefish@163g.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cachecat</span>
</div>
<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"left","width":240,"height":360},"mobile":{"show":false},"react":{"opacityDefault":1,"opacityOnHover":1},"log":false,"tagMode":false});</script></body>
</html>
