<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cachefish.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="来世做春风，浪漫且自由">
<meta property="og:type" content="website">
<meta property="og:title" content="cachecatのBlog">
<meta property="og:url" content="https://cachefish.github.io/page/5/index.html">
<meta property="og:site_name" content="cachecatのBlog">
<meta property="og:description" content="来世做春风，浪漫且自由">
<meta property="og:locale" content="zh_CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://cachefish.github.io/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>cachecatのBlog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">cachecatのBlog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">localhost</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">19</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">19</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">49</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cachefish.github.io/2022/03/02/5-%E7%BD%91%E7%BB%9C%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2229.jfif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="来世做春风，浪漫且自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cachecatのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/02/5-%E7%BD%91%E7%BB%9C%E5%B1%82/" class="post-title-link" itemprop="url">网络层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-02 19:30:00" itemprop="dateCreated datePublished" datetime="2022-03-02T19:30:00+08:00">2022-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-03 09:30:43" itemprop="dateModified" datetime="2022-03-03T09:30:43+08:00">2022-03-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/base-network/" itemprop="url" rel="index"><span itemprop="name">base network</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="网络层的必要性"><a href="#网络层的必要性" class="headerlink" title="网络层的必要性"></a>网络层的必要性</h2><p>网络层建立在数据链路层的两个相邻端点之间的数据帧的传送能力之上，将数据从源端经过若干中间结点传送到目的端，从而向传输层提供最基本的端到端的数据传送服务。</p>
<hr>
<p>面向无连接的服务在通信子网内以数据报实现(提供源-&gt;目的之间的数据收发)</p>
<p>数据报: 在数据报的操作方式中，每个分组的传送是被单独处理的，每个分组成为数据报。它是完备、独立的数据实体，每个数据报自身携带要从源计算机传递到目的计算机的信息，该信息不依赖于源计算机和目的计算机以及传输网络间交换。一个结点收到一个数据报后根据数据报的地址信息和结点所存储的路由信息，找到下一个合适的出路，将数据报原样的发送到下一个结点。</p>
<p>面向连接指的是在数据传输之前双方需要建立一种连接，然后在该连接上实现有次序的分组传输，直到数据传输完毕才会释放连接(面向连接的服务采用虚电路(virtual circuit)方式实现。虚电路指的是通信子网为实现面向连接服务而在源与目的之间所建立的逻辑通信链路(每个节点都包含一个虚电路)。</p>
<h2 id="数据交换方式"><a href="#数据交换方式" class="headerlink" title="数据交换方式"></a>数据交换方式</h2><p>采用交换机或结点机等交换系统，通过路由选择技术在欲进行通信的双方之间建立的物理或者逻辑的交换，形成通路。</p>
<p>电路交换:在传输任何数据之前，都必须建立端到端(站到站)的线路，即在原节点和目的结点间寄哪里一条由各个中间交换结点的分段连接所组成的通信电路，使用这个专用电路从站点A-&gt;B传输</p>
<p>报文交换:属于存储交换，它不需要在两个站之间建立一条专用通路。<br>原理:把待存储的信息存储起来，等信道空闲时发出来，只要存储时间足够长，就能够把信道忙碌和空闲的状态均匀化，大大压缩了必须的信道容量和转接设备容量。</p>
<h3 id="报文分组交换"><a href="#报文分组交换" class="headerlink" title="报文分组交换"></a>报文分组交换</h3><p>把大的数据块分割成小的数据块，并规定了最大的分组长度。</p>
<h3 id="如何屏蔽异种网络的差异"><a href="#如何屏蔽异种网络的差异" class="headerlink" title="如何屏蔽异种网络的差异"></a>如何屏蔽异种网络的差异</h3><p>统一网络地址()  统一数据格式(ip数据报)</p>
<h3 id="如何实现全网的数据传输和变换"><a href="#如何实现全网的数据传输和变换" class="headerlink" title="如何实现全网的数据传输和变换"></a>如何实现全网的数据传输和变换</h3><p>网络之间的数据包寻径，转发(路由器、路由表)<br>路由表的产生和动态刷新、差错处理。</p>
<hr>
<h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><p>ip协议定义了用以实现面向无连接服务的网络分组格式。是一个面向无连接的、不可靠的数据报传输协议</p>
<p>无连接指的是不维护IP分组发送后的状态信息，并且每个数据分组的处理是相对独立的。</p>
<p>不可靠指的是IP协议不能保证每个ip分组能够成功的到达目的结点，也不能保证分组传输的顺序。</p>
<h2 id="ip协议格式"><a href="#ip协议格式" class="headerlink" title="ip协议格式"></a>ip协议格式</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">版本  首部长度 服务类型 总长度 标识 标志 片偏移 生存时间(<span class="meta">TTL</span>) 协议 首部校验和 可选字段 <span class="built_in">ip</span>地址</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="ip地址"><a href="#ip地址" class="headerlink" title="ip地址"></a>ip地址</h4><p>以32位二进制位的形式存储于计算机中，32位的ip地址由网络标识和主机号两部分组成(网络标识用于标识该主机所在的网络，而主机号则表示该主机在相应网络中的特定位置)</p>
<p>A: 0.0.0.0—–127.255.255.255<br>B: 128.0.0.0—–191.255.255.255<br>C: 192.0.0.0—-223.255.255.255<br>D: 224.0.0.0—-255.255.255.255</p>
<hr>
<h2 id="ARP地址解析协议"><a href="#ARP地址解析协议" class="headerlink" title="ARP地址解析协议"></a>ARP地址解析协议</h2><p>ARP（Address ResolutionProtocol）地址解析协议，目的是实现IP地址到MAC地址的转换。</p>
<p>所谓“地址解析”就是主机在发送帧前将目标IP地址转换成目标MAC地址的过程。ARP协议的基本功能就是通过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的顺利进行。</p>
<h2 id="上层（网络层）关心的IP地址，下层-数据链路层-关心的是MAC地址，这个时候就需要映射IP和MAC。"><a href="#上层（网络层）关心的IP地址，下层-数据链路层-关心的是MAC地址，这个时候就需要映射IP和MAC。" class="headerlink" title="上层（网络层）关心的IP地址，下层(数据链路层)关心的是MAC地址，这个时候就需要映射IP和MAC。"></a>上层（网络层）关心的IP地址，下层(数据链路层)关心的是MAC地址，这个时候就需要映射IP和MAC。</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>主机A的IP地址为192.168.1.1，MAC地址为0A-11-22-33-44-01；<br>主机B的IP地址为192.168.1.2，MAC地址为0A-11-22-33-44-02；<br>当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址（192.168.1.2）解析成主机B的MAC地址，以下为工作流程：</p>
<ul>
<li>第1步：根据主机A上的路由表内容，IP确定用于访问主机B的转发IP地址是192.168.1.2。然后A主机在自己的本地ARP缓存中检查主机B的匹配MAC地址。</li>
<li>第2步：如果主机A在ARP缓存中没有找到映射，它将询问192.168.1.2的硬件地址，从而将ARP请求帧广播到本地网络上的所有主机。源主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接收到ARP请求并且检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，它将丢弃ARP请求。</li>
<li>第3步：主机B确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。</li>
<li>第4步：主机B将包含其MAC地址的ARP回复消息直接发送回主机A。</li>
<li>第5步：当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。<br><img src="https://img-blog.csdnimg.cn/5895276f74be41859cdd37e3eed437ee.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2FjaGVmaXNo,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="image"></li>
</ul>
<hr>
<h3 id="ARP报文总长度"><a href="#ARP报文总长度" class="headerlink" title="ARP报文总长度"></a>ARP报文总长度</h3><p>ARP报文的总长度为64字节。</p>
<p>首先要知道帧的概念 帧是在数据链路层传输的数据格式，比如以太网v2，以太网IEEE802.3和PPP等。</p>
<p>所以Wireshark抓到的帧是包含帧头的，即包含以太网v2的帧头，长14 bytes；</p>
<p>而ARP数据包的长度固定为28 bytes；</p>
<p>帧总长度 &#x3D; 帧头 + 网络层包头 + 传输层报文头 + 应用数据；</p>
<p>而ARP请求中ARP包已经是最高层，之上没有传输层和应用层，所以总长度为：</p>
<p>帧总长度 &#x3D; 帧头 + ARP包头 &#x3D; 14 + 28 &#x3D; 42 bytes；</p>
<p>而真正 发包的时为了保证以太网帧的最小帧长为64 bytes，会在报文里添加一个padding字段，用来填充数据包大小。</p>
<p>使用wireshark抓包时，抓到的包为60 bytes。比以太网帧的最小帧长扫了4 bytes，原因是因为wireshark抓包时不能抓到数据包最后的CRC字段。</p>
<p>CRC字段是为了校验以太网帧的正确性。在数据包填充完成后，回去通过算法计算一个值放到数据包的CRC字段中。当接受端收到数据包后，会同样使用算法计算一个值，然后和CRC字段的值进行对比，查看是否相同。如果不同则证明数据包被更改，如果相同则证明数据包并未被更改。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cachefish.github.io/2022/03/02/8-%E8%A7%89%E6%82%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2229.jfif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="来世做春风，浪漫且自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cachecatのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/02/8-%E8%A7%89%E6%82%9F/" class="post-title-link" itemprop="url">c++基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-02 19:30:00" itemprop="dateCreated datePublished" datetime="2022-03-02T19:30:00+08:00">2022-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-03 09:33:35" itemprop="dateModified" datetime="2022-03-03T09:33:35+08:00">2022-03-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-base/" itemprop="url" rel="index"><span itemprop="name">c++ base</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="个人品质"><a href="#个人品质" class="headerlink" title="个人品质"></a>个人品质</h2><ul>
<li>上心：人下班了，心未下班，灵感通常都是在路上，洗澡，吃饭等闲散时光产生的。</li>
<li>细致：不犯低级错误。</li>
<li>敏锐：能从蛛丝马迹中寻找线索。</li>
<li>耐心：和问题死磕到底，不解决问题誓不罢休。</li>
<li>勤学好思：多读书，多看牛人的代码，多思考为什么。</li>
<li>轻度强迫症：坚持原则，绝不妥协。</li>
<li>追求简洁，清晰，各个维度具有美感的设计和代码。</li>
<li><h2 id="好的代码该有的样子："><a href="#好的代码该有的样子：" class="headerlink" title="好的代码该有的样子："></a>好的代码该有的样子：</h2></li>
</ul>
<ol>
<li>一眼望过去规整，有美感。<br>  代码是来交流的，你能忍受杂乱无章，也要为其它人考虑下吧。况且乱中会出错。</li>
<li>层次清晰，对称。<br>  整个复杂的计算机世界都是分层建立起来的，各司其职，才能井井有条。你自己写的小小的代码也应当如此。<br>   对称不光能让一个东西协调，还能避免出错，易于理解。构造，析构; 开始，停止。</li>
<li>低耦合，高内聚。<br> 软件世界的精髓。可以对应许多耳熟能详的东西：封装，隐藏细节，屏蔽变化，高复用，函数式编程，模块化，可测性….</li>
<li>有恰如其分的注释。</li>
<li>简单，易懂，易维护。</li>
</ol>
<h2 id="命名规范："><a href="#命名规范：" class="headerlink" title="命名规范："></a>命名规范：</h2><p>形式A:aaa_bbb<br>形式B:AaaBbb<br>形式C:AAA_BBB</p>
<p>除类名用形式B,常量用形式C,其余所有地方都用形式A.（变量名,函数名,源&#x2F;头文件名,动态库，静态库，工程名，解决方案名，makefile名．．．．．．)</p>
<p>类名，变量名用名词结构，方法名用动宾结构。<br>名字都应该尽量简短，达意。</p>
<h3 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h3><p>不允许像MFC中那样以C开头</p>
<h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>纯数据类的成员变量不用以m_开头，其它类成员变量需要以m_开头。<br>原因：前缀m_主要时用来区分成员变量和局部变量，如果一个类是纯数据类，那么基本上是没有复杂成员函数的，所以不存在成员变量和局部变量区分的必要。纯数据类的成员变量通常是public的，加了m_，反而带来使用上的不便。</p>
<h3 id="全局变量名"><a href="#全局变量名" class="headerlink" title="全局变量名"></a>全局变量名</h3><p>g_variable_name<br>避免使用全局变量。用单健类来实现，或者重新设计逻辑。</p>
<h2 id="排版规范-核心规则："><a href="#排版规范-核心规则：" class="headerlink" title="排版规范 核心规则："></a>排版规范 核心规则：</h2><p>1.每行不超过110个字符。<br>2.缩进量4个space，tab键必须设置为替换为 4 个space。<br>3.所有块语句必须加{ ,即使单行代码<br>4.由于所有语句块都加了{}, 代码已经不密集了，尽量不要无谓的空行。<br>5.所有左大括号 { 前都不换行。<br>6.函数的多个参数尽可能在不超过总长度的前提下放在1行，换行要和第一个参数对齐：<br>7.初始化列表<br>如果单行能放下就不换行，否则全部换行，如下所示：<br>和成员变量之间有换行。成员变量优先放在默认成员初始化器（default member initializer）中，以免漏初始化。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cachefish.github.io/2022/02/24/4-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2229.jfif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="来世做春风，浪漫且自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cachecatのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/24/4-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/" class="post-title-link" itemprop="url">数据链路层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-24 19:30:00" itemprop="dateCreated datePublished" datetime="2022-02-24T19:30:00+08:00">2022-02-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-03 09:20:03" itemprop="dateModified" datetime="2022-03-03T09:20:03+08:00">2022-03-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/base-network/" itemprop="url" rel="index"><span itemprop="name">base network</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="数据链路层的必要性"><a href="#数据链路层的必要性" class="headerlink" title="数据链路层的必要性"></a>数据链路层的必要性</h2><hr>
<p>为了尽可能避免数据传输过程中的损坏和丢失问题 因为物理层只是关心原始比特流的传送，不考虑所传输信号的意义和信息结构，所以物理层不可能识别或判断数据在传输过程中是否出现了损坏或丢失，从而也谈不上采取相应的措施去补救。<br>收发双方的接收速率和发送速率不匹配引发的数据丢失问题。当数据发送方的能力大于接受方的数据接收能力时，接收方会因为来不及接收而产生数据溢出导致数据丢失，物理层不会考虑发送站点与接收站点速度。<br>总而言之，数据链路层拥有为了避免数据传输中的损失、丢失和维持传输速度的能力。</p>
<hr>
<h2 id="帧与成帧-数据控制"><a href="#帧与成帧-数据控制" class="headerlink" title="帧与成帧(数据控制)"></a>帧与成帧(数据控制)</h2><hr>
<p>数据链路层采用被称为帧的协议数据单元作为数据传输逻辑单元。</p>
<p>帧-&gt;  帧开始 | 地址 | 长度&#x2F;类型&#x2F;控制 | 数据 | FCS(帧校验序列) | 帧结束</p>
<p>引入帧机制可以实现相邻结点之间的可靠传输，有助于提高数据传输的效率。</p>
<p>&#x3D;&#x3D;作用:&#x3D;&#x3D;<br>使用帧的主要作用是数据被分成可恢复的区块并且可以很容易地检查这些区块是否被破坏。<br>传输过程中的故障会破坏某些帧。只有丢失的帧而不是整组数据需要重新传输。“错误检测和纠正”中论述了错误的检测和纠正。帧是一系列标准化的数据位，是网络通信的基本单元。<br>为了达到处理传输错误的目的，数据链路层要将数据流分成帧并且计算每帧的校验和，接收方对校验和进行检验；为了调节数据流的快慢，数据链路层要将数据分帧发送，当接收方速度过慢时，数据链路层可以停止发送下一帧并保持数据的完整性。</p>
<hr>
<h2 id="成帧过程"><a href="#成帧过程" class="headerlink" title="成帧过程"></a>成帧过程</h2><hr>
<p>发送方的数据链路层可以将从网络成接收到的分组封装成帧的功能，为来自上层的分组加入必要的帧头与帧尾部分，称为成帧</p>
<h3 id="帧同步"><a href="#帧同步" class="headerlink" title="帧同步"></a>帧同步</h3><p>四种定界方法(规定好的拆包格式)<br>网络中是以帧为最小单位进行传输的，所以接收端要正确的接收到帧，必须要清楚该帧在一串比特流中的开始和结尾，所以在组帧的时候既要加首部，也要加尾部。PS（而分组，即IP数据报仅仅是包含在帧的数据部分，所以不需要加尾部来定界，只需要添加首部就行了）</p>
<p>帧同步的方法有以下四种：<br>1.字符计数法<br>2.字节填充的首尾界符法：<br>3.比特填充的首尾标志法：<br>4.物理编码违例法：</p>
<hr>
<h2 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h2><hr>
<h4 id="差错"><a href="#差错" class="headerlink" title="差错"></a>差错</h4><p>指接收端收到的数据与发送段实际发出的数据出现不一致的现象。</p>
<h4 id="差错控制-1"><a href="#差错控制-1" class="headerlink" title="差错控制"></a>差错控制</h4><p>采用可靠的有效的编码以减少或消除计算机系统中传输差错的方法，用于提高传输质量。</p>
<h5 id="奇偶校验码、循环冗余校验码"><a href="#奇偶校验码、循环冗余校验码" class="headerlink" title="奇偶校验码、循环冗余校验码"></a>奇偶校验码、循环冗余校验码</h5><p>检错码本身不提供自动的错误纠正功能，需要一种与之相配套的错误纠正机制(反馈重发)</p>
<h5 id="1-停止-等待方式"><a href="#1-停止-等待方式" class="headerlink" title="1. 停止-等待方式"></a>1. 停止-等待方式</h5><p> 发送段发送出一帧后必须停下来等待接收端的对发送帧的确认。如果发送方未收到应答，则一直等待，所以有相应的控制机制使发送方能继续进行，不会出现无尽的等待，造成发送的死锁，所以要使用超时重发技术，每发送一个帧，启动一个超时定时器，超时则重新传输。</p>
<h5 id="2-连续ARQ协议"><a href="#2-连续ARQ协议" class="headerlink" title="2. 连续ARQ协议"></a>2. 连续ARQ协议</h5><p>发送方维持着一个一定大小的发送窗口，位于发送窗口内的所有分组都可连续发送出去，而中途不需要等待对方的确认；这样信道的利用率就提高了。而发送方每收到一个确认就把发送窗口向前滑动一个分组的位置。</p>
<ul>
<li>停止－等待Stop-and-Wait ARQ：发送窗口 &#x3D; 接收窗口 &#x3D; 1；效率低下。</li>
<li>SR协议（选择重传）：当发送方接受到接受方的状态报告指示报文出错时，发送方只发送出错的报文。因此必须在接受端加大缓存，以备所有序号都收到且连续然后一并交给主机。</li>
<li>GBN（回退N帧）协议：发送端发送完一个数据分组后，并不停下来等待确认消息，而是连续发送N个数据分组消息。当发送方接受到接受方的状态报告指示报文出错，发送方将重传过去的n个报文。该方法比停等式减少等待时间，提高吞吐率；但是一帧出错，必须重传其帧和后面n-1帧，增加了系统开销，在信道越差时，有待于确认的帧越多，可能要退回来重发很多帧，所以此方法性能不一定比停等式优越。</li>
</ul>
<hr>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><hr>
<p>由于系统性能不同，会导致发送方与接收方的处理数据速度有所不同，对于数据链路层来说，控制的是相邻两结点之间的数据链路的流量(传输层控制的是源端到目的端之间端到端的流量)</p>
<h3 id="滑动窗口协议实现流量控制与可靠性传输"><a href="#滑动窗口协议实现流量控制与可靠性传输" class="headerlink" title="滑动窗口协议实现流量控制与可靠性传输"></a>滑动窗口协议实现流量控制与可靠性传输</h3><p>本质:在收到一确认帧之前，对发送方可发送的帧的数目加以限制(是由发送方调整保留在重发表中的待确认帧的数目来实现的)<br>    如果接收方来不及对新到的帧进行处理，则停发确认信息，此时发送方的重发表就会增长，当达到重发表限度是，发送方就不再发送新的帧，知道再一次收到确认信息为止。<br><img src="https://img-blog.csdnimg.cn/06edd6690d224c5997f3414d6cd44727.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2FjaGVmaXNo,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="image"></p>
<hr>
<h2 id="关于MAC地址："><a href="#关于MAC地址：" class="headerlink" title="关于MAC地址："></a>关于MAC地址：</h2><p>MAC地址是用来识别数据链路层中相连的结点<br>MAC地址长度为48位, 6个字节，一般用16进制数字加上冒号的形式来表示(例如: 08:00:27:03:fb:19)<br>MAC地址在网卡出厂时就确定了, 不能修改。 MAC地址通常是唯一的(虚拟机中的MAC地址不是真实的MAC地址可 能会冲突，也有些网卡支持用户配置MAC地址)<br>为什么存在MAC地址还需要IP地址去标识互联网中的一台主机呢？</p>
<p>在数据链路层，存在多种异构的网络，比如以太网、令牌环网等，也就是数据链路层存在多种MTU，既多种不同的传输信道，如果只有MAC地址，在不同的网络之间是每有办法传输的，只能在MAC地址上封装一次抽象的IP地址来封装底层各种不同的网络。</p>
<h2 id="MAC地址和IP地址的对比："><a href="#MAC地址和IP地址的对比：" class="headerlink" title="MAC地址和IP地址的对比："></a>MAC地址和IP地址的对比：</h2><p>一个数据报中的源IP地址和目的IP地址是为了标识这个数据的起点和终点<br>源MAC地址和目的MAC地址是为了标识上一站的地址和下一站的地址<br>在一个数据报的传输过程中，IP一直不变，而MAC地址是一直在变的<br>关于MTU(最大传输单元)： MTU相当于在发寄快递的时候对包裹的限制，这个限制是不同的链路层对应的物理层的限制。</p>
<p>MAC帧中的数据长度规定为46-1500字节,ARP(地址解析协议)数据包的长度不够46字节要在后面补填充位，如果大于1500字节，必须要求网络层进行分片。<br>最大值1500称为以太网的最大传输单元(MTU)不同的网络类型有不同的MTU<br>如果一个数据包从以太网路由到拨号链路上，数据包长度大于拨号链路的MTU,则需要对数据包进行分片。<br>MTU对IP协议的影响： 由于链路层存在MTU的限制，导致网络层的报文如果超过1500字节，就必须要对齐进行分片发送。</p>
<p>将较大的IP包分成多个小包, 并给每个小包打上标签，每个小包IP协议头的 16位标识(id) 都是相同的，这样在重组的时候就知道这个小包来自于哪个报文。<br>每个小包的IP协议头的3位标志字段中, 第2位MF置为0, 表示允许分片, 第3位DF来表示结束标记(当前是否是后一个小包, 是的话置为1, 否则置为0)。<br>到达对端时再将这些小包按顺序重组, 拼装到一起返回给传输层。一旦这些小包中任意一个小包丢失，接收端的重组就会失败，但是IP层不会负责重新传输数据。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cachefish.github.io/2022/02/24/6-%E7%89%A9%E7%90%86%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2229.jfif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="来世做春风，浪漫且自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cachecatのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/24/6-%E7%89%A9%E7%90%86%E5%B1%82/" class="post-title-link" itemprop="url">物理层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-24 19:30:00" itemprop="dateCreated datePublished" datetime="2022-02-24T19:30:00+08:00">2022-02-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-03 09:20:16" itemprop="dateModified" datetime="2022-03-03T09:20:16+08:00">2022-03-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/base-network/" itemprop="url" rel="index"><span itemprop="name">base network</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="物理层的基本概念-是什么？"><a href="#物理层的基本概念-是什么？" class="headerlink" title="物理层的基本概念(是什么？)"></a>物理层的基本概念(是什么？)</h2><hr>
<p>物理层是网络基础的&#x3D;&#x3D;传输通道&#x3D;&#x3D;，解决了&#x3D;&#x3D;如何在连接各种计算机的传输媒体上传输数据比特流&#x3D;&#x3D;。该层中定义了&#x3D;&#x3D;为建立、维护和拆除物理链路所需的机械的、电气的、功能的和规程&#x3D;&#x3D;的特性，其作用是&#x3D;&#x3D;使原始的数据比特流能在物理媒体上传输。&#x3D;&#x3D;</p>
<p>物理层利用传输介质为通信的两端建立、管理和释放物理链接，实现比特流的透明传输，保证比特流正确的传输到对端。物理层中承载的是比特流,单位是比特（bit）。</p>
<hr>
<h2 id="网络物理层要解决的主要问题-干什么-："><a href="#网络物理层要解决的主要问题-干什么-：" class="headerlink" title="网络物理层要解决的主要问题(干什么)："></a>网络物理层要解决的主要问题(干什么)：</h2><hr>
<ol>
<li>物理层尽可能地屏蔽掉物理设备和传输媒体，通信手段的不同，使数据链路层感觉不到这些差异，只考虑完成本层的协议和服务。</li>
<li>给其服务用户(数据链路层)在一条物理的传输媒体上传送和接收比特流(一般为串行按顺序传输的比特流)的能力，为此，物理层应该解决物理连接的建立、维持和释放问题。 </li>
<li>在两个相邻系统之间唯一地标识数据电路。物理层主要功能:为数据端设备提供传送数据通路、传输数据。</li>
</ol>
<hr>
<h2 id="扮演的角色与功能-什么用"><a href="#扮演的角色与功能-什么用" class="headerlink" title="扮演的角色与功能(什么用)"></a>扮演的角色与功能(什么用)</h2><hr>
<p>物理层定义了通过连接网络节点的物理数据链路传输原始比特流的方式。<br>比特流可以被分组为码字或符号，并被转换为在传输介质上传输的物理信号。<br>物理层由网络的电子电路传输技术组成。它是网络中高级功能的基础层，可以通过具有广泛不同特性的大量不同硬件技术来实现。<br>在 OSI 模型的语义中，物理层将来自数据链路层的逻辑通信请求转换为特定于硬件的操作，以引起电子（或其他）信号的传输或接收。 物理层支持负责生成逻辑数据包的更高层。</p>
<p>物理层在物理传输介质上执行逐位或逐符号的数据传递。它为传输介质提供标准化接口，包括电气连接器和电缆的机械规格，例如最大电缆长度、传输线信号电平和阻抗的电气规格。物理层负责电磁兼容性，包括电磁频谱 信号强度、模拟带宽等的频率分配和规范。传输介质可以是电的或光纤上的光或无线通信链路，例如自由空间光通信或无线电。</p>
<p>线路编码用于将数据转换为可调制到载波或红外光上的电波动模式。数据流通过同步串行通信中的位同步或异步串行通信中的启停信号和流控制来管理。多个网络参与者之间传输介质的共享可以通过简单的电路交换或多路复用来处理。用于共享传输介质的更复杂的介质访问控制协议可以使用载波侦听和冲突检测，例如以太网的载波侦听多路访问和冲突检测(CSMA&#x2F;CD)。</p>
<p>为了优化可靠性和效率，可以使用信号处理技术，例如均衡、训练序列和脉冲整形。可以应用包括前向纠错的纠错码和技术来进一步提高可靠性。<br>物理层相关的其他主题包括：比特率；点对点、多点或点对多点线路配置；物理网络拓扑，例如总线、环形、网状或星形网络；串行或并行通信；单工、半双工或全双工传输模式；和自动协商</p>
<hr>
<h2 id="数据通信系统的模型："><a href="#数据通信系统的模型：" class="headerlink" title="数据通信系统的模型："></a>数据通信系统的模型：</h2><hr>
<ul>
<li>信道 —— 一般用来表示向某一个方向传送信息的媒体。</li>
<li></li>
<li>单向通信（单工通信）——只能有一个方向的通信而没有反方向的交互。</li>
<li></li>
<li>双向交替通信（半双工通信）——通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。</li>
<li></li>
<li>双向同时通信（全双工通信）——通信的双方可以同时发送和接收信息。</li>
</ul>
<hr>
<h2 id="传输媒体的接口的特性。"><a href="#传输媒体的接口的特性。" class="headerlink" title="传输媒体的接口的特性。"></a>传输媒体的接口的特性。</h2><hr>
<ul>
<li>机械特性 ：指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等。</li>
<li></li>
<li>电气特性：指明在接口电缆的各条线上出现的电压的范围。4V— 6V表示二进制“0”,用-4V—-6V表示二进制“1”</li>
<li></li>
<li>功能特性：指明某条线上出现的某一电平的电压表示何种意义。</li>
<li></li>
<li>过程特性 ：指明对于不同功能的各种可能事件的出现顺序。</li>
</ul>
<hr>
<h2 id="曼切斯特编码与差分曼切斯特编码"><a href="#曼切斯特编码与差分曼切斯特编码" class="headerlink" title="曼切斯特编码与差分曼切斯特编码"></a>曼切斯特编码与差分曼切斯特编码</h2><hr>
<p>首先，来自信源的信号常称基带信号。</p>
<p>基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。因此必须对基带信号进行调制</p>
<h2 id="调制又分为两大类：基带调制、带通调制"><a href="#调制又分为两大类：基带调制、带通调制" class="headerlink" title="调制又分为两大类：基带调制、带通调制"></a>调制又分为两大类：基带调制、带通调制</h2><h3 id="基带调制"><a href="#基带调制" class="headerlink" title="基带调制"></a>基带调制</h3><hr>
<p>基带调制：变换后的信号仍然是基带信号，调制的过程称为编码。常用编码方式:</p>
<p>不归零制：正电平代表 1，负电平代表 0。</p>
<p>归零制：正脉冲代表 1，负脉冲代表 0。</p>
<p>曼彻斯特编码：位周期中心的向上跳变代表 0，位周期中心的向下跳变代表 1。但也可反过来定义。</p>
<p>差分曼彻斯特编码：在每一位的中心处始终都有跳变。位开始边界有跳变代表 0，而位开始边界没有跳变代表 1。</p>
<hr>
<h3 id="带通调制"><a href="#带通调制" class="headerlink" title="带通调制"></a>带通调制</h3><hr>
<p>带通调制：把基带信号的频率范围搬移到较高的频段，并转换为模拟信号,调制的过程称之为载波。远距离</p>
<p>调幅(AM)：载波的振幅随基带数字信号而变化。</p>
<p>调频(FM)：载波的频率随基带数字信号而变化。</p>
<p>调相(PM) ：载波的初始相位随基带数字信号而变化。</p>
<hr>
<h2 id="信噪比与香农公式"><a href="#信噪比与香农公式" class="headerlink" title="信噪比与香农公式"></a>信噪比与香农公式</h2><h3 id="信噪比"><a href="#信噪比" class="headerlink" title="信噪比"></a>信噪比</h3><hr>
<p>任何实际的信道都不是理想的，在传输信号时会产生各种失真以及带来多种干扰。</p>
<p>码元传输的速率越高，或信号传输的距离越远，或传输媒体质量越差，在信道的输出端的波形的失真就越严重。</p>
<p>从概念上讲，限制码元在信道上的传输速率的因素有以下两个：</p>
<ul>
<li>信道能够通过的频率范围</li>
</ul>
<p>如果信道的频带越宽，也就是能够通过的信号高频分量越多，那么就可以用更高的速率传送码元而不出现码间串扰。</p>
<ul>
<li>信噪比</li>
</ul>
<p>噪声是随机产生的，它的瞬时值有时会很大。因此噪声会使接收端对码元的判决产生错误。但是如果信号相对较强，那么噪声的影响就相对较小。</p>
<p>所以，信噪比就是信号的平均功率和噪声的平均功率之比。</p>
<p>公式：</p>
<p>信噪比(dB) &#x3D; 10 log10(S&#x2F;N)(dB)</p>
<p>例子：当 S&#x2F;N &#x3D; 10 时，信噪比为 10 dB，而当 S&#x2F;N &#x3D; 1000时，信噪比为 30 dB。</p>
<hr>
<h3 id="香农公式"><a href="#香农公式" class="headerlink" title="香农公式"></a>香农公式</h3><hr>
<p>1984年，香农 (Shannon) 用信息论的理论推导出了带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率（香农公式）。</p>
<p>香农公式表明：</p>
<p>信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。</p>
<p>只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输。</p>
<p>若信道带宽 W 或信噪比 S&#x2F;N 没有上限（当然实际信道不可能是这样的），则信道的极限信息传输速率 C 也就没有上限。</p>
<p>实际信道上能够达到的信息传输速率要比香农的极限传输速率低不少。</p>
<p>对于频带宽度已确定的信道，如果信噪比不能再提高了，并且码元传输速率也达到了上限值，那么还有办法提高信息的传输速率。</p>
<p>&#x3D;&#x3D;用编码的方法让每一个码元携带更多比特的信息量。&#x3D;&#x3D;</p>
<hr>
<h3 id="常见的传输介质"><a href="#常见的传输介质" class="headerlink" title="常见的传输介质"></a>常见的传输介质</h3><hr>
<p>传输媒体也称为传输介质或传输媒介，可分为两大类，即导引型传输媒体和非导引型传输媒体</p>
<p>在导引型传输媒体中，电磁波被导引沿着固体媒体（铜线或光纤）传播。</p>
<p>非导引型传输媒体就是指自由空间。在非导引型传输媒体中，电磁波的传输常称为无线传输</p>
<hr>
<h3 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h3><h5 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h5><hr>
<p>我们常用的网线，模拟传输和数字传输都可以使用双绞线，其通信距离一般为几到十几公里</p>
<p>对传送数据来说，现在最常用的 UTP 是5类线（Category 5 或 CAT5）。</p>
<hr>
<h5 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h5><hr>
<p>同轴电缆具有很好的抗干扰特性，被广泛用于传输较高速率的数据。</p>
<p>同轴电缆的带宽取决于电缆的质量。</p>
<p>50欧姆 同轴电缆 —— LAN &#x2F; 数字传输常用</p>
<p>75欧姆 同轴电缆 —— 有线电视 &#x2F; 模拟传输常用</p>
<hr>
<h5 id="光缆"><a href="#光缆" class="headerlink" title="光缆"></a>光缆</h5><hr>
<p>光纤是光缆通信的传输媒体，由于可见光的频率非常高，约为 108 MHz 的量级，因此一个光纤通信系统的传输带宽远远大于目前其他各种传输媒体的带宽。</p>
<p>光纤优点：</p>
<p>(1) 通信容量非常大。</p>
<p>(2) 传输损耗小，中继距离长。</p>
<p>(2) 抗雷电和电磁干扰性能好。</p>
<p>(3) 无串音干扰，保密性好。</p>
<p>(4) 体积小，重量轻。</p>
<hr>
<h4 id="非导引型传输媒体"><a href="#非导引型传输媒体" class="headerlink" title="非导引型传输媒体"></a>非导引型传输媒体</h4><hr>
<p>短波通信（即高频通信）主要是靠电离层的反射，但短波信道的通信质量较差，传输速率低。</p>
<p>微波在空间主要是直线传播。</p>
<p>传统微波通信有两种方式：</p>
<p>地面微波接力通信</p>
<p>卫星通信</p>
<hr>
<h2 id="频分复用技术与时分复用技术"><a href="#频分复用技术与时分复用技术" class="headerlink" title="频分复用技术与时分复用技术"></a>频分复用技术与时分复用技术</h2><p>复用 (multiplexing) 是通信技术中的基本概念。它允许用户使用一个共享信道进行通信，降低成本，提高利用率。</p>
<h3 id="频分复用-FDM"><a href="#频分复用-FDM" class="headerlink" title="频分复用 FDM"></a>频分复用 FDM</h3><hr>
<p>将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</p>
<p>频分复用的所有用户在同样的时间占用不同的带宽资源（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。</p>
<hr>
<h3 id="时分复用TDM"><a href="#时分复用TDM" class="headerlink" title="时分复用TDM"></a>时分复用TDM</h3><hr>
<p>时分复用则是将时间划分为一段段等长的时分复用帧（TDM 帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。</p>
<p>每一个用户所占用的时隙是周期性地出现（其周期就是 TDM  帧的长度）。</p>
<p>时分复用的所有用户是在不同的时间占用同样的频带宽度。</p>
<p>时分复用的不足：用户对分配到的子信道的利用率一般是不高的。</p>
<hr>
<h2 id="常见的宽带接入技术"><a href="#常见的宽带接入技术" class="headerlink" title="常见的宽带接入技术"></a>常见的宽带接入技术</h2><hr>
<p>ADSL 技术    数字用户线</p>
<p>光纤同轴混合网（HFC网）</p>
<p>FTTH 技术  光纤到户 Fiber to the home</p>
<p>从宽带接入的媒体来看，可以划分为两大类：</p>
<p>有线宽带接入</p>
<p>无线宽带接入</p>
<hr>
<h3 id="ADSL-技术"><a href="#ADSL-技术" class="headerlink" title="ADSL 技术"></a>ADSL 技术</h3><hr>
<p>非对称数字用户线 ADSL (Asymmetric Digital Subscriber Line) 技术就是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务</p>
<p>ADSL 技术就把 0~4 kHz 低端频谱留给传统电话使用，而把原来没有被利用的高端频谱留给用户上网使用</p>
<p>ADSL 所能得到的最高数据传输速率与实际的用户线上的信噪比密切相关。</p>
<p>ADSL 的特点：</p>
<p>上行和下行带宽做成不对称的。</p>
<p>ADSL 在用户线（铜线）的两端各安装一个 ADSL 调制解调器。</p>
<p>我国目前采用的方案是离散多音调 DMT，DMT 调制技术采用频分复用的方法</p>
<p>ADSL 采用自适应调制技术使用户线能够传送尽可能高的数据率</p>
<hr>
<h3 id="光纤同轴混合网（HFC网）"><a href="#光纤同轴混合网（HFC网）" class="headerlink" title="光纤同轴混合网（HFC网）"></a>光纤同轴混合网（HFC网）</h3><hr>
<p>HFC (Hybrid Fiber Coax) 网是在目前覆盖面很广的有线电视网 CATV 的基础上开发的一种居民宽带接入网。</p>
<p>现有的 CATV 网是树形拓扑结构的同轴电缆网络，它采用模拟技术的频分复用对电视节目进行单向传输。</p>
<p>HFC 网对 CATV 网进行了改造。</p>
<p>HFC 网将原 CATV 网中的同轴电缆主干部分改换为光纤，并使用模拟光纤技术。</p>
<p>用户接口盒 UIB (User Interface Box) 要提供三种连接，即：</p>
<p>使用同轴电缆连接到机顶盒 (set-top box)，然后再连接到用户的电视机。</p>
<p>使用双绞线连接到用户的电话机。</p>
<p>使用电缆调制解调器连接到用户的计算机。</p>
<p>电缆调制解调器是为 HFC 网而使用的调制解调器。最大的特点就是传输速率高</p>
<hr>
<h3 id="FTTx-技术"><a href="#FTTx-技术" class="headerlink" title="FTTx 技术"></a>FTTx 技术</h3><hr>
<p>FTTx 表示 Fiber To The…（光纤到…），例如：</p>
<p>光纤到户 FTTH (Fiber To The Home)：光纤一直铺设到用户家庭，可能是居民接入网最后的解决方法。</p>
<p>光纤到大楼 FTTB (Fiber To The Building)：光纤进入大楼后就转换为电信号，然后用电缆或双绞线分配到各用户。</p>
<p>光纤到路边 FTTC (Fiber To The Curb)：光纤铺到路边，从路边到各用户可使用星形结构双绞线作为传输媒体。</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cachefish.github.io/2022/02/23/3-%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2229.jfif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="来世做春风，浪漫且自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cachecatのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/23/3-%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88/" class="post-title-link" itemprop="url">基础汇总</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-23 19:30:00" itemprop="dateCreated datePublished" datetime="2022-02-23T19:30:00+08:00">2022-02-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-03 09:19:58" itemprop="dateModified" datetime="2022-03-03T09:19:58+08:00">2022-03-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E7%BB%8F/" itemprop="url" rel="index"><span itemprop="name">面经</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-语言基础-C-x2F-C"><a href="#1-语言基础-C-x2F-C" class="headerlink" title="1. 语言基础 (C&#x2F;C++)"></a>1. 语言基础 (C&#x2F;C++)</h1><h4 id="（0）-指针和引用的区别"><a href="#（0）-指针和引用的区别" class="headerlink" title="（0） 指针和引用的区别"></a>（0） 指针和引用的区别</h4><ul>
<li>指针是一个新的变量，指向另一个变量的地址，我们可以通过访问这个地址来修改另一个变量；而引用是一个别名，对引用的操作就是对变量的本身进行操作</li>
<li>指针可以有多级，引用只有一级</li>
<li>传参的时候，使用指针的话需要解引用才能对参数进行修改，而使用引用可以直接对参数进行修改</li>
<li>指针的大小一般是4个字节，引用的大小取决于被引用对象的大小</li>
<li>指针可以为空，引用不可以。</li>
</ul>
<h4 id="（1）在函数参数传递的时候，什么时候使用指针，什么时候使用引用？"><a href="#（1）在函数参数传递的时候，什么时候使用指针，什么时候使用引用？" class="headerlink" title="（1）在函数参数传递的时候，什么时候使用指针，什么时候使用引用？"></a>（1）在函数参数传递的时候，什么时候使用指针，什么时候使用引用？</h4><ul>
<li>需要返回函数内局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的</li>
<li>对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小</li>
<li>类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式<h4 id="（2）-堆和栈有什么区别"><a href="#（2）-堆和栈有什么区别" class="headerlink" title="（2） 堆和栈有什么区别"></a>（2） 堆和栈有什么区别</h4></li>
<li>从定义上：堆是由new和malloc开辟的一块内存，由程序员手动管理，栈是编译器自动管理的内存，存放函数的参数和局部变量。</li>
<li>堆空间因为会有频繁的分配释放操作，会产生内存碎片</li>
<li>堆的生长空间向上，地址越来越大，栈的生长空间向下，地址越来越小<h4 id="（3）堆快一点还是栈快一点？（字节提前批一面）"><a href="#（3）堆快一点还是栈快一点？（字节提前批一面）" class="headerlink" title="（3）堆快一点还是栈快一点？（字节提前批一面）"></a>（3）堆快一点还是栈快一点？（字节提前批一面）</h4>栈快一点。因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。而堆的操作是由C&#x2F;C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。<h4 id="（4）-new和delete是如何实现的，new-与-malloc的异同处"><a href="#（4）-new和delete是如何实现的，new-与-malloc的异同处" class="headerlink" title="（4） new和delete是如何实现的，new 与 malloc的异同处"></a>（4） new和delete是如何实现的，new 与 malloc的异同处</h4>在new一个对象的时候，首先会调用malloc为对象分配内存空间，然后调用对象的构造函数。delete会调用对象的析构函数，然后调用free回收内存。</li>
</ul>
<p>new与malloc都会分配空间，但是new还会调用对象的构造函数进行初始化，malloc需要给定空间大小，而new只需要对象名</p>
<h4 id="（5）既然有了malloc-x2F-free，C-中为什么还需要new-x2F-delete呢？"><a href="#（5）既然有了malloc-x2F-free，C-中为什么还需要new-x2F-delete呢？" class="headerlink" title="（5）既然有了malloc&#x2F;free，C++中为什么还需要new&#x2F;delete呢？"></a>（5）既然有了malloc&#x2F;free，C++中为什么还需要new&#x2F;delete呢？</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/leikun153/article/details/80612130">https://blog.csdn.net/leikun153/article/details/80612130</a></p>
<ul>
<li><p>malloc&#x2F;free和new&#x2F;delete都是用来申请内存和回收内存的。</p>
</li>
<li><p>在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而malloc&#x2F;free是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给malloc&#x2F;free。</p>
<h4 id="（6）-C和C-的区别"><a href="#（6）-C和C-的区别" class="headerlink" title="（6） C和C++的区别"></a>（6） C和C++的区别</h4><p>包括但不限于：</p>
</li>
<li><p>C是面向过程的语言，C++是面向对象的语言，C++有“封装，继承和多态”的特性。封装隐藏了实现细节，使得代码模块化。继承通过子类继承父类的方法和属性，实现了代码重用。多态则是“一个接口，多个实现”，通过子类重写父类的虚函数，实现了接口重用。</p>
</li>
<li><p>C和C++内存管理的方法不一样，C使用malloc&#x2F;free，C++除此之外还用new&#x2F;delete</p>
</li>
<li><p>C++中还有函数重载和引用等概念，C中没有</p>
<h4 id="（7）delete和delete-的区别"><a href="#（7）delete和delete-的区别" class="headerlink" title="（7）delete和delete[]的区别"></a>（7）delete和delete[]的区别</h4></li>
<li><p>delete只会调用一次析构函数，而delete[]会调用每个成员的析构函数</p>
</li>
<li><p>用new分配的内存用delete释放，用new[]分配的内存用delete[]释放</p>
</li>
</ul>
<h4 id="（8）-C-、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）"><a href="#（8）-C-、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）" class="headerlink" title="（8） C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）"></a>（8） C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）</h4><p>包括但不限于：</p>
<ul>
<li>C++ 和Java都是面向对象的语言，C++是编译成可执行文件直接运行的，JAVA是编译之后在JAVA虚拟机上运行的，因此JAVA有良好的跨平台特性，但是执行效率没有C++ 高。</li>
<li>C++的内存管理由程序员手动管理，JAVA的内存管理是由Java虚拟机完成的，它的垃圾回收使用的是标记-回收算法</li>
<li>C++有指针，Java没有指针，只有引用</li>
<li>JAVA和C++都有构造函数，但是C++有析构函数但是Java没有<h4 id="（9）C-和python的区别"><a href="#（9）C-和python的区别" class="headerlink" title="（9）C++和python的区别"></a>（9）C++和python的区别</h4>包括但不限于：</li>
</ul>
<ol>
<li>python是一种脚本语言，是解释执行的，而C++是编译语言，是需要编译后在特定平台运行的。python可以很方便的跨平台，但是效率没有C++高。</li>
<li>python使用缩进来区分不同的代码块，C++使用花括号来区分</li>
<li>C++中需要事先定义变量的类型，而python不需要，python的基本数据类型只有数字，布尔值，字符串，列表，元组等等</li>
<li>python的库函数比C++的多，调用起来很方便<h4 id="（10）-Struct和class的区别"><a href="#（10）-Struct和class的区别" class="headerlink" title="（10） Struct和class的区别"></a>（10） Struct和class的区别</h4></li>
</ol>
<ul>
<li><p>使用struct时，它的成员的访问权限默认是public的，而class的成员默认是private的</p>
</li>
<li><p>struct的继承默认是public继承，而class的继承默认是private继承</p>
</li>
<li><p>class可以用作模板，而struct不能</p>
<h4 id="（11）-define-和const的联系与区别（编译阶段、安全性、内存占用等）"><a href="#（11）-define-和const的联系与区别（编译阶段、安全性、内存占用等）" class="headerlink" title="（11） define 和const的联系与区别（编译阶段、安全性、内存占用等）"></a>（11） define 和const的联系与区别（编译阶段、安全性、内存占用等）</h4><p>联系：它们都是定义常量的一种方法。</p>
<p>区别：</p>
</li>
<li><p>define定义的常量没有类型，只是进行了简单的替换，可能会有多个拷贝，占用的内存空间大，const定义的常量是有类型的，存放在静态存储区，只有一个拷贝，占用的内存空间小。</p>
</li>
<li><p>define定义的常量是在预处理阶段进行替换，而const在编译阶段确定它的值。</p>
</li>
<li><p>define不会进行类型安全检查，而const会进行类型安全检查，安全性更高。</p>
</li>
<li><p>const可以定义函数而define不可以。</p>
<h4 id="（12）-在C-中const的用法（定义，用途）"><a href="#（12）-在C-中const的用法（定义，用途）" class="headerlink" title="（12） 在C++中const的用法（定义，用途）"></a>（12） 在C++中const的用法（定义，用途）</h4></li>
<li><p>const修饰类的成员变量时，表示常量不能被修改</p>
</li>
<li><p>const修饰类的成员函数，表示该函数不会修改类中的数据成员，不会调用其他非const的成员函数</p>
</li>
</ul>
<h4 id="（13）-C-中的static用法和意义"><a href="#（13）-C-中的static用法和意义" class="headerlink" title="（13） C++中的static用法和意义"></a>（13） C++中的static用法和意义</h4><p>static的意思是静态的，可以用来修饰变量，函数和类成员。</p>
<ul>
<li><p>变量：被static修饰的变量就是静态变量，它会在程序运行过程中一直存在，会被放在静态存储区。局部静态变量的作用域在函数体中，全局静态变量的作用域在这个文件里。</p>
</li>
<li><p>函数：被static修饰的函数就是静态函数，静态函数只能在本文件中使用，不能被其他文件调用，也不会和其他文件中的同名函数冲突。</p>
</li>
<li><p>类：而在类中，被static修饰的成员变量是类静态成员，这个静态成员会被类的多个对象共用。被static修饰的成员函数也属于静态成员，不是属于某个对象的，访问这个静态函数不需要引用对象名，而是通过引用类名来访问。</p>
</li>
</ul>
<p>【note】静态成员函数要访问非静态成员时，要用过对象来引用。局部静态变量在函数调用结束后也不会被回收，会一直在程序内存中，直到该函数再次被调用，它的值还是保持上一次调用结束后的值。</p>
<p>注意和const的区别。const强调值不能被修改，而static强调唯一的拷贝，对所有类的对象都共用。</p>
<h4 id="（14）-计算下面几个类的大小："><a href="#（14）-计算下面几个类的大小：" class="headerlink" title="（14） 计算下面几个类的大小："></a>（14） 计算下面几个类的大小：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(A)&lt;&lt;endl;<span class="comment">// 输出 1;</span></span><br><span class="line">  A a; </span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(a)&lt;&lt;endl;<span class="comment">// 输出 1;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>空类的大小是1， 在C++中空类会占一个字节，这是为了让对象的实例能够相互区别。具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个字节，这样空类实例化之后就会拥有独一无二的内存地址。当该空白类作为基类时，该类的大小就优化为0了，子类的大小就是子类本身的大小。这就是所谓的空白基类最优化。</p>
<p>空类的实例大小就是类的大小，所以sizeof(a)&#x3D;1字节,如果a是指针，则sizeof(a)就是指针的大小，即4字节。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="function"><span class="keyword">virtual</span> <span class="title">Fun</span><span class="params">()</span></span>&#123;&#125; &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(A)&lt;&lt;endl;<span class="comment">// 输出 4(32位机器)/8(64位机器);</span></span><br><span class="line">  A a; </span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(a)&lt;&lt;endl;<span class="comment">// 输出 4(32位机器)/8(64位机器);</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为有虚函数的类对象中都有一个虚函数表指针 __vptr，其大小是4字节<br></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="type">static</span> <span class="type">int</span> a; &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(A)&lt;&lt;endl;<span class="comment">// 输出 1;</span></span><br><span class="line">  A a; </span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(a)&lt;&lt;endl;<span class="comment">// 输出 1;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态成员存放在静态存储区，不占用类的大小, 普通函数也不占用类大小</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="type">int</span> a; &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(A)&lt;&lt;endl;<span class="comment">// 输出 4;</span></span><br><span class="line">  A a; </span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(a)&lt;&lt;endl;<span class="comment">// 输出 4;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="type">static</span> <span class="type">int</span> a; <span class="type">int</span> b; &#125;;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(A)&lt;&lt;endl;<span class="comment">// 输出 4;</span></span><br><span class="line">  A a; </span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(a)&lt;&lt;endl;<span class="comment">// 输出 4;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态成员a不占用类的大小，所以类的大小就是b变量的大小 即4个字节</p>
<h4 id="（15）-C-的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等"><a href="#（15）-C-的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等" class="headerlink" title="（15） C++的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等"></a>（15） C++的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等</h4><p>C++ STL从广义来讲包括了三类：算法，容器和迭代器。</p>
<ul>
<li>算法包括排序，复制等常用算法，以及不同容器特定的算法。</li>
<li>容器就是数据的存放形式，包括序列式容器和关联式容器，序列式容器就是list，vector等，关联式容器就是set，map等。</li>
<li>迭代器就是在不暴露容器内部结构的情况下对容器的遍历。<h4 id="（16）-STL源码中的hash表的实现"><a href="#（16）-STL源码中的hash表的实现" class="headerlink" title="（16） STL源码中的hash表的实现"></a>（16） STL源码中的hash表的实现</h4>STL中的hash表就unordered_map。使用的是哈希进行实现（注意与map的区别）。它记录的键是元素的哈希值，通过对比元素的哈希值来确定元素的值。</li>
</ul>
<p>unordered_map的底层实现是hashtable，采用开链法（也就是用桶）来解决哈希冲突，当桶的大小超过8时，就自动转为红黑树进行组织。</p>
<h4 id="（17）解决哈希冲突的方式？"><a href="#（17）解决哈希冲突的方式？" class="headerlink" title="（17）解决哈希冲突的方式？"></a>（17）解决哈希冲突的方式？</h4><ol>
<li>线性探查。该元素的哈希值对应的桶不能存放元素时，循序往后一一查找，直到找到一个空桶为止，在查找时也一样，当哈希值对应位置上的元素与所要寻找的元素不同时，就往后一一查找，直到找到吻合的元素，或者空桶。</li>
<li>二次探查。该元素的哈希值对应的桶不能存放元素时，就往后寻找1^2,2^2,3^2,4^2…..i^2个位置。</li>
<li>双散列函数法。当第一个散列函数发生冲突的时候，使用第二个散列函数进行哈希，作为步长。</li>
<li>开链法。在每一个桶中维护一个链表，由元素哈希值寻找到这个桶，然后将元素插入到对应的链表中，STL的hashtable就是采用这种实现方式。</li>
<li>建立公共溢出区。当发生冲突时，将所有冲突的数据放在公共溢出区。<h4 id="（18）-STL中unordered-map和map的区别"><a href="#（18）-STL中unordered-map和map的区别" class="headerlink" title="（18） STL中unordered_map和map的区别"></a>（18） STL中unordered_map和map的区别</h4></li>
</ol>
<ul>
<li>unordered_map是使用哈希实现的，占用内存比较多，查询速度比较快，是常数时间复杂度。它内部是无序的，需要实现&#x3D;&#x3D;操作符。</li>
<li>map底层是采用红黑树实现的，插入删除查询时间复杂度都是O(log(n))，它的内部是有序的，因此需要实现比较操作符(&lt;)。<h4 id="（19）-STL中vector的实现"><a href="#（19）-STL中vector的实现" class="headerlink" title="（19） STL中vector的实现"></a>（19） STL中vector的实现</h4>STL中的vector是封装了动态数组的顺序容器。不过与动态数组不同的是，vector可以根据需要自动扩大容器的大小。具体策略是每次容量不够用时重新申请一块大小为原来容量两倍的内存，将原容器的元素拷贝至新容器，并释放原空间，返回新空间的指针。</li>
</ul>
<p>在原来空间不够存储新值时，每次调用push_back方法都会重新分配新的空间以满足新数据的添加操作。如果在程序中频繁进行这种操作，还是比较消耗性能的。</p>
<h4 id="（20）-vector使用的注意点及其原因，频繁对vector调用push-back-对性能的影响和原因。"><a href="#（20）-vector使用的注意点及其原因，频繁对vector调用push-back-对性能的影响和原因。" class="headerlink" title="（20） vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。"></a>（20） vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。</h4><p>如果需要频繁插入，最好先指定vector的大小，因为vector在容器大小不够用的时候会重新申请一块大小为原容器两倍的空间，并将原容器的元素拷贝到新容器中，并释放原空间，这个过程是十分耗时和耗内存的。频繁调用push_back()会使得程序花费很多时间在vector扩容上，会变得很慢。这种情况可以考虑使用list。</p>
<h4 id="（21）C-中vector和list的区别"><a href="#（21）C-中vector和list的区别" class="headerlink" title="（21）C++中vector和list的区别"></a>（21）C++中vector和list的区别</h4><p>vector和数组类似，拥有一段连续的内存空间。vector申请的是一段连续的内存，当插入新的元素内存不够时，通常以2倍重新申请更大的一块内存，将原来的元素拷贝过去，释放旧空间。因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。</p>
<p>list是由双向链表实现的，因此内存空间是不连续的。只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n); 但由于链表的特点，能高效地进行插入和删除。</p>
<p>vector拥有一段连续的内存空间，能很好的支持随机存取，因此vector::iterator支持“+”，“+&#x3D;”，“&lt;”等操作符。</p>
<p>list的内存空间可以是不连续，它不支持随机访问，因此list::iterator则不支持“+”、“+&#x3D;”、“&lt;”等</p>
<p>vector::iterator和list::iterator都重载了“++”运算符。</p>
<p>总之，如果需要高效的随机存取，而不在乎插入和删除的效率，使用vector;</p>
<p>如果需要大量的插入和删除，而不关心随机存取，则应使用list。</p>
<h4 id="（22）-C-中的重载和重写的区别："><a href="#（22）-C-中的重载和重写的区别：" class="headerlink" title="（22） C++中的重载和重写的区别："></a>（22） C++中的重载和重写的区别：</h4><ul>
<li>重载（overload）是指函数名相同，参数列表不同的函数实现方法。它们的返回值可以不同，但返回值不可以作为区分不同重载函数的标志。</li>
<li>重写（overwide）是指函数名相同，参数列表相同，只有方法体不相同的实现方法。一般用于子类继承父类时对父类方法的重写。子类的同名方法屏蔽了父类方法的现象称为隐藏。</li>
</ul>
<p>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_30379911/article/details/99497160">https://blog.csdn.net/weixin_30379911/article/details/99497160</a></p>
<h4 id="（23）-C-内存管理（热门问题）"><a href="#（23）-C-内存管理（热门问题）" class="headerlink" title="（23） C ++内存管理（热门问题）"></a>（23） C ++内存管理（热门问题）</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43152052/article/details/98889139">https://blog.csdn.net/qq_43152052/article/details/98889139</a></p>
<p>在C++中，内存分成5个区，他们分别是堆、栈、全局&#x2F;静态存储区和常量存储区和代码区。</p>
<ul>
<li>栈，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</li>
<li>堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。</li>
<li>全局&#x2F;静态存储区，内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据（局部static变量，全局static变量）、全局变量和常量。</li>
<li>常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量字符串，不允许修改。</li>
<li>代码区，存放程序的二进制代码</li>
</ul>
<p>关于这个有很多种说法，有的会增加一个自由存储区，存放malloc分配得到的内存，与堆相似。</p>
<h4 id="（24）-介绍面向对象的三大特性，并且举例说明每一个。"><a href="#（24）-介绍面向对象的三大特性，并且举例说明每一个。" class="headerlink" title="（24） 介绍面向对象的三大特性，并且举例说明每一个。"></a>（24） 介绍面向对象的三大特性，并且举例说明每一个。</h4><p>面向对象的三大特性是：封装，继承和多态。</p>
<ul>
<li><p>封装隐藏了类的实现细节和成员数据，实现了代码模块化，如类里面的private和public；</p>
</li>
<li><p>继承使得子类可以复用父类的成员和方法，实现了代码重用；</p>
</li>
<li><p>多态则是“一个接口，多个实现”，通过父类调用子类的成员，实现了接口重用，如父类的指针指向子类的对象。</p>
<h4 id="（25）-多态的实现（和下个问题一起回答）"><a href="#（25）-多态的实现（和下个问题一起回答）" class="headerlink" title="（25） 多态的实现（和下个问题一起回答）"></a>（25） 多态的实现（和下个问题一起回答）</h4><p>C++ 多态包括编译时多态和运行时多态，编译时多态体现在函数重载和模板上，运行时多态体现在虚函数上。</p>
</li>
<li><p>虚函数：在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数.</p>
<h4 id="（26）-C-虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）"><a href="#（26）-C-虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）" class="headerlink" title="（26） C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）"></a>（26） C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）</h4><p>C++的虚函数是实现多态的机制。它是通过虚函数表实现的，虚函数表是每个类中存放虚函数地址的指针数组，类的实例在调用函数时会在虚函数表中寻找函数地址进行调用，如果子类覆盖了父类的函数，则子类的虚函数表会指向子类实现的函数地址，否则指向父类的函数地址。一个类的所有实例都共享同一张虚函数表。</p>
</li>
</ul>
<p>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/lihao21/article/details/50688337">C++虚函数表剖析</a></p>
<ul>
<li>如果多重继承和多继承的话，子类的虚函数表长什么样子？<br>多重继承的情况下越是祖先的父类的虚函数更靠前，多继承的情况下越是靠近子类名称的类的虚函数在虚函数表中更靠前。详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36359022/article/details/81870219">https://blog.csdn.net/qq_36359022/article/details/81870219</a></li>
</ul>
<h4 id="（27）-实现编译器处理虚函数表应该如何处理"><a href="#（27）-实现编译器处理虚函数表应该如何处理" class="headerlink" title="（27） 实现编译器处理虚函数表应该如何处理"></a>（27） 实现编译器处理虚函数表应该如何处理</h4><p>编译器处理虚函数的方法是：<br>如果类中有虚函数，就将虚函数的地址记录在类的虚函数表中。派生类在继承基类的时候，如果有重写基类的虚函数，就将虚函数表中相应的函数指针设置为派生类的函数地址，否则指向基类的函数地址。<br>为每个类的实例添加一个虚表指针（vptr），虚表指针指向类的虚函数表。实例在调用虚函数的时候，通过这个虚函数表指针找到类中的虚函数表，找到相应的函数进行调用。<br>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/iFuMI/article/details/51088091">虚函数的作用及其底层实现机制</a></p>
<h4 id="（28）-基类的析构函数一般写成虚函数的原因"><a href="#（28）-基类的析构函数一般写成虚函数的原因" class="headerlink" title="（28） 基类的析构函数一般写成虚函数的原因"></a>（28） 基类的析构函数一般写成虚函数的原因</h4><p>首先析构函数可以为虚函数，当析构一个指向子类的父类指针时，编译器可以根据虚函数表寻找到子类的析构函数进行调用，从而正确释放子类对象的资源。</p>
<p>如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除指向子类的父类指针时，只会调用父类的析构函数而不调用子类析构函数，这样就会造成子类对象析构不完全造成内存泄漏。</p>
<h4 id="（29）-构造函数为什么一般不定义为虚函数"><a href="#（29）-构造函数为什么一般不定义为虚函数" class="headerlink" title="（29） 构造函数为什么一般不定义为虚函数"></a>（29） 构造函数为什么一般不定义为虚函数</h4><p>1）因为创建一个对象时需要确定对象的类型，而虚函数是在运行时确定其类型的。而在构造一个对象时，<strong>由于对象还未创建成功，编译器无法知道对象的实际类型</strong>，是类本身还是类的派生类等等</p>
<p>2）虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数即构造函数了</p>
<h4 id="（30）-构造函数或者析构函数中调用虚函数会怎样"><a href="#（30）-构造函数或者析构函数中调用虚函数会怎样" class="headerlink" title="（30） 构造函数或者析构函数中调用虚函数会怎样"></a>（30） 构造函数或者析构函数中调用虚函数会怎样</h4><p>在构造函数中调用虚函数，由于当前对象还没有构造完成，此时调用的虚函数指向的是基类的函数实现方式。</p>
<p>在析构函数中调用虚函数，此时调用的是子类的函数实现方式。</p>
<h4 id="（31）-纯虚函数"><a href="#（31）-纯虚函数" class="headerlink" title="（31） 纯虚函数"></a>（31） 纯虚函数</h4><p>纯虚函数是只有声明没有实现的虚函数，是对子类的约束，是接口继承</p>
<p>包含纯虚函数的类是抽象类，它不能被实例化，只有实现了这个纯虚函数的子类才能生成对象</p>
<p>使用场景：当这个类本身产生一个实例没有意义的情况下，把这个类的函数实现为纯虚函数，比如动物可以派生出老虎兔子，但是实例化一个动物对象就没有意义。并且可以规定派生的子类必须重写某些函数的情况下可以写成纯虚函数。</p>
<h4 id="（32）-静态绑定和动态绑定的介绍"><a href="#（32）-静态绑定和动态绑定的介绍" class="headerlink" title="（32） 静态绑定和动态绑定的介绍"></a>（32） 静态绑定和动态绑定的介绍</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lizhenghn/p/3657717.html">C++中的静态绑定和动态绑定</a></p>
<p>静态绑定也就是将该对象相关的属性或函数绑定为它的静态类型，也就是它在声明的类型，在编译的时候就确定。在调用的时候编译器会寻找它声明的类型进行访问。</p>
<p>动态绑定就是将该对象相关的属性或函数绑定为它的动态类型，具体的属性或函数在运行期确定，通常通过虚函数实现动态绑定。</p>
<h4 id="（33）-深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）"><a href="#（33）-深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）" class="headerlink" title="（33） 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）"></a>（33） 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）</h4><p>浅拷贝就是将对象的指针进行简单的复制，原对象和副本指向的是相同的资源。</p>
<p>而深拷贝是新开辟一块空间，将原对象的资源复制到新的空间中，并返回该空间的地址。</p>
<p>深拷贝可以避免重复释放和写冲突。例如使用浅拷贝的对象进行释放后，对原对象的释放会导致内存泄漏或程序崩溃。</p>
<h4 id="（34）-对象复用的了解，零拷贝的了解"><a href="#（34）-对象复用的了解，零拷贝的了解" class="headerlink" title="（34） 对象复用的了解，零拷贝的了解"></a>（34） 对象复用的了解，零拷贝的了解</h4><p>对象复用指得是设计模式，对象可以采用不同的设计模式达到复用的目的，最常见的就是继承和组合模式了。</p>
<p>零拷贝指的是在进行操作时，避免CPU从一处存储拷贝到另一处存储。在Linux中，我们可以减少数据在内核空间和用户空间的来回拷贝实现，比如通过调用mmap()来代替read调用。</p>
<blockquote>
<p>用程序调用mmap()，磁盘上的数据会通过DMA被拷贝的内核缓冲区，接着操作系统会把这段内核缓冲区与应用程序共享，这样就不需要把内核缓冲区的内容往用户空间拷贝。应用程序再调用write(),操作系统直接将内核缓冲区的内容拷贝到socket缓冲区中，这一切都发生在内核态，最后，socket缓冲区再把数据发到网卡去。</p>
</blockquote>
<h4 id="（35）-介绍C-所有的构造函数"><a href="#（35）-介绍C-所有的构造函数" class="headerlink" title="（35） 介绍C++所有的构造函数"></a>（35） 介绍C++所有的构造函数</h4><p>C++中的构造函数主要有三种类型：默认构造函数、重载构造函数和拷贝构造函数</p>
<ul>
<li>默认构造函数是当类没有实现自己的构造函数时，编译器默认提供的一个构造函数。</li>
<li>重载构造函数也称为一般构造函数，一个类可以有多个重载构造函数，但是需要参数类型或个数不相同。可以在重载构造函数中自定义类的初始化方式。</li>
<li>拷贝构造函数是在发生对象复制的时候调用的。 <h4 id="（36）-什么情况下会调用拷贝构造函数（三种情况）"><a href="#（36）-什么情况下会调用拷贝构造函数（三种情况）" class="headerlink" title="（36） 什么情况下会调用拷贝构造函数（三种情况）"></a>（36） 什么情况下会调用拷贝构造函数（三种情况）</h4></li>
<li>对象以值传递的方式传入函数参数 <blockquote>
<p>如 <code> void func(Dog dog)&#123;&#125;;</code></p>
</blockquote>
</li>
<li>对象以值传递的方式从函数返回<blockquote>
<p>如 <code> Dog func()&#123; Dog d; return d;&#125;</code></p>
</blockquote>
</li>
<li>对象需要通过另外一个对象进行初始化</li>
</ul>
<p>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/lwbeyond/article/details/6202256">C++拷贝构造函数详解</a></p>
<h4 id="（37）-结构体内存对齐方式和为什么要进行内存对齐？"><a href="#（37）-结构体内存对齐方式和为什么要进行内存对齐？" class="headerlink" title="（37） 结构体内存对齐方式和为什么要进行内存对齐？"></a>（37） 结构体内存对齐方式和为什么要进行内存对齐？</h4><p>因为结构体的成员可以有不同的数据类型，所占的大小也不一样。同时，由于CPU读取数据是按块读取的，内存对齐可以使得CPU一次就可以将所需的数据读进来。</p>
<p>对齐规则：</p>
<ul>
<li>第一个成员在与结构体变量偏移量为0的地址</li>
<li>其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。</li>
<li>对齐数&#x3D;编译器默认的一个对齐数 与 该成员大小的较小值。</li>
<li>linux 中默认为4</li>
<li>vs 中的默认值为8<br>结构体总大小为最大对齐数的整数倍（每个成员变量除了第一个成员都有一个对齐数）</li>
</ul>
<h4 id="（38）-内存泄露的定义，如何检测与避免？"><a href="#（38）-内存泄露的定义，如何检测与避免？" class="headerlink" title="（38） 内存泄露的定义，如何检测与避免？"></a>（38） 内存泄露的定义，如何检测与避免？</h4><p>动态分配内存所开辟的空间，在使用完毕后未手动释放，导致一直占据该内存，即为内存泄漏。</p>
<p>造成内存泄漏的几种原因：</p>
<p>1）类的构造函数和析构函数中new和delete没有配套</p>
<p>2）在释放对象数组时没有使用delete[]，使用了delete</p>
<p>3）没有将基类的析构函数定义为虚函数，当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确释放，因此造成内存泄露</p>
<p>4）没有正确的清楚嵌套的对象指针</p>
<p>避免方法：</p>
<ol>
<li>malloc&#x2F;free要配套</li>
<li>使用智能指针；</li>
<li>将基类的析构函数设为虚函数；<h4 id="（39）-C-的智能指针有哪些"><a href="#（39）-C-的智能指针有哪些" class="headerlink" title="（39） C++的智能指针有哪些"></a>（39） C++的智能指针有哪些</h4>C++中的智能指针有auto_ptr,shared_ptr,weak_ptr和unique_ptr。智能指针其实是将指针进行了封装，可以像普通指针一样进行使用，同时可以自行进行释放，避免忘记释放指针指向的内存地址造成内存泄漏。</li>
</ol>
<ul>
<li><p>auto_ptr是较早版本的智能指针，在进行指针拷贝和赋值的时候，新指针直接接管旧指针的资源并且将旧指针指向空，但是这种方式在需要访问旧指针的时候，就会出现问题。</p>
</li>
<li><p>unique_ptr是auto_ptr的一个改良版，不能赋值也不能拷贝，保证一个对象同一时间只有一个智能指针。</p>
</li>
<li><p>shared_ptr可以使得一个对象可以有多个智能指针，当这个对象所有的智能指针被销毁时就会自动进行回收。（内部使用计数机制进行维护）</p>
</li>
<li><p>weak_ptr是为了协助shared_ptr而出现的。它不能访问对象，只能观测shared_ptr的引用计数，防止出现死锁。</p>
<h4 id="（40）-调试程序的方法"><a href="#（40）-调试程序的方法" class="headerlink" title="（40） 调试程序的方法"></a>（40） 调试程序的方法</h4></li>
<li><p>通过设置断点进行调试</p>
</li>
<li><p>打印log进行调试</p>
</li>
<li><p>打印中间结果进行调试</p>
<h4 id="（41）-遇到coredump要怎么调试"><a href="#（41）-遇到coredump要怎么调试" class="headerlink" title="（41） 遇到coredump要怎么调试"></a>（41） 遇到coredump要怎么调试</h4><p>coredump是程序由于异常或者bug在运行时异常退出或者终止，在一定的条件下生成的一个叫做core的文件，这个core文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。</p>
</li>
<li><p>使用gdb命令对core文件进行调试</p>
</li>
</ul>
<p>以下例子在Linux上编写一段代码并导致segment fault 并产生core文件</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> coredumpTest</span><br><span class="line"><span class="keyword">vim</span> coredumpTest.cpp</span><br></pre></td></tr></table></figure>
<p>在编辑器内键入</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,i);<span class="comment">//正确的应该是&amp;i,这里使用i会导致segment fault</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">g</span>++ <span class="comment">coredumpTest</span><span class="string">.</span><span class="comment">cpp</span> <span class="literal">-</span><span class="comment">g</span> <span class="literal">-</span><span class="comment">o</span> <span class="comment">coredumpTest</span></span><br></pre></td></tr></table></figure>
<p>运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./coredumpTest</span><br></pre></td></tr></table></figure>
<p>使用gdb调试coredump</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb <span class="selector-attr">[可执行文件名]</span> <span class="selector-attr">[core文件名]</span></span><br></pre></td></tr></table></figure>

<h4 id="（42）-inline关键字说一下-和宏定义有什么区别"><a href="#（42）-inline关键字说一下-和宏定义有什么区别" class="headerlink" title="（42） inline关键字说一下 和宏定义有什么区别"></a>（42） inline关键字说一下 和宏定义有什么区别</h4><p>inline是内联的意思，可以定义比较小的函数。因为函数频繁调用会占用很多的栈空间，进行入栈出栈操作也耗费计算资源，所以可以用inline关键字修饰频繁调用的小函数。编译器会在编译阶段将代码体嵌入内联函数的调用语句块中。</p>
<p>1、内联函数在编译时展开，而宏在预编译时展开</p>
<p>2、在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。</p>
<p>3、内联函数可以进行诸如类型安全检查、语句是否正确等编译功能，宏不具有这样的功能。</p>
<p>4、宏不是函数，而inline是函数</p>
<p>5、宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性。而内联函数不会出现二义性。</p>
<p>6、inline可以不展开，宏一定要展开。因为inline指示对编译器来说，只是一个建议，编译器可以选择忽略该建议，不对该函数进行展开。</p>
<p>7、宏定义在形式上类似于一个函数，但在使用它时，仅仅只是做预处理器符号表中的简单替换，因此它不能进行参数有效性的检测，也就不能享受C++编译器严格类型检查的好处，另外它的返回值也不能被强制转换为可转换的合适的类型，这样，它的使用就存在着一系列的隐患和局限性。</p>
<h4 id="（43）-模板的用法与适用场景-实现原理"><a href="#（43）-模板的用法与适用场景-实现原理" class="headerlink" title="（43） 模板的用法与适用场景 实现原理"></a>（43） 模板的用法与适用场景 实现原理</h4><p>用template &lt;typename T&gt;关键字进行声明，接下来就可以进行模板函数和模板类的编写了</p>
<p>编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，这次编译只会进行一个语法检查，并不会生成具体的代码。在运行时对代码进行参数替换后再进行编译，生成具体的函数代码。</p>
<h4 id="（44）-成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？"><a href="#（44）-成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？" class="headerlink" title="（44） 成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？"></a>（44） 成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？</h4><p>成员初始化列表就是在类或者结构体的构造函数中，在参数列表后以冒号开头，逗号进行分隔的一系列初始化字段。如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A&#123;</span><br><span class="line"><span class="built_in">int</span> id;</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line">FaceImage face;</span><br><span class="line"><span class="constructor">A(<span class="params">int</span>&amp; <span class="params">inputID</span>,<span class="params">string</span>&amp; <span class="params">inputName</span>,FaceImage&amp; <span class="params">inputFace</span>)</span>:id(inputID),name(inputName),face(inputFace)&#123;&#125; <span class="comment">// 成员初始化列表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为使用成员初始化列表进行初始化的话，会直接使用传入参数的拷贝构造函数进行初始化，省去了一次执行传入参数的默认构造函数的过程，否则会调用一次传入参数的默认构造函数。所以使用成员初始化列表效率会高一些。<br><br>另外，有三种情况是必须使用成员初始化列表进行初始化的：</p>
<ul>
<li>常量成员的初始化，因为常量成员只能初始化不能赋值</li>
<li>引用类型</li>
<li>没有默认构造函数的对象必须使用成员初始化列表的方式进行初始化</li>
</ul>
<p>详见<a target="_blank" rel="noopener" href="https://www.cnblogs.com/graphics/archive/2010/07/04/1770900.html">C++ 初始化列表</a></p>
<h4 id="（45）-用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）"><a href="#（45）-用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）" class="headerlink" title="（45） 用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）"></a>（45） 用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）</h4><ul>
<li><p>自动类型推导auto：auto的自动类型推导用于从初始化表达式中推断出变量的数据类型。通过auto的自动类型推导，可以大大简化我们的编程工作</p>
</li>
<li><p>nullptr<br>：nullptr是为了解决原来C++中NULL的二义性问题而引进的一种新的类型，因为NULL实际上代表的是0，而nullptr是void*类型的</p>
</li>
<li><p>lambda表达式：它类似Javascript中的闭包，它可以用于创建并定义匿名的函数对象，以简化编程工作。Lambda的语法如下：<br><code>[函数对象参数](操作符重载函数参数)mutable或exception声明-&gt;返回值类型&#123;函数体&#125;</code></p>
</li>
<li><p>thread类和mutex类</p>
</li>
<li><p>新的智能指针 unique_ptr和shared_ptr</p>
</li>
<li><p>更多详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/caogenwangbaoqiang/article/details/79438279">https://blog.csdn.net/caogenwangbaoqiang/article/details/79438279</a></p>
<h4 id="（46）-C-的调用惯例（简单一点C-函数调用的压栈过程）"><a href="#（46）-C-的调用惯例（简单一点C-函数调用的压栈过程）" class="headerlink" title="（46） C++的调用惯例（简单一点C++函数调用的压栈过程）"></a>（46） C++的调用惯例（简单一点C++函数调用的压栈过程）</h4><p>函数的调用过程：</p>
</li>
</ul>
<p>1）从栈空间分配存储空间</p>
<p>2）从实参的存储空间复制值到形参栈空间</p>
<p>3）进行运算</p>
<p>形参在函数未调用之前都是没有分配存储空间的，在函数调用结束之后，形参弹出栈空间，清除形参空间。</p>
<p>数组作为参数的函数调用方式是地址传递，形参和实参都指向相同的内存空间，调用完成后，形参指针被销毁，但是所指向的内存空间依然存在，不能也不会被销毁。</p>
<p>当函数有多个返回值的时候，不能用普通的 return 的方式实现，需要通过传回地址的形式进行，即地址&#x2F;指针传递。</p>
<h4 id="（47）-C-的四种强制转换"><a href="#（47）-C-的四种强制转换" class="headerlink" title="（47） C++的四种强制转换"></a>（47） C++的四种强制转换</h4><p>四种强制类型转换操作符分别为：static_cast、dynamic_cast、const_cast、reinterpret_cast</p>
<ul>
<li>1）static_cast ：<br>用于各种隐式转换。具体的说，就是用户各种基本数据类型之间的转换，比如把int换成char，float换成int等。以及派生类（子类）的指针转换成基类（父类）指针的转换。<blockquote>
<p>特性与要点：</p>
</blockquote>
<ol>
<li>它没有运行时类型检查，所以是有安全隐患的。</li>
<li>在派生类指针转换到基类指针时，是没有任何问题的，在基类指针转换到派生类指针的时候，会有安全问题。</li>
<li>static_cast不能转换const，volatile等属性</li>
</ol>
</li>
<li>2）dynamic_cast：<br>用于动态类型转换。具体的说，就是在基类指针到派生类指针，或者派生类到基类指针的转换。<br>dynamic_cast能够提供运行时类型检查，只用于含有虚函数的类。<br>dynamic_cast如果不能转换返回NULL。</li>
<li>3）const_cast：<br>用于去除const常量属性，使其可以修改 ，也就是说，原本定义为const的变量在定义后就不能进行修改的，但是使用const_cast操作之后，可以通过这个指针或变量进行修改; 另外还有volatile属性的转换。</li>
<li>4）reinterpret_cast<br>几乎什么都可以转，用在任意的指针之间的转换，引用之间的转换，指针和足够大的int型之间的转换，整数到指针的转换等。但是不够安全。<h4 id="（48）string的底层实现"><a href="#（48）string的底层实现" class="headerlink" title="（48）string的底层实现"></a>（48）string的底层实现</h4>string继承自basic_string,其实是对char*进行了封装，封装的string包含了char*数组，容量，长度等等属性。</li>
</ul>
<p>string可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间（2^n），然后将原字符串拷贝过去，并加上新增的内容。</p>
<h4 id="（49）一个函数或者可执行文件的生成过程或者编译过程是怎样的"><a href="#（49）一个函数或者可执行文件的生成过程或者编译过程是怎样的" class="headerlink" title="（49）一个函数或者可执行文件的生成过程或者编译过程是怎样的"></a>（49）一个函数或者可执行文件的生成过程或者编译过程是怎样的</h4><p>预处理，编译，汇编，链接</p>
<ul>
<li>预处理： 对预处理命令进行替换等预处理操作</li>
<li>编译：代码优化和生成汇编代码</li>
<li>汇编：将汇编代码转化为机器语言</li>
<li>链接：将目标文件彼此链接起来<h4 id="（50）set，map和vector的插入复杂度"><a href="#（50）set，map和vector的插入复杂度" class="headerlink" title="（50）set，map和vector的插入复杂度"></a>（50）set，map和vector的插入复杂度</h4>set,map的插入复杂度就是红黑树的插入复杂度，是log(N)。</li>
</ul>
<p>unordered_set,unordered_map的插入复杂度是常数，最坏是O(N).</p>
<p>vector的插入复杂度是O(N),最坏的情况下（从头插入）就要对所有其他元素进行移动，或者扩容重新拷贝</p>
<h4 id="（51）定义和声明的区别"><a href="#（51）定义和声明的区别" class="headerlink" title="（51）定义和声明的区别"></a>（51）定义和声明的区别</h4><ul>
<li><p>声明是告诉编译器变量的类型和名字，不会为变量分配空间</p>
</li>
<li><p>定义就是对这个变量和函数进行内存分配和初始化。需要分配空间，同一个变量可以被声明多次，但是只能被定义一次</p>
<h4 id="（52）typdef和define区别"><a href="#（52）typdef和define区别" class="headerlink" title="（52）typdef和define区别"></a>（52）typdef和define区别</h4></li>
</ul>
<p>#define是预处理命令，在预处理是执行简单的替换，不做正确性的检查</p>
<p>typedef是在编译时处理的，它是在自己的作用域内给已经存在的类型一个别名</p>
<h4 id="（53）被free回收的内存是立即返还给操作系统吗？为什么"><a href="#（53）被free回收的内存是立即返还给操作系统吗？为什么" class="headerlink" title="（53）被free回收的内存是立即返还给操作系统吗？为什么"></a>（53）被free回收的内存是立即返还给操作系统吗？为什么</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/YMY_mine/article/details/81180168">https://blog.csdn.net/YMY_mine/article/details/81180168</a></p>
<p>不是的，被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。</p>
<h4 id="（54）引用作为函数参数以及返回值的好处"><a href="#（54）引用作为函数参数以及返回值的好处" class="headerlink" title="（54）引用作为函数参数以及返回值的好处"></a>（54）引用作为函数参数以及返回值的好处</h4><p>对比值传递，引用传参的好处：</p>
<p>1）在函数内部可以对此参数进行修改</p>
<p>2）提高函数调用和运行的效率（因为没有了传值和生成副本的时间和空间消耗）</p>
<p>如果函数的参数实质就是形参，不过这个形参的作用域只是在函数体内部，也就是说实参和形参是两个不同的东西，要想形参代替实参，肯定有一个值的传递。函数调用时，值的传递机制是通过“形参&#x3D;实参”来对形参赋值达到传值目的，产生了一个实参的副本。即使函数内部有对参数的修改，也只是针对形参，也就是那个副本，实参不会有任何更改。函数一旦结束，形参生命也宣告终结，做出的修改一样没对任何变量产生影响。</p>
<p>用引用作为返回值最大的好处就是在内存中不产生被返回值的副本。</p>
<p>但是有以下的限制：</p>
<p>1）不能返回局部变量的引用。因为函数返回以后局部变量就会被销毁</p>
<p>2）不能返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一 个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak</p>
<p>3）可以返回类成员的引用，但是最好是const。因为如果其他对象可以获得该属性的非常量的引用，那么对该属性的单纯赋值就会破坏业务规则的完整性。 </p>
<h4 id="（55）友元函数和友元类"><a href="#（55）友元函数和友元类" class="headerlink" title="（55）友元函数和友元类"></a>（55）友元函数和友元类</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhuguanhao/p/6286145.html">https://www.cnblogs.com/zhuguanhao/p/6286145.html</a></p>
<p>友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。通过友元，一个不同函数或者另一个类中的成员函数可以访问类中的私有成员和保护成员。友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。</p>
<p>1）友元函数</p>
<p>有元函数是定义在类外的普通函数，不属于任何类，可以访问其他类的私有成员。但是需要在类的定义中声明所有可以访问它的友元函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">set_show</span><span class="params">(<span class="type">int</span> x, A &amp;a)</span></span>;      <span class="comment">//该函数是友元函数的声明</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_show</span><span class="params">(<span class="type">int</span> x, A &amp;a)</span>  <span class="comment">//友元函数定义，为了访问类A中的成员</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a.data = x;</span><br><span class="line">    cout &lt;&lt; a.data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">A</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_show</span>(<span class="number">1</span>, a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个函数可以是多个类的友元函数，但是每个类中都要声明这个函数。</p>
<p>2）友元类</p>
<p>友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。<br>但是另一个类里面也要相应的进行声明</p>
 <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">C</span>;                         <span class="comment">//这是友元类的声明</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>             <span class="comment">//友元类定义，为了访问类A中的成员</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_show</span><span class="params">(<span class="type">int</span> x, A &amp;a)</span> </span>&#123; a.data = x; cout&lt;&lt;a.data&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">A</span> a;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">C</span> c;</span><br><span class="line"></span><br><span class="line">    c.<span class="built_in">set_show</span>(<span class="number">1</span>, a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用友元类时注意： </p>
<p>(1) 友元关系不能被继承。 </p>
<p>(2) 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。 </p>
<p>(3) 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明</p>
<h5 id="（56）-说一下volatile关键字的作用"><a href="#（56）-说一下volatile关键字的作用" class="headerlink" title="（56） 说一下volatile关键字的作用"></a>（56） 说一下volatile关键字的作用</h5><p>volatile的意思是“脆弱的”，表明它修饰的变量的值十分容易被改变，所以编译器就不会对这个变量进行优化（CPU的优化是让该变量存放到CPU寄存器而不是内存），进而提供稳定的访问。每次读取volatile的变量时，系统总是会从内存中读取这个变量，并且将它的值立刻保存。</p>
<h4 id="（57）-STL中的sort-算法是用什么实现的，stable-sort-呢"><a href="#（57）-STL中的sort-算法是用什么实现的，stable-sort-呢" class="headerlink" title="（57） STL中的sort()算法是用什么实现的，stable_sort()呢"></a>（57） STL中的sort()算法是用什么实现的，stable_sort()呢</h4><p>STL中的sort是用快速排序和插入排序结合的方式实现的，stable_sort()是归并排序。</p>
<h4 id="（58）vector会迭代器失效吗？什么情况下会迭代器失效？"><a href="#（58）vector会迭代器失效吗？什么情况下会迭代器失效？" class="headerlink" title="（58）vector会迭代器失效吗？什么情况下会迭代器失效？"></a>（58）vector会迭代器失效吗？什么情况下会迭代器失效？</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/qingjiaowoxiaoxioashou/p/5874572.html">https://www.cnblogs.com/qingjiaowoxiaoxioashou/p/5874572.html</a></p>
<ul>
<li>会</li>
<li>当vector在插入的时候，如果原来的空间不够，会将申请新的内存并将原来的元素移动到新的内存，此时指向原内存地址的迭代器就失效了，first和end迭代器都失效</li>
<li>当vector在插入的时候，end迭代器肯定会失效</li>
<li>当vector在删除的时候，被删除元素以及它后面的所有元素迭代器都失效。</li>
</ul>
<h4 id="（58）为什么C-没有实现垃圾回收？"><a href="#（58）为什么C-没有实现垃圾回收？" class="headerlink" title="（58）为什么C++没有实现垃圾回收？"></a>（58）为什么C++没有实现垃圾回收？</h4><ul>
<li>首先，实现一个垃圾回收器会带来额外的空间和时间开销。你需要开辟一定的空间保存指针的引用计数和对他们进行标记mark。然后需要单独开辟一个线程在空闲的时候进行free操作。  </li>
<li>垃圾回收会使得C++不适合进行很多底层的操作。</li>
</ul>
<h1 id="2-计网相关"><a href="#2-计网相关" class="headerlink" title="2. 计网相关"></a>2. 计网相关</h1><h4 id="（1）-建立TCP服务器的各个系统调用"><a href="#（1）-建立TCP服务器的各个系统调用" class="headerlink" title="（1） 建立TCP服务器的各个系统调用"></a>（1） 建立TCP服务器的各个系统调用</h4><p>建立TCP服务器连接的过程中主要通过以下系统调用序列来获取某些函数，这些系统调用主要包括：socket（），bind（），listen（），accept（），send（）和recv（）。<br>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37964547/article/details/81429627">建立TCP 服务器的系统调用</a></p>
<h4 id="（2）-继上一题，说明socket网络编程有哪些系统调用？其中close是一次就能直接关闭的吗，半关闭状态是怎么产生的？"><a href="#（2）-继上一题，说明socket网络编程有哪些系统调用？其中close是一次就能直接关闭的吗，半关闭状态是怎么产生的？" class="headerlink" title="（2） 继上一题，说明socket网络编程有哪些系统调用？其中close是一次就能直接关闭的吗，半关闭状态是怎么产生的？"></a>（2） 继上一题，说明socket网络编程有哪些系统调用？其中close是一次就能直接关闭的吗，半关闭状态是怎么产生的？</h4><pre><code>socket()    创建套接字   
bind()      绑定本机端口    
connect()   建立连接     （TCP三次握手在调用这个函数时进行）
listen()    监听端口
accept()    接受连接
recv(), read(), recvfrom()  数据接收
send(), write(), sendto()   数据发送
close(), shutdown() 关闭套接字
</code></pre>
<p>使用close()时，只有当套接字的引用计数为0的时候才会终止连接，而用shutdown()就可以直接关闭连接</p>
<p>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/junjun150013652/article/details/37994907">网络编程Socket之TCP之close&#x2F;shutdown详解</a></p>
<p>TCP连接与断开详解： <a target="_blank" rel="noopener" href="https://www.cnblogs.com/felixzh/p/8359066.html">https://www.cnblogs.com/felixzh/p/8359066.html</a></p>
<h4 id="（3）-对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF，和外部网关协议EGP和BGP"><a href="#（3）-对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF，和外部网关协议EGP和BGP" class="headerlink" title="（3） 对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF，和外部网关协议EGP和BGP."></a>（3） 对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF，和外部网关协议EGP和BGP.</h4><ul>
<li><p>RIP“路由信息协议(Route Information Protocol)”的简写，主要传递路由信息，通过每隔30秒广播一次路由表，维护相邻路由器的位置关系，同时根据收到的路由表信息使用动态规划的方式计算自己的路由表信息。RIP是一个距离矢量路由协议,最大跳数为16跳,16跳以及超过16跳的网络则认为目标网络不可达。</p>
</li>
<li><p>OSPF：详见：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/41341540">https://zhuanlan.zhihu.com/p/41341540</a></p>
</li>
</ul>
<h4 id="（4）-UDP如何实现可靠传输"><a href="#（4）-UDP如何实现可靠传输" class="headerlink" title="（4） UDP如何实现可靠传输"></a>（4） UDP如何实现可靠传输</h4><p>因为UDP是无连接的协议，所以在传输层上无法保证可靠传输，要想实现可靠传输，只能从应用层实现。需要实现seq&#x2F;ack机制，重传机制和窗口确认机制。</p>
<p>就要接收方收到UDP之后回复个确认包，发送方有个机制，收不到确认包就要重新发送，每个包有递增的序号，接收方发现中间丢了包就要发重传请求，当网络太差时候频繁丢包，防止越丢包越重传的恶性循环，要有个发送窗口的限制，发送窗口的大小根据网络传输情况调整，调整算法要有一定自适应性。</p>
<p>作者：姚冬<br>链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/283995548/answer/661809748">https://www.zhihu.com/question/283995548/answer/661809748</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h4 id="（5）-TCP和UDP的区别"><a href="#（5）-TCP和UDP的区别" class="headerlink" title="（5） TCP和UDP的区别"></a>（5） TCP和UDP的区别</h4><ul>
<li>TCP是面向连接的协议，提供的是可靠传输，在收发数据前需要通过三次握手建立连接，使用ACK对收发的数据进行正确性检验。而UDP是无连接的协议，不管对方有没有收到或者收到的数据是否正确。</li>
<li>TCP提供流量控制和拥塞控制，而UDP没有。</li>
<li>TCP对系统资源的要求高于UDP，所以速度也比UDP慢。</li>
<li>TCP数据包是没有边界的，会出现粘包的问题，UDP包是独立的，不会出现粘包问题。</li>
<li>所以在应用方面，如果强调数据的完整性和正确性用TCP，当要求性能和速度的时候，使用UDP更加合适。</li>
</ul>
<p>注：单凭TCP是不能保证完整性的，要是有黑客伪造TCP包，是无法识别的。</p>
<h4 id="（6）-TCP和UDP相关的协议与端口号"><a href="#（6）-TCP和UDP相关的协议与端口号" class="headerlink" title="（6） TCP和UDP相关的协议与端口号"></a>（6） TCP和UDP相关的协议与端口号</h4><p>TCP族的协议有HTTP，HTTPS，SMTP，TelNet，FTP等，UDP族的协议有DNS，DHCP等等。<br>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_22080999/article/details/81105051">https://blog.csdn.net/qq_22080999/article/details/81105051</a></p>
<h4 id="（7）-TCP（UDP，IP）等首部的认识（http请求报文构成）"><a href="#（7）-TCP（UDP，IP）等首部的认识（http请求报文构成）" class="headerlink" title="（7） TCP（UDP，IP）等首部的认识（http请求报文构成）"></a>（7） TCP（UDP，IP）等首部的认识（http请求报文构成）</h4><p>TCP的头部大致包括：源端口，目的端口，序号，确认号，偏移位，标志位，校验和等等</p>
<p>UDP的头部则包括：源端口，目的端口，长度，校验和。</p>
<p>IP数据包的头部包括：源IP地址，目的IP地址，协议，校验和，总长度等等</p>
<p>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zhangliangzi/article/details/52554439">https://blog.csdn.net/zhangliangzi/article/details/52554439</a></p>
<h4 id="（8）-网页解析的过程与实现方法"><a href="#（8）-网页解析的过程与实现方法" class="headerlink" title="（8） 网页解析的过程与实现方法"></a>（8） 网页解析的过程与实现方法</h4><p>这里仅展示浏览器解析服务器响应的过程，URL解析和交互的完整过程在(9)</p>
<ul>
<li>首先是html文档解析，浏览器会将html文档生成解析树，也就是DOM树，它由dom元素以及属性节点组成。</li>
<li>然后浏览器加载过程中如果遇到了外部css文件或者图片资源，还会另外发送请求来获取css文件和资源，这个请求通常是异步的，不会影响html文档的加载。</li>
<li>不过如果浏览器在加载时遇到了js文件，则会挂起渲染的线程，等待js文件加载解析完毕才恢复html的渲染线程。</li>
<li>然后是css解析，将css文件解析为样式表对象来渲染DOM树。<h4 id="（9）-在浏览器中输入URL后执行的全部过程（如www-baidu-com）"><a href="#（9）-在浏览器中输入URL后执行的全部过程（如www-baidu-com）" class="headerlink" title="（9）    在浏览器中输入URL后执行的全部过程（如www.baidu.com）"></a>（9）    在浏览器中输入URL后执行的全部过程（如<a target="_blank" rel="noopener" href="http://www.baidu.com)/">www.baidu.com）</a></h4></li>
</ul>
<ol>
<li>首先是域名解析，客户端使用DNS协议将URL解析为对应的IP地址；</li>
<li>然后建立TCP连接，客户端与服务器通过三次握手建立TCP连接；</li>
<li>接着是http连接，客户端向服务器发送http连接请求； （http连接无需额外连接，直接通过已经建立的TCP连接发送）</li>
<li>服务器对客户端发来的http请求进行处理，并返回响应；</li>
<li>客户端接收到http响应，将结果渲染展示给用户。<h4 id="（10）-网络层分片的原因与具体实现"><a href="#（10）-网络层分片的原因与具体实现" class="headerlink" title="（10） 网络层分片的原因与具体实现"></a>（10） 网络层分片的原因与具体实现</h4>因为在链路层中帧的大小通常都有限制，比如在以太网中帧的最大大小（MTU）就是1500字节。如果IP数据包加上头部后大小超过1500字节，就需要分片。</li>
</ol>
<p>IP分片和完整IP报文差不多拥有相同的IP头，16位ID域对于每个分片都是一致的，这样才能在重新组装的时候识别出来自同一个IP报文的分片。在IP头里面，16位识别号唯一记录了一个IP包的ID，具有同一个ID的IP分片将会重新组装；而13位片偏移则记录了某IP片相对整个包的位置；而这两个表中间的3位标志则标志着该分片后面是否还有新的分片。这三个标志就组成了IP分片的所有信息(将在后面介绍)，接受方就可以利用这些信息对IP数据进行重新组织。<br>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/gettogetto/article/details/72851734">https://blog.csdn.net/gettogetto/article/details/72851734</a></p>
<h4 id="（11）-TCP的三次握手与四次挥手的详细介绍（TCP连接建立与断开是热门问题）"><a href="#（11）-TCP的三次握手与四次挥手的详细介绍（TCP连接建立与断开是热门问题）" class="headerlink" title="（11） TCP的三次握手与四次挥手的详细介绍（TCP连接建立与断开是热门问题）"></a>（11） TCP的三次握手与四次挥手的详细介绍（TCP连接建立与断开是热门问题）</h4><ul>
<li>三次握手</li>
</ul>
<p>第一次握手：首先client给server发送连接请求报文，在这个报文中，包含了SYN&#x3D;1，client_seq&#x3D;任意值i，发送之后处于SYN-SENT状态，这是第一次握手</p>
<p>第二次握手：server端接收到了这个请求，并分配资源，同时给client返回一个ACK报文，这个报文中呢包含了这些字段，标志位SYN和ACK都为1，而小ack为i+1，此时位于SYN-RCVD状态，这是第二次握手</p>
<p>第三次握手：client收到server发来的ACK信息后呢，他会看到server发过来的小ack是i+1，这时他知道了server收到了消息，也给server回一个ACK报文，报文中同样包含了ACK&#x3D;1这样的消息，同时呢，还包括了client_ack&#x3D;k+1这样的字段，这样呢三次握手之后，连接就建立了，client进入established（已建立连接）状态<br><img src="/fig/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="三次握手.png"></p>
<ul>
<li>四次挥手断开连接：</li>
</ul>
<p>TCP断开连接通常是由一方主动，一方被动的，这里我们假设client主动，server被动<br>第一次挥手：当client没有数据要发送给server了，他会给server发送一个FIN报文，告诉server：“我已经没有数据要发给你了，但是你要是还想给我发数据的话，你就接着发，但是你得告诉我你收到我的关闭信息了”，这是第一次挥手，挥手之后client进入FIN_WAIT_1的第一阶段</p>
<p>第二次挥手：当server收到client发来的FIN报文后，告诉client：“我收到你的FIN消息了，但是你等我发完的”此时给client返回一个ACK信息，并且呢ack&#x3D;seq+1，这是第二次挥手，挥手之后呢server进入CLOSE_WAIT阶段，而client收到之后处于FIN_WAIT_2第二阶段</p>
<p>第三次挥手：当server发完所有数据时，他会给client发送一个FIN报文，告诉client说“我传完数据了，现在要关闭连接了”，然后呢server变成LAST_ACK状态，等着client最后的ACK信息，这是第三次挥手</p>
<p>第四次挥手：当client收到这个FIN报文时，他会对这个消息进行确认，即给server发ACK信息，但是它不相信网络，怕server收不到信息，它会进入TIME_WAIT状态，万一server没收到ACK消息它可以可以重传，而当server收到这个ACK信息后，就正式关闭了tcp连接，处于CLOSED状态，而client等待了2MSL这样长时间后还没等到消息，它知道server已经关闭连接了，于是乎他自己也断开了，这是第四次挥手，这样tcp连接就断开了<br><img src="/fig/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="fig/四次挥手.png"></p>
<h4 id="（12）-TCP握手以及每一次握手客户端和服务器端处于哪个状态"><a href="#（12）-TCP握手以及每一次握手客户端和服务器端处于哪个状态" class="headerlink" title="（12） TCP握手以及每一次握手客户端和服务器端处于哪个状态"></a>（12） TCP握手以及每一次握手客户端和服务器端处于哪个状态</h4><p>见上</p>
<h4 id="（13）-为什么使用三次握手，两次握手可不可以？"><a href="#（13）-为什么使用三次握手，两次握手可不可以？" class="headerlink" title="（13） 为什么使用三次握手，两次握手可不可以？"></a>（13） 为什么使用三次握手，两次握手可不可以？</h4><p>如果使用两次握手的话，三次握手中的最后一次缺失，服务器不能确认客户端的接收能力。</p>
<p>举两个例子，第一种是黑客会伪造大量SYN请求发送给服务器，服务器立即确认并建立连接，分配资源，但是这一系列连接并不是真实存在的，这大大浪费了服务器的资源并且阻塞了正常用户的连接，这种也叫SYN洪泛攻击。第二种是服务器返回给客户端的ACK数据包可能会在传输的过程中丢失，而客户端没有收到该ACK数据包而拒绝接收服务器接下来发送的数据，于是服务器一直在发送，客户端一直在拒绝，形成死锁。</p>
<h4 id="（14）-TIME-WAIT的意义（为什么要等于2MSL）"><a href="#（14）-TIME-WAIT的意义（为什么要等于2MSL）" class="headerlink" title="（14） TIME_WAIT的意义（为什么要等于2MSL）"></a>（14） TIME_WAIT的意义（为什么要等于2MSL）</h4><p>TIME_WAIT是指四次挥手中客户端接收了服务端的FIN报文并发送ACK报文给服务器后，仍然需要等待2MSL时间的过程。虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。如果客户端发送的ACK发生丢失，服务器会再次发送FIN报文给客户端，所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p>
<h4 id="（15）-超时重传机制（不太高频）"><a href="#（15）-超时重传机制（不太高频）" class="headerlink" title="（15） 超时重传机制（不太高频）"></a>（15） 超时重传机制（不太高频）</h4><h4 id="（16）-TCP怎么保证可靠性？"><a href="#（16）-TCP怎么保证可靠性？" class="headerlink" title="（16） TCP怎么保证可靠性？"></a>（16） TCP怎么保证可靠性？</h4><p><strong>（校序重流拥）</strong></p>
<ul>
<li><p>校验和<br>发送的数据包的二进制相加然后取反，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。 </p>
</li>
<li><p>确认应答+序列号<br>TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 </p>
</li>
<li><p>超时重传<br>当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 </p>
</li>
<li><p>流量控制<br>TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。<br>接收方有即时窗口（滑动窗口），随ACK报文发送</p>
</li>
<li><p>拥塞控制<br>当网络拥塞时，减少数据的发送。<br>发送方有拥塞窗口，发送数据前比对接收方发过来的即使窗口，取小</p>
</li>
</ul>
<p>慢启动、拥塞避免、快速重传、快速恢复 </p>
<h4 id="（17）-流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？"><a href="#（17）-流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？" class="headerlink" title="（17） 流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？"></a>（17） 流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？</h4><p>所谓流量控制就是让发送方发送速率不要过快，让接收方来得及接收。利用TCP报文段中的窗口大小字段来控制发送方的发送窗口不大于接收方发回的窗口大小就可以实施流量控制。</p>
<p>考虑一种特殊的情况，就是接收方若没有缓存足够使用，就会发送零窗口大小的报文，此时发送放将发送窗口设置为0，停止发送数据。之后接收方有足够的缓存，发送了非零窗口大小的报文，但是这个报文在中途丢失的，那么发送方的发送窗口就一直为零导致死锁。</p>
<p>解决这个问题，TCP为每一个连接设置一个持续计时器（persistence timer）。只要TCP的一方收到对方的零窗口通知，就启动该计时器，周期性的发送一个零窗口探测报文段。对方就在确认这个报文的时候给出现在的窗口大小（注意：TCP规定，即使设置为零窗口，也必须接收以下几种报文段：零窗口探测报文段、确认报文段和携带紧急数据的报文段）。</p>
<h4 id="（18）-tcp滑动窗口协议"><a href="#（18）-tcp滑动窗口协议" class="headerlink" title="（18） tcp滑动窗口协议"></a>（18） tcp滑动窗口协议</h4><p>详见 <a target="_blank" rel="noopener" href="https://blog.csdn.net/wdscq1234/article/details/52444277">TCP-IP详解：滑动窗口SlidingWindow</a>和<a target="_blank" rel="noopener" href="https://www.cnblogs.com/alifpga/p/7675850.html">TCP滑动窗口</a></p>
<p>TCP的滑动窗口用来控制接收方和发送方的发送速率，避免拥塞的发生。滑动窗口其实就是接收端的缓冲区大小，用来告诉发送方对它发送的数据有多大的缓冲空间。在接收方的滑动窗口已知的情况下，当接收方确认了连续的数据序列之后，发送方的滑动窗口向后滑动，发送下一个数据序列。</p>
<p>接收方会在每个ACK数据包中附带自己当前的接受窗口（滑动窗口）的大小，方便发送方进行控制。</p>
<h4 id="（19）-拥塞控制和流量控制的区别"><a href="#（19）-拥塞控制和流量控制的区别" class="headerlink" title="（19） 拥塞控制和流量控制的区别"></a>（19） 拥塞控制和流量控制的区别</h4><p>拥塞控制是防止过多的数据注入到网络中，导致网络发生拥塞；而流量控制是防止发送方一下子发送过多的数据到接收方，导致接收方缓存放不下。两种算法都是对发送方的行为进行控制的。</p>
<h4 id="（20）-TCP拥塞控制，算法名字？（极其重要）"><a href="#（20）-TCP拥塞控制，算法名字？（极其重要）" class="headerlink" title="（20） TCP拥塞控制，算法名字？（极其重要）"></a>（20） TCP拥塞控制，算法名字？（极其重要）</h4><p><img src="/fig/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.png" alt="拥塞控制"><br>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载，拥塞控制自然也是控制发送者的流量，拥塞控制有四种算法，<strong>慢启动、拥塞避免，快速重传和快速恢复</strong></p>
<p>发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口和接受窗口的较小值。</p>
<p>（1）<strong>慢启动</strong>。慢启动算法的思路是当主机开始发送数据时，先以比较小的拥塞窗口进行发送，然后每次翻倍，也就是说，由小到大逐渐增加拥塞窗口的大小，而这个大小是指数增长的，即1、2、4、8、16<br>*为了防止拥塞窗口cwnd增长过大引起网络拥塞，还要另外设置一个慢启动阈值ssthresh状态变量，当拥塞窗口的大小超过慢启动阈值的时候（ cwnd &gt; ssthresh 时），停止使用慢开始算法而改用拥塞避免算法</p>
<p>（2）<strong>拥塞避免</strong>。拥塞避免算法的思路是让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。</p>
<p>（3）<strong>快速重传</strong>。当发送端连续收到三个重复的ack时，表示该数据段已经丢失，需要重发。此时慢启动阈值ssth变为原来一半，拥塞窗口cwnd变为ssth+3，然后+1+1的发（每一轮rtt+1）</p>
<p>（4）<strong>快速恢复</strong>。当超过设定的时间没有收到某个报文段的ack时，表示网络拥塞，慢启动阈值ssth变为原来一半，拥塞窗口cwnd&#x3D;1，进入慢启动阶段</p>
<h4 id="（21）-http协议与TCP的区别与联系"><a href="#（21）-http协议与TCP的区别与联系" class="headerlink" title="（21） http协议与TCP的区别与联系"></a>（21） http协议与TCP的区别与联系</h4><p>联系：Http协议是建立在TCP协议基础之上的，当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。Http会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据传输完毕后，Http会立即将TCP连接断开，这个过程是很短的。</p>
<p>区别：HTTP和TCP位于不同的网络分层。TCP是传输层的协议，定义的是数据传输和连接的规范，而HTTP是应用层的，定义的是数据的内容的规范。<br>建立一个TCP请求需要进行三次握手，而由于http是建立在tcp连接之上的，建立一个http请求通常包含请求和响应两个步骤。</p>
<h4 id="（22）-http-x2F-1-0和http-x2F-1-1的区别"><a href="#（22）-http-x2F-1-0和http-x2F-1-1的区别" class="headerlink" title="（22） http&#x2F;1.0和http&#x2F;1.1的区别"></a>（22） http&#x2F;1.0和http&#x2F;1.1的区别</h4><p>HTTP 协议老的标准是 HTTP&#x2F;1.0 ，目前最通用的标准是 HTTP&#x2F;1.1 。<br>HTTP1.0 只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，但是最新的http&#x2F;1.0加入了长连接，只需要在客户端给服务器发送的http报文头部加入Connection:keep-alive<br>HTTP 1.1 支持持久连接，默认进行持久连接，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。</p>
<h4 id="（23）-http的请求方法有哪些？get和post的区别。"><a href="#（23）-http的请求方法有哪些？get和post的区别。" class="headerlink" title="（23） http的请求方法有哪些？get和post的区别。"></a>（23） http的请求方法有哪些？get和post的区别。</h4><p>HTTP的请求方法包括GET，POST，PUT，DELETE四种基本方法。（四种方法中只有POST不是操作幂等性的）</p>
<p>get和post的区别：</p>
<ol>
<li>get方法不会修改服务器上的资源，它的查询是没有副作用的，而post有可能会修改服务器上的资源</li>
<li>get可以保存为书签，可以用缓存来优化，而post不可以</li>
<li>get把请求附在url上，而post把参数附在http包的包体中</li>
<li>浏览器和服务器一般对get方法所提交的url长度有限制，一般是1k或者2k，而对post方法所传输的参数大小限制为80k到4M不等</li>
<li>post可以传输二进制编码的信息，get的参数一般只支持ASCII<h4 id="（24）-http的状态码-403-201等等是什么意思"><a href="#（24）-http的状态码-403-201等等是什么意思" class="headerlink" title="（24） http的状态码 403 201等等是什么意思"></a>（24） http的状态码 403 201等等是什么意思</h4>详见 <a target="_blank" rel="noopener" href="https://blog.csdn.net/u011630575/article/details/46636535">HTTP状态码的含义</a></li>
</ol>
<p>常见的状态码有：</p>
<blockquote>
<ul>
<li>200 - 请求成功</li>
<li>301 - 资源（网页等）被永久转移到其它URL</li>
<li>404 - 请求的资源（网页等）不存在</li>
<li>500 - 内部服务器错误</li>
<li>400 - 请求无效 </li>
<li>403 - 禁止访问</li>
</ul>
</blockquote>
<h4 id="（25）-http和https的区别，由http升级为https需要做哪些操作"><a href="#（25）-http和https的区别，由http升级为https需要做哪些操作" class="headerlink" title="（25） http和https的区别，由http升级为https需要做哪些操作"></a>（25） http和https的区别，由http升级为https需要做哪些操作</h4><p>http 是超文本传输协议，信息是明文传输， https 则是具有安全性的 ssl 加密传输协议<br>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80 ，后者是 443<br>http 的连接很简单，是无状态的； HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比http 协议安全。<br>https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wqhwe/p/5407468.html">https://www.cnblogs.com/wqhwe/p/5407468.html</a></p>
<h4 id="（26）-https的具体实现，怎么确保安全性"><a href="#（26）-https的具体实现，怎么确保安全性" class="headerlink" title="（26） https的具体实现，怎么确保安全性"></a>（26） https的具体实现，怎么确保安全性</h4><p><strong>SSL是传输层的协议</strong></p>
<p>https包括非对称加密和对称加密两个阶段，在客户端与服务器建立连接的时候使用非对称加密，连接建立以后使用的是对称加密。</p>
<ol>
<li>客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接</li>
<li>Web服务器收到客户端请求后，会将网站的公钥传送一份给客户端，私钥自己保存。</li>
<li>客户端的浏览器根据双方同意的安全等级，生成对称加密使用的密钥，称为会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站</li>
<li>Web服务器利用自己的私钥解密出会话密钥。</li>
<li>Web服务器利用会话密钥加密与客户端之间的通信，这个过程是对称加密的过程。</li>
</ol>
<p>服务器第一次传给客户端的公钥其实是CA对网站信息进行加密的数字证书</p>
<p>客户端的对称加密密钥其实是三个随机数的哈希（1. 客户端第一次给服务端发送请求时附带的随机数 2. 服务器返回时的随机数 3. 客户端收到返回时的随机数）</p>
<h4 id="（27）-TCP三次握手时的第一次的seq序号是怎样产生的"><a href="#（27）-TCP三次握手时的第一次的seq序号是怎样产生的" class="headerlink" title="（27） TCP三次握手时的第一次的seq序号是怎样产生的"></a>（27） TCP三次握手时的第一次的seq序号是怎样产生的</h4><p>第一次的序号是随机序号，但也不是完全随机，它是使用一个ISN算法得到的。</p>
<p>seq &#x3D; C + H (源IP地址，目的IP地址，源端口，目的端口)。其中，C是一个计时器，每隔一段时间值就会变大，H是消息摘要算法，输入是一个四元组（源IP地址，目的IP地址，源端口，目的端口）。</p>
<h4 id="（28）-一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？"><a href="#（28）-一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？" class="headerlink" title="（28） 一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？"></a>（28） 一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？</h4><p>65536.因为TCP的报文头部中源端口号和目的端口号的长度是16位，也就是可以表示2^16&#x3D;65536个不同端口号，因此TCP可供识别的端口号最多只有65536个。但是由于0到1023是知名服务端口，所以实际上还要少1024个端口号。</p>
<p>而对于服务器来说，可以开的端口号与65536无关，其实是受限于Linux可以打开的文件数量，并且可以通过MaxUserPort来进行配置。</p>
<h4 id="（29）-对称密码和非对称密码体系"><a href="#（29）-对称密码和非对称密码体系" class="headerlink" title="（29） 对称密码和非对称密码体系"></a>（29） 对称密码和非对称密码体系</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_29689487/article/details/81634057">https://blog.csdn.net/qq_29689487/article/details/81634057</a></p>
<ul>
<li>对称加密：加密和解密使用的密钥是同一个<ul>
<li>优点：计算量小，算法速度快，加密效率高  缺点：密钥容易泄漏。不同的会话需要不同的密钥，管理起来很费劲</li>
<li>常用算法：DES，3DES，IDEA，CR4，CR5，CR6，AES</li>
</ul>
</li>
<li>非对称加密：需要公钥和私钥，公钥用来加密，私钥用来解密<ul>
<li>优点：安全，不怕泄漏  缺点：速度慢</li>
<li>常用算法：RSA，ECC，DSA<h4 id="（30）-数字证书的了解（高频）"><a href="#（30）-数字证书的了解（高频）" class="headerlink" title="（30） 数字证书的了解（高频）"></a>（30） 数字证书的了解（高频）</h4><img src="/fig/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6.jpg" alt="fig/数字证书.jpg"></li>
</ul>
</li>
</ul>
<p>权威CA使用私钥将网站A的信息和消息摘要（签名S）进行加密打包形成数字证书。公钥给客户端。</p>
<p>网站A将自己的信息和数字证书发给客户端，客户端用CA的公钥对数字证书进行解密，得到签名S，与手动将网站的信息进行消息摘要得到的结果S*进行对比，如果签名一致就证明网站A可以信任。</p>
<h4 id="（31）-服务器出现大量close-wait的连接的原因以及解决方法"><a href="#（31）-服务器出现大量close-wait的连接的原因以及解决方法" class="headerlink" title="（31） 服务器出现大量close_wait的连接的原因以及解决方法"></a>（31） 服务器出现大量close_wait的连接的原因以及解决方法</h4><p>close_wait状态是在TCP四次挥手的时候收到FIN但是没有发送自己的FIN时出现的，服务器出现大量close_wait状态的原因有两种：</p>
<ul>
<li>服务器内部业务处理占用了过多时间，都没能处理完业务；或者还有数据需要发送；或者服务器的业务逻辑有问题，没有执行close()方法</li>
<li>服务器的父进程派生出子进程，子进程继承了socket，收到FIN的时候子进程处理但父进程没有处理该信号，导致socket的引用不为0无法回收</li>
</ul>
<p>处理方法：</p>
<ul>
<li><p>停止应用程序</p>
</li>
<li><p>修改程序里的bug</p>
<h4 id="（32）-消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢？（百度安全一面）"><a href="#（32）-消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢？（百度安全一面）" class="headerlink" title="（32） 消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢？（百度安全一面）"></a>（32） 消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢？（百度安全一面）</h4></li>
<li><p>消息摘要算法有MD家族（MD2，MD4，MD5），SHA家族（SHA-1,SHA-256）和CRC家族（CRC8,CRC16,CRC32）等等</p>
</li>
<li><p>MD5算法介绍：<br>MD5以512位分组来处理输入的信息，且每一分组又被划分为若干个小分组（16个32位子分组），经过一些列的处理后，算法输出由四个散列值（32位分组组成的128位散列值。）</p>
</li>
</ul>
<ol>
<li>MD5首先将输入的信息分成若干个512字节长度的分组，如果不够就填充1和若干个0。</li>
<li>对每个512字节的分组进行循环运算。使用四个幻数对第一个分组的数据进行四轮变换，得到四个变量。</li>
<li>接下来对其中三个使用线性函数进行计算，与剩下一个相加，并赋值给其中某个变量，得到新的四个变量，重复16次这个过程，得到的四个变量作为幻数，与下一个分组进行相似的计算。</li>
<li>遍历所有分组后得到的四个变量即为结果。</li>
</ol>
<p>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39640298/article/details/84555814">https://blog.csdn.net/weixin_39640298/article/details/84555814</a></p>
<ul>
<li><p>为什么不可逆：因为MD5在进行消息摘要的过程中，数据与原始数据相比发生了丢失，所以不能由结果进行恢复。</p>
</li>
<li><p>加强安全性：加盐（加随机数）</p>
<h4 id="（33）-单条记录高并发访问的优化"><a href="#（33）-单条记录高并发访问的优化" class="headerlink" title="（33） 单条记录高并发访问的优化"></a>（33） 单条记录高并发访问的优化</h4><p>服务器端：</p>
</li>
<li><p>使用缓存，如redis等</p>
</li>
<li><p>使用分布式架构进行处理</p>
</li>
<li><p>将静态页面和静态资源存储在静态资源服务器，需要处理的数据使用服务器进行计算后返回</p>
</li>
<li><p>将静态资源尽可能在客户端进行缓存</p>
</li>
<li><p>采用ngnix进行负载均衡 （nginx读作恩静埃克斯 &#x3D; Engine X）</p>
</li>
</ul>
<p>数据库端：</p>
<ul>
<li>数据库采用主从赋值，读写分离措施</li>
<li>建立适当的索引</li>
<li>分库分表<h4 id="（34）-介绍一下ping的过程，分别用到了哪些协议"><a href="#（34）-介绍一下ping的过程，分别用到了哪些协议" class="headerlink" title="（34） 介绍一下ping的过程，分别用到了哪些协议"></a>（34） 介绍一下ping的过程，分别用到了哪些协议</h4>详见：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Akagi201/archive/2012/03/26/2418475.html">Ping原理与ICMP协议</a></li>
</ul>
<p>ping是使用ICMP协议来进行工作的。 ICMP:网络控制报文协议</p>
<ul>
<li>首先，ping命令会构建一个ICMP请求数据包，然后由ICMP协议将这个数据包连同目的IP地址源IP地址一起交给IP协议。</li>
<li>然后IP协议就会构建一个IP数据报，并且在映射表中查找目的IP对应的mac地址，将其交给数据链路层。</li>
<li>然后数据链路层就会构建一个数据帧，附上源mac地址和目的mac地址发送出去。</li>
</ul>
<p>目的主机接收到数据帧后，就会检查包上的mac地址与本机mac是否相符，如果相符，就接收并把其中的信息提取出来交给IP协议，IP协议就会将其中的信息提取出来交给ICMP协议。然后构建一个ICMP应答包，用相同的过程发送回去。</p>
<h4 id="（35）-TCP-x2F-IP的粘包与避免介绍一下"><a href="#（35）-TCP-x2F-IP的粘包与避免介绍一下" class="headerlink" title="（35） TCP&#x2F;IP的粘包与避免介绍一下"></a>（35） TCP&#x2F;IP的粘包与避免介绍一下</h4><p>因为TCP为了减少额外开销，采取的是流式传输，所以接收端在一次接收的时候有可能一次接收多个包。而TCP粘包就是发送方的若干个数据包到达接收方的时候粘成了一个包。多个包首尾相接，无法区分。</p>
<p>导致TCP粘包的原因有三方面：</p>
<ul>
<li>发送端等待缓冲区满才进行发送，造成粘包</li>
<li>接收方来不及接收缓冲区内的数据，造成粘包</li>
<li>由于TCP协议在发送较小的数据包的时候，会将几个包合成一个包后发送</li>
</ul>
<p>避免粘包的措施：</p>
<ul>
<li>通过编程，强制使TCP发生数据传送，不必等到缓冲区满</li>
<li>优化接收方接收数据的过程，使其来得及接收数据包，包括提高接收进程优先级等</li>
<li>设置固定长度的报文或者设置报文头部指示报文的长度。</li>
</ul>
<h4 id="（36）-说一下TCP的封包和拆包"><a href="#（36）-说一下TCP的封包和拆包" class="headerlink" title="（36） 说一下TCP的封包和拆包"></a>（36） 说一下TCP的封包和拆包</h4><p>因为TCP是无边界的流传输，所以需要对TCP进行封包和拆包，确保发送和接收的数据不粘连。</p>
<ul>
<li>封包：封包就是在发送数据报的时候为每个TCP数据包加上一个包头，将数据报分为包头和包体两个部分。包头是一个固定长度的结构体，里面包含该数据包的总长度。</li>
<li>拆包：接收方在接收到报文后提取包头中的长度信息进行截取。<h4 id="（37）-一个ip配置多个域名，靠什么识别？"><a href="#（37）-一个ip配置多个域名，靠什么识别？" class="headerlink" title="（37） 一个ip配置多个域名，靠什么识别？"></a>（37） 一个ip配置多个域名，靠什么识别？</h4></li>
<li>靠host主机名区分</li>
<li>靠端口号区分<h4 id="（38）-服务器攻击（DDos攻击）"><a href="#（38）-服务器攻击（DDos攻击）" class="headerlink" title="（38） 服务器攻击（DDos攻击）"></a>（38） 服务器攻击（DDos攻击）</h4><h4 id="（39）DNS的工作过程和原理"><a href="#（39）DNS的工作过程和原理" class="headerlink" title="（39）DNS的工作过程和原理"></a>（39）DNS的工作过程和原理</h4><img src="/fig/DNS%E6%9F%A5%E8%AF%A2%E5%9B%BE%E8%A7%A3.png"><br>DNS解析有两种方式：递归查询和迭代查询</li>
<li>递归查询 用户先向本地域名服务器查询，如果本地域名服务器的缓存没有IP地址映射记录，就向根域名服务器查询，根域名服务器就会向顶级域名服务器查询，顶级域名服务器向权限域名服务器查询，查到结果后依次返回。</li>
<li>迭代查询 用户向本地域名服务器查询，如果没有缓存，本地域名服务器会向根域名服务器查询，根域名服务器返回顶级域名服务器的地址，本地域名服务器再向顶级域名服务器查询，得到权限域名服务器的地址，本地域名服务器再向权限域名服务器查询得到结果<h4 id="（41）OSA七层协议和五层协议，分别有哪些"><a href="#（41）OSA七层协议和五层协议，分别有哪些" class="headerlink" title="（41）OSA七层协议和五层协议，分别有哪些"></a>（41）OSA七层协议和五层协议，分别有哪些</h4>OSI七层协议模型主要是：应用层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、网络层（Network）、数据链路层（Data Link）、物理层（Physical）。</li>
</ul>
<p>五层体系结构包括：应用层、传输层、网络层、数据链路层和物理层。</p>
<p><img src="/fig/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%B1%82.png" alt="(fig/网络协议层.png"></p>
<h4 id="（42）IP寻址和MAC寻址有什么不同，怎么实现的"><a href="#（42）IP寻址和MAC寻址有什么不同，怎么实现的" class="headerlink" title="（42）IP寻址和MAC寻址有什么不同，怎么实现的"></a>（42）IP寻址和MAC寻址有什么不同，怎么实现的</h4><p>通过MAC地址寻找主机是MAC地址寻址，通过IP地址寻找主机叫IP地址寻址。它们适用于不同的协议层，IP寻址是网络层，Mac寻址是数据链路层。</p>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/6388.html">http://c.biancheng.net/view/6388.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wxy_nick/article/details/9190693">https://blog.csdn.net/wxy_nick/article/details/9190693</a></p>
<p>IP寻址的过程（ARP协议）：主机A想通过IP地址寻找到目标主机，首先分析IP地址确定目标主机与自己是否为同一网段。如果是则查看ARP缓存，或者使用ARP协议发送广播。如果不是，则寻找网关发送ARP数据包</p>
<h1 id="3-数据库"><a href="#3-数据库" class="headerlink" title="3. 数据库"></a>3. 数据库</h1><h4 id="（1）-关系型和非关系型数据库的区别（低频）"><a href="#（1）-关系型和非关系型数据库的区别（低频）" class="headerlink" title="（1） 关系型和非关系型数据库的区别（低频）"></a>（1） 关系型和非关系型数据库的区别（低频）</h4><ul>
<li>关系型数据库的优点<ol>
<li>容易理解。因为它采用了关系模型来组织数据。</li>
<li>可以保持数据的一致性。</li>
<li>数据更新的开销比较小。</li>
<li>支持复杂查询（带where子句的查询）</li>
</ol>
</li>
<li>非关系型数据库的优点<ol>
<li>不需要经过sql层的解析，读写效率高。</li>
<li>基于键值对，数据的扩展性很好。</li>
<li>可以支持多种类型数据的存储，如图片，文档等等。<h4 id="（2）-什么是非关系型数据库（低频）"><a href="#（2）-什么是非关系型数据库（低频）" class="headerlink" title="（2） 什么是非关系型数据库（低频）"></a>（2） 什么是非关系型数据库（低频）</h4>非关系型数据库也叫nosql，采用键值对的形式进行存储。它的读写性能很高，易于扩展。例如Redis,Mongodb,hbase等等。</li>
</ol>
</li>
</ul>
<p>适合使用非关系型数据库的场景：</p>
<ul>
<li>日志系统</li>
<li>地理位置存储</li>
<li>数据量巨大</li>
<li>高可用<h4 id="（3）-说一下-MySQL-执行一条查询语句的内部执行过程？"><a href="#（3）-说一下-MySQL-执行一条查询语句的内部执行过程？" class="headerlink" title="（3） 说一下 MySQL 执行一条查询语句的内部执行过程？"></a>（3） 说一下 MySQL 执行一条查询语句的内部执行过程？</h4></li>
<li>连接器：客户端先通过连接器连接到 MySQL 服务器。</li>
<li>缓存：连接器权限验证通过之后，先查询是否有查询缓存，如果有缓存（之前执行过此语句）则直接返回缓存数据，如果没有缓存则进入分析器。</li>
<li>分析器：分析器会对查询语句进行语法分析和词法分析，判断 SQL 语法是否正确，如果查询语法错误会直接返回给客户端错误信息，如果语法正确则进入优化器。</li>
<li>优化器：优化器是对查询语句进行优化处理，例如一个表里面有多个索引，优化器会判别哪个索引性能更好。</li>
<li>执行器：优化器执行完就进入执行器，执行器就开始执行语句进行查询比对了，直到查询到满足条件的所有数据，然后进行返回。<h4 id="（4）-数据库的索引类型"><a href="#（4）-数据库的索引类型" class="headerlink" title="（4） 数据库的索引类型"></a>（4） 数据库的索引类型</h4>数据库的索引类型分为逻辑分类和物理分类<br><br>逻辑分类：</li>
<li>主键索引 当关系表中定义主键时会自动创建主键索引。每张表中的主键索引只能有一个，要求主键中的每个值都唯一，即不可重复，也不能有空值。</li>
<li>唯一索引 数据列不能有重复，可以有空值。一张表可以有多个唯一索引，但是每个唯一索引只能有一列。如身份证，卡号等。</li>
<li>普通索引 一张表可以有多个普通索引，可以重复可以为空值</li>
<li>全文索引 可以加快模糊查询，不常用</li>
</ul>
<p>物理分类：</p>
<ul>
<li>聚集索引（聚簇索引） 数据在物理存储中的顺序跟索引中数据的逻辑顺序相同，比如以ID建立聚集索引，数据库中id从小到大排列，那么物理存储中该数据的内存地址值也按照从小到大存储。一般是表中的主键索引，如果没有主键索引就会以第一个非空的唯一索引作为聚集索引。一张表只能有一个聚集索引。</li>
<li>非聚集索引 数据在物理存储中的顺序跟索引中数据的逻辑顺序不同。非聚集索引因为无法定位数据所在的行，所以需要扫描两遍索引树。第一遍扫描非聚集索引的索引树，确定该数据的主键ID，然后到主键索引（聚集索引）中寻找相应的数据。<h4 id="（5）-说一下事务是怎么实现的"><a href="#（5）-说一下事务是怎么实现的" class="headerlink" title="（5） 说一下事务是怎么实现的"></a>（5） 说一下事务是怎么实现的</h4><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013256816/article/details/103966510">https://blog.csdn.net/u013256816/article/details/103966510</a></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/takumicx/p/9998844.html">https://www.cnblogs.com/takumicx/p/9998844.html</a></p>
<p>事务就是一组逻辑操作的集合。实现事务就是要保证可靠性和并发隔离，或者说，能够满足ACID特性的机制。而这些主要是靠日志恢复和并发控制实现的。</p>
<ul>
<li>日志恢复：数据库里有两个日志，一个是redo log，一个是undo log。redo log记录的是已经成功提交的事务操作信息，用来恢复数据，保证事务的<strong>持久性</strong>。undo log记录的是事务修改之前的数据信息，用来回滚数据，保证事务的<strong>原子性</strong>。</li>
<li>并发控制：并发控制主要靠读写锁和MVCC（多版本并发控制）来实现。读写锁包括共享锁和排他锁，保证事务的<strong>隔离性</strong>。MVCC通过为数据添加时间戳来实现。</li>
</ul>
<h4 id="（6）-MySQL怎么建立索引，怎么建立主键索引，怎么删除索引？"><a href="#（6）-MySQL怎么建立索引，怎么建立主键索引，怎么删除索引？" class="headerlink" title="（6） MySQL怎么建立索引，怎么建立主键索引，怎么删除索引？"></a>（6） MySQL怎么建立索引，怎么建立主键索引，怎么删除索引？</h4><p>MySQL建立索引有两种方式：用alter table或者create index。</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="built_in">table_name</span> <span class="keyword">add</span> <span class="keyword">primary key</span>(column_list) #添加一个主键索引</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="built_in">table_name</span> <span class="keyword">add</span> <span class="keyword">index</span> (column_list)      #添加一个普通索引</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="built_in">table_name</span> <span class="keyword">add</span> <span class="keyword">unique</span> (column_list)     #添加一个唯一索引</span><br></pre></td></tr></table></figure>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> index_name <span class="keyword">on</span> <span class="built_in">table_name</span> (column_list)   #创建一个普通索引</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index_name <span class="keyword">on</span> <span class="built_in">table_name</span> (column_list)  #创建一个唯一索引</span><br></pre></td></tr></table></figure>

<p>Mysql删除索引同样也有两种方式：alter table 和 drop index</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="built_in">table_name</span> <span class="keyword">drop</span> <span class="keyword">index</span> index_name    #删除一个普通索引</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="built_in">table_name</span> <span class="keyword">drop</span> <span class="keyword">primary key</span>         #删除一个主键索引</span><br></pre></td></tr></table></figure>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> index_name <span class="keyword">on</span> <span class="keyword">table</span> <span class="built_in">table_name</span></span><br></pre></td></tr></table></figure>
<h4 id="（7）-索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）"><a href="#（7）-索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）" class="headerlink" title="（7） 索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）"></a>（7） 索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wezheng/p/8399305.html">https://www.cnblogs.com/wezheng/p/8399305.html</a></p>
<ul>
<li>经常搜索的列上建索引</li>
<li>作为主键的列上要建索引</li>
<li>经常需要连接（where子句）的列上</li>
<li>经常需要排序的列</li>
<li>经常需要范围查找的列</li>
</ul>
<p>哪些列不适合建索引？</p>
<ul>
<li>很少查询的列</li>
<li>更新很频繁的列</li>
<li>数据值的取值比较少的列（比如性别）<h4 id="（8）-索引的底层实现（重点）"><a href="#（8）-索引的底层实现（重点）" class="headerlink" title="（8） 索引的底层实现（重点）"></a>（8） 索引的底层实现（重点）</h4>数据库的索引是使用B+树来实现的。</li>
</ul>
<p>（为什么要用B+树，为什么不用红黑树和B树）<br><br>B+树是一种特殊的平衡多路树，是B树的优化改进版本，它把所有的数据都存放在叶节点上，中间节点保存的是索引。这样一来相对于B树来说，减少了数据对中间节点的空间占用，使得中间节点可以存放更多的指针，使得树变得更矮，深度更小，从而减少查询的磁盘IO次数，提高查询效率。另一个是由于叶节点之间有指针连接，所以可以进行范围查询，方便区间访问。</p>
<p>而红黑树是二叉的，它的深度相对B+树来说更大，更大的深度意味着查找次数更多，更频繁的磁盘IO，所以红黑树更适合在内存中进行查找。</p>
<h4 id="（9）-B树和B-树的区别（重点）"><a href="#（9）-B树和B-树的区别（重点）" class="headerlink" title="（9） B树和B+树的区别（重点）"></a>（9） B树和B+树的区别（重点）</h4><p><img src="/./fig/Bptree.png" alt="./fig/Bptree.png"></p>
<p>这都是由于B+树和B具有不同的存储结构所造成的区别，以一个m阶树为例。</p>
<ol>
<li>关键字的数量不同；B+树中分支结点有m个关键字，其叶子结点也有m个，其关键字只是起到了一个索引的作用，但是B树虽然也有m个子结点，但是其只拥有m-1个关键字。</li>
<li>存储的位置不同；B+树中的数据都存储在叶子结点上，也就是其所有叶子结点的数据组合起来就是完整的数据，但是B树的数据存储在每一个结点中，并不仅仅存储在叶子结点上。</li>
<li>分支结点的构造不同；B+树的分支结点仅仅存储着关键字信息和儿子的指针（这里的指针指的是磁盘块的偏移量），也就是说内部结点仅仅包含着索引信息。</li>
<li>查询不同；B树在找到具体的数值以后，则结束，而B+树则需要通过索引找到叶子结点中的数据才结束，也就是说B+树的搜索过程中走了一条从根结点到叶子结点的路径。</li>
</ol>
<p>B+树优点：由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引，而B树则常用于文件索引。</p>
<h4 id="（10）-索引最左前缀-x2F-最左匹配"><a href="#（10）-索引最左前缀-x2F-最左匹配" class="headerlink" title="（10） 索引最左前缀&#x2F;最左匹配"></a>（10） 索引最左前缀&#x2F;最左匹配</h4><p>假如我们对a b c三个字段建立了联合索引，在联合索引中，从最左边的字段开始，任何连续的索引都能匹配上，当遇到范围查询的时候停止。比如对于联合索引index(a,b,c),能匹配a,ab,abc三组索引。并且对查询时字段的顺序没有限制，也就是a,b,c; b,a,c; c,a,b; c,b,a都可以匹配。</p>
<h4 id="（11）-Mysql的优化（高频，索引优化，性能优化）"><a href="#（11）-Mysql的优化（高频，索引优化，性能优化）" class="headerlink" title="（11） Mysql的优化（高频，索引优化，性能优化）"></a>（11） Mysql的优化（高频，索引优化，性能优化）</h4><p>高频访问：</p>
<ul>
<li>分表分库：将数据库表进行水平拆分，减少表的长度</li>
<li>增加缓存： 在web和DB之间加上一层缓存层</li>
<li>增加数据库的索引：在合适的字段加上索引，解决高频访问的问题</li>
</ul>
<p>并发优化：</p>
<ul>
<li>主从读写分离：只在主服务器上写，从服务器上读</li>
<li>负载均衡集群：通过集群或者分布式的方式解决并发压力<h4 id="（12）-MYSQL数据库引擎介绍，innodb和myisam的特点与区别"><a href="#（12）-MYSQL数据库引擎介绍，innodb和myisam的特点与区别" class="headerlink" title="（12） MYSQL数据库引擎介绍，innodb和myisam的特点与区别"></a>（12） MYSQL数据库引擎介绍，innodb和myisam的特点与区别</h4></li>
<li>InnoDB ： InnoDB是mysql的默认引擎，支持事务和外键，支持容灾恢复。适合更新频繁和多并发的表  行级锁</li>
<li>MyISAM ： 插入和查询速度比较高，支持大文件，但是不支持事务，适合在web和数据仓库场景下使用  表级锁</li>
<li>MEMORY ： memory将表中的数据保存在内存里，适合数据比较小而且频繁访问的场景</li>
<li>CSV</li>
<li>blackhole<h4 id="（13）-数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）"><a href="#（13）-数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）" class="headerlink" title="（13） 数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）"></a>（13） 数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）</h4>数据库事务是指逻辑上对数据的一种操作，这个事务要么全部成功，要么全部失败。</li>
</ul>
<p><strong>A: atom 原子性</strong><br><br>数据库事务的原子性是指：事务是一个不可分割的工作单位，这组操作要么全部发生，要么全部不发生。</p>
<p><strong>C: consistency 一致性</strong><br><br>数据库事务的一致性是指：在事务开始以前，数据库中的数据有一个一致的状态。在事务完成后，数据库中的事务也应该保持这种一致性。事务应该将数据从一个一致性状态转移到另一个一致性状态。<br>比如在银行转账操作后两个账户的总额应当不变。</p>
<p><strong>I: isolation 隔离性</strong><br><br>数据库事务的隔离性要求数据库中的事务不会受另一个并发执行的事务的影响，对于数据库中同时执行的每个事务来说，其他事务要么还没开始执行，要么已经执行结束，它都感觉不到还有别的事务正在执行。</p>
<p><strong>D：durability 持久性</strong><br><br>数据库事务的持久性要求事务对数据库的改变是永久的，哪怕数据库发生损坏都不会影响到已发生的事务。<br>如果事务没有完成，数据库因故断电了，那么重启后也应该是没有执行事务的状态，如果事务已经完成后数据库断电了，那么重启后就应该是事务执行完成后的状态。</p>
<h4 id="（14）什么是脏读，不可重复读和幻读？"><a href="#（14）什么是脏读，不可重复读和幻读？" class="headerlink" title="（14）什么是脏读，不可重复读和幻读？"></a>（14）什么是脏读，不可重复读和幻读？</h4><p>详见<a target="_blank" rel="noopener" href="https://blog.csdn.net/fuzhongmin05/article/details/91126936">数据库的事务隔离级别总结</a></p>
<ul>
<li>脏读：脏读是指一个事务在处理过程中读取了另一个还没提交的事务的数据。<blockquote>
<p>比如A向B转账100，A的账户减少了100，而B的账户还没来得及修改，此时一个并发的事务访问到了B的账户，就是脏读</p>
</blockquote>
</li>
<li>不可重复读：不可重复读是对于数据库中的某一个字段，一个事务多次查询却返回了不同的值，这是由于在查询的间隔中，该字段被另一个事务修改并提交了。<blockquote>
<p>比如A第一次查询自己的账户有1000元，此时另一个事务给A的账户增加了1000元，所以A再次读取他的账户得到了2000的结果，跟第一次读取的不一样。<br>不可重复读与脏读的不同之处在于，脏读是读取了另一个事务没有提交的脏数据，不可重复读是读取了已经提交的数据，实际上并不是一个异常现象。</p>
</blockquote>
</li>
<li>幻读：事务多次读取同一个范围的时候，查询结果的记录数不一样，这是由于在查询的间隔中，另一个事务新增或删除了数据。<blockquote>
<p>比如A公司一共有100个人，第一次查询总人数得到100条记录，此时另一个事务新增了一个人，所以下一次查询得到101条记录。<br>不可重复度和幻读的不同之处在于，幻读是多次读取的结果行数不同，不可重复度是读取结果的值不同。</p>
</blockquote>
</li>
</ul>
<p>避免不可重复读需要锁行，避免幻读则需要锁表。</p>
<p>脏读，不可重复读和幻读都是数据库的读一致性问题，是在并行的过程中出现的问题，必须采用一定的隔离级别解决。<br>详见<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Hakuna-Matata/p/7772794.html">脏读、不可重复读和幻读的区别</a></p>
<h4 id="（15）-数据库的隔离级别，mysql和Oracle的隔离级别分别是什么（重点）"><a href="#（15）-数据库的隔离级别，mysql和Oracle的隔离级别分别是什么（重点）" class="headerlink" title="（15） 数据库的隔离级别，mysql和Oracle的隔离级别分别是什么（重点）"></a>（15） 数据库的隔离级别，mysql和Oracle的隔离级别分别是什么（重点）</h4><p>详见<a target="_blank" rel="noopener" href="https://blog.csdn.net/fuzhongmin05/article/details/91126936">数据库的事务隔离级别总结</a>和<a target="_blank" rel="noopener" href="https://blog.csdn.net/fg2006/article/details/6937413">数据库隔离级别</a></p>
<p>为了保证数据库事务一致性，解决脏读，不可重复读和幻读的问题，数据库的隔离级别一共有四种隔离级别：</p>
<ul>
<li>读未提交 Read Uncommitted: 最低级别的隔离，不能解决以上问题</li>
<li>读已提交 Read committed:   可以避免脏读的发生 </li>
<li>可重复读 Reapeatable read:  确保事务可以多次从一个字段中读取相同的值，在该事务执行期间，禁止其他事务对此字段的更新，可以避免脏读和不可重复读。 通过锁行来实现 </li>
<li>串行化 Serializaion  最严格的事务隔离机制，要求所有事务被串行执行，可以避免以上所有问题。 通过锁表来实现</li>
</ul>
<p>Oracle的默认隔离级别是<strong>读已提交</strong>，实现了四种隔离级别中的读已提交和串行化隔离级别</p>
<p>MySQL的默认隔离级别是<strong>可重复读</strong>，并且实现了所有四种隔离级别</p>
<h4 id="（16）-数据库连接池的作用"><a href="#（16）-数据库连接池的作用" class="headerlink" title="（16） 数据库连接池的作用"></a>（16） 数据库连接池的作用</h4><h4 id="（17）-Mysql的表空间方式，各自特点"><a href="#（17）-Mysql的表空间方式，各自特点" class="headerlink" title="（17） Mysql的表空间方式，各自特点"></a>（17） Mysql的表空间方式，各自特点</h4><ul>
<li><p>共享表空间：指的是数据库的所有的表数据，索引文件全部放在一个文件中，默认这个共享表空间的文件路径在 data 目录下。 </p>
</li>
<li><p>独立表空间：每一个表都将会生成以独立的文件方式来进行存储。 优点：当表被删除时这部分空间可以被回收；可以更快的恢复和备份单个表；将单个表复制到另一个实例会很方便； 缺点：mysqld会维持很多文件句柄，表太多会影响性能。如果很多表都增长会导致碎片问题</p>
<h4 id="（18）-分布式事务"><a href="#（18）-分布式事务" class="headerlink" title="（18） 分布式事务"></a>（18） 分布式事务</h4><h4 id="（19）-数据库的范式"><a href="#（19）-数据库的范式" class="headerlink" title="（19） 数据库的范式"></a>（19） 数据库的范式</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html">https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html</a></p>
</li>
<li><p><strong>第一范式(确保每列保持原子性)</strong><br><br>第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。</p>
</li>
</ul>
<blockquote>
<p>比如 学生 选课（包括很多课程） 就不符合第一范式</p>
</blockquote>
<ul>
<li><strong>第二范式(确保表中的每列都和主键相关)</strong><br><br>在满足第一范式的前提下，（主要针对联合主键而言）第二范式需要确保数据库表中的每一列都和主键的所有成员直接相关，由整个主键才能唯一确定，而不能只与主键的某一部分相关或者不相关。</li>
</ul>
<blockquote>
<p>比如一张学生信息表，由主键（学号）可以唯一确定一个学生的姓名，班级，年龄等信息。但是主键 （学号，班级） 与列 姓名，班主任，教室 就不符合第二范式，因为班主任跟部分主键（班级）是依赖关系</p>
</blockquote>
<ul>
<li><strong>第三范式(确保非主键的列没有传递依赖)</strong><br><br>在满足第二范式的前提下，第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。非主键的列不能确定其他列，列与列之间不能出现传递依赖。</li>
</ul>
<blockquote>
<p>比如一张学生信息表，主键是（学号）列包括 姓名，班级，班主任 就不符合第三范式，因为非主键的列中 班主任 依赖于 班级</p>
</blockquote>
<ul>
<li><p><strong>BCNF范式（确保主键之间没有传递依赖）</strong><br><br>主键有可能是由多个属性组合成的复合主键，那么多个主键之间不能有传递依赖。也就是复合主键之间谁也不能决定谁，相互之间没有关系。</p>
<h4 id="（20）-数据的锁的种类，加锁的方式"><a href="#（20）-数据的锁的种类，加锁的方式" class="headerlink" title="（20） 数据的锁的种类，加锁的方式"></a>（20） 数据的锁的种类，加锁的方式</h4><p>以MYSQL为例，</p>
</li>
<li><p>按照类型来分有乐观锁和悲观锁</p>
</li>
<li><p>根据粒度来分有行级锁，页级锁，表级锁（粒度一个比一个大） （仅BDB，Berkeley Database支持页级锁）</p>
</li>
<li><p>根据作用来分有共享锁（读锁）和排他锁（写锁）。</p>
<h4 id="（21）-什么是共享锁和排他锁"><a href="#（21）-什么是共享锁和排他锁" class="headerlink" title="（21） 什么是共享锁和排他锁"></a>（21） 什么是共享锁和排他锁</h4></li>
<li><p>共享锁是读操作的时候创建的锁，一个事务对数据加上共享锁之后，其他事务只能对数据再加共享锁，不能进行写操作直到释放所有共享锁。</p>
</li>
<li><p>排他锁是写操作时创建的锁，事务对数据加上排他锁之后其他任何事务都不能对数据加任何的锁（即其他事务不能再访问该数据）</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42743933/article/details/81236658">https://blog.csdn.net/qq_42743933/article/details/81236658</a></p>
</li>
</ul>
<h4 id="（22）-分库分表的理解和简介"><a href="#（22）-分库分表的理解和简介" class="headerlink" title="（22） 分库分表的理解和简介"></a>（22） 分库分表的理解和简介</h4><h4 id="（23）"><a href="#（23）" class="headerlink" title="（23）"></a>（23）</h4><h4 id="（24）数据库高并发的解决方案"><a href="#（24）数据库高并发的解决方案" class="headerlink" title="（24）数据库高并发的解决方案"></a>（24）数据库高并发的解决方案</h4><ol>
<li>在web服务框架中加入缓存。在服务器与数据库层之间加入缓存层，将高频访问的数据存入缓存中，减少数据库的读取负担。</li>
<li>增加数据库索引。提高查询速度。（不过索引太多会导致速度变慢，并且数据库的写入会导致索引的更新，也会导致速度变慢）</li>
<li>主从读写分离，让主服务器负责写，从服务器负责读。</li>
<li>将数据库进行拆分，使得数据库的表尽可能小，提高查询的速度。</li>
<li>使用分布式架构，分散计算压力。<h4 id="（25）乐观锁与悲观锁解释一下"><a href="#（25）乐观锁与悲观锁解释一下" class="headerlink" title="（25）乐观锁与悲观锁解释一下"></a>（25）乐观锁与悲观锁解释一下</h4>一般的数据库都会支持并发操作，在并发操作中为了避免数据冲突，所以需要对数据上锁，乐观锁和悲观锁就是两种不同的上锁方式。</li>
</ol>
<p>悲观锁假设数据在并发操作中一定会发生冲突，所以在数据开始读取的时候就把数据锁住。而乐观锁则假设数据一般情况下不会发生冲突，所以在数据提交更新的时候，才会检测数据是否有冲突。</p>
<h4 id="（26）乐观锁与悲观锁是怎么实现的"><a href="#（26）乐观锁与悲观锁是怎么实现的" class="headerlink" title="（26）乐观锁与悲观锁是怎么实现的"></a>（26）乐观锁与悲观锁是怎么实现的</h4><p>悲观锁有行级锁和页级锁两种形式。行级锁对正在使用的单条数据进行锁定，事务完成后释放该行数据，而页级锁则对整张表进行锁定，事务正在对该表进行访问的时候不允许其他事务并行访问。</p>
<p>悲观锁要求在整个过程中一直与数据库有一条连接，因为上一个事务完成后才能让下一个事务执行，这个过程是串行的。</p>
<p>乐观锁有三种常用的实现形式：</p>
<ul>
<li>一种是在执行事务时把整个数据都拷贝到应用中，在数据更新提交的时候比较数据库中的数据与新数据，如果两个数据一摸一样则表示没有冲突可以直接提交，如果有冲突就要交给业务逻辑去解决。</li>
<li>一种是使用版本戳来对数据进行标记，数据每发生一次修改，版本号就增加1。某条数据在提交的时候，如果数据库中的版本号与自己的一致，就说明数据没有发生修改，否则就认为是过期数据需要处理。</li>
<li>最后一种采用时间戳对数据最后修改的时间进行标记。与上一种类似。</li>
</ul>
<h4 id="（27）对数据库目前最新技术有什么了解吗"><a href="#（27）对数据库目前最新技术有什么了解吗" class="headerlink" title="（27）对数据库目前最新技术有什么了解吗"></a>（27）对数据库目前最新技术有什么了解吗</h4><h1 id="4-Linux"><a href="#4-Linux" class="headerlink" title="4. Linux"></a>4. Linux</h1><h4 id="（1）-Linux的I-x2F-O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）"><a href="#（1）-Linux的I-x2F-O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）" class="headerlink" title="（1） Linux的I&#x2F;O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）"></a>（1） Linux的I&#x2F;O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sqsltr/article/details/92762279">https://blog.csdn.net/sqsltr/article/details/92762279</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/euphie/p/6376508.html">https://www.cnblogs.com/euphie/p/6376508.html</a></p>
<p>（IO过程包括两个阶段：（1）内核从IO设备读写数据和（2）进程从内核复制数据）</p>
<ul>
<li><p>阻塞：调用IO操作的时候，如果缓冲区空或者满了，调用的进程或者线程就会处于阻塞状态直到IO可用并完成数据拷贝。</p>
</li>
<li><p>非阻塞：调用IO操作的时候，内核会马上返回结果，如果IO不可用，会返回错误，这种方式下进程需要不断轮询直到IO可用为止，但是当进程从内核拷贝数据时是阻塞的。</p>
</li>
<li><p>IO多路复用就是同时监听多个描述符，一旦某个描述符IO就绪（读就绪或者写就绪），就能够通知进程进行相应的IO操作，否则就将进程阻塞在select或者epoll语句上。</p>
</li>
<li><p>同步IO：同步IO模型包括阻塞IO，非阻塞IO和IO多路复用。特点就是当进程从内核复制数据的时候都是阻塞的。</p>
</li>
<li><p>异步IO：在检测IO是否可用和进程拷贝数据的两个阶段都是不阻塞的，进程可以做其他事情，当IO完成后内核会给进程发送一个信号。</p>
<h4 id="（2）-文件系统的理解（EXT4，XFS，BTRFS）"><a href="#（2）-文件系统的理解（EXT4，XFS，BTRFS）" class="headerlink" title="（2） 文件系统的理解（EXT4，XFS，BTRFS）"></a>（2） 文件系统的理解（EXT4，XFS，BTRFS）</h4><h4 id="（3）-EPOLL的介绍和了解"><a href="#（3）-EPOLL的介绍和了解" class="headerlink" title="（3） EPOLL的介绍和了解"></a>（3） EPOLL的介绍和了解</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/56486633">https://zhuanlan.zhihu.com/p/56486633</a></p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/397449cadc9a">https://www.jianshu.com/p/397449cadc9a</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/davidsguo008/article/details/73556811">https://blog.csdn.net/davidsguo008/article/details/73556811</a></p>
<p>Epoll是Linux进行IO多路复用的一种方式，用于在一个线程里监听多个IO源，在IO源可用的时候返回并进行操作。它的特点是基于事件驱动，性能很高。</p>
<p>epoll将文件描述符拷贝到内核空间后使用红黑树进行维护，同时向内核注册每个文件描述符的回调函数，当某个文件描述符可读可写的时候，将这个文件描述符加入到就绪链表里，并唤起进程，返回就绪链表到用户空间，由用户程序进行处理。</p>
<p>Epoll有三个系统调用：epoll_create(),epoll_ctl()和epoll_wait()。</p>
<ul>
<li><p>eoll_create()函数在内核中初始化一个eventpoll对象，同时初始化红黑树和就绪链表。</p>
</li>
<li><p>epoll_ctl()用来对监听的文件描述符进行管理。将文件描述符插入红黑树，或者从红黑树中删除，这个过程的时间复杂度是log(N)。同时向内核注册文件描述符的回调函数。</p>
</li>
<li><p>epoll_wait()会将进程放到eventpoll的等待队列中，将进程阻塞，当某个文件描述符IO可用时，内核通过回调函数将该文件描述符放到就绪链表里，epoll_wait()会将就绪链表里的文件描述符返回到用户空间。</p>
<h4 id="（4）-IO复用的三种方法（select-poll-epoll）深入理解，包括三者区别，内部原理实现？"><a href="#（4）-IO复用的三种方法（select-poll-epoll）深入理解，包括三者区别，内部原理实现？" class="headerlink" title="（4） IO复用的三种方法（select,poll,epoll）深入理解，包括三者区别，内部原理实现？"></a>（4） IO复用的三种方法（select,poll,epoll）深入理解，包括三者区别，内部原理实现？</h4><p>（1）select的方法介绍：select把所有监听的文件描述符拷贝到内核中，挂起进程。当某个文件描述符可读或可写的时候，中断程序唤起进程，select将监听的文件描述符再次拷贝到用户空间，然select后遍历这些文件描述符找到IO可用的文件。下次监控的时候需要再次拷贝这些文件描述符到内核空间。select支持监听的描述符最大数量是1024.<br><img src="/fig/select.png" alt="select"><br>（2）poll使用链表保存文件描述符，其他的跟select没有什么不同。</p>
</li>
</ul>
<p>（3）epoll将文件描述符拷贝到内核空间后使用红黑树进行维护，同时向内核注册每个文件描述符的回调函数，当某个文件描述符可读可写的时候，将这个文件描述符加入到就绪链表里，并唤起进程，返回就绪链表到用户空间。<br><img src="/fig/epoll.png" alt="epoll"><br>详见 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/Anker/p/3265058.html">https://www.cnblogs.com/Anker/p/3265058.html</a></p>
<h4 id="（5）-Epoll的ET模式和LT模式（ET的非阻塞）"><a href="#（5）-Epoll的ET模式和LT模式（ET的非阻塞）" class="headerlink" title="（5） Epoll的ET模式和LT模式（ET的非阻塞）"></a>（5） Epoll的ET模式和LT模式（ET的非阻塞）</h4><ul>
<li>ET是边缘触发模式，在这种模式下，只有当描述符从未就绪变成就绪时，内核才会通过epoll进行通知。然后直到下一次变成就绪之前，不会再次重复通知。也就是说，如果一次就绪通知之后不对这个描述符进行IO操作导致它变成未就绪，内核也不会再次发送就绪通知。优点就是只通知一次，减少内核资源浪费，效率高。缺点就是不能保证数据的完整，有些数据来不及读可能就会无法取出。</li>
<li>LT是水平触发模式，在这个模式下，如果文件描述符IO就绪，内核就会进行通知，如果不对它进行IO操作，只要还有未操作的数据，内核都会一直进行通知。优点就是可以确保数据可以完整输出。缺点就是由于内核会一直通知，会不停从内核空间切换到用户空间，资源浪费严重。<h4 id="（6）-查询进程占用CPU的命令（注意要了解到used，buf，代表意义）"><a href="#（6）-查询进程占用CPU的命令（注意要了解到used，buf，代表意义）" class="headerlink" title="（6） 查询进程占用CPU的命令（注意要了解到used，buf，代表意义）"></a>（6） 查询进程占用CPU的命令（注意要了解到used，buf，代表意义）</h4>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36357820/article/details/76606113">https://blog.csdn.net/qq_36357820/article/details/76606113</a></li>
</ul>
<ol>
<li>top命令查看linux负载：</li>
<li>uptime查看linux负载</li>
<li>w查看linux负载：</li>
<li>vmstat查看linux负载<h4 id="（7）-linux的其他常见命令（kill，find，cp等等）"><a href="#（7）-linux的其他常见命令（kill，find，cp等等）" class="headerlink" title="（7） linux的其他常见命令（kill，find，cp等等）"></a>（7） linux的其他常见命令（kill，find，cp等等）</h4><h4 id="（8）-shell脚本用法"><a href="#（8）-shell脚本用法" class="headerlink" title="（8） shell脚本用法"></a>（8） shell脚本用法</h4><h4 id="（9）-硬连接和软连接的区别"><a href="#（9）-硬连接和软连接的区别" class="headerlink" title="（9） 硬连接和软连接的区别"></a>（9） 硬连接和软连接的区别</h4><h4 id="（10）-文件权限怎么看（rwx）"><a href="#（10）-文件权限怎么看（rwx）" class="headerlink" title="（10） 文件权限怎么看（rwx）"></a>（10） 文件权限怎么看（rwx）</h4><h4 id="（11）-文件的三种时间（mtime-atime，ctime），分别在什么时候会改变"><a href="#（11）-文件的三种时间（mtime-atime，ctime），分别在什么时候会改变" class="headerlink" title="（11） 文件的三种时间（mtime, atime，ctime），分别在什么时候会改变"></a>（11） 文件的三种时间（mtime, atime，ctime），分别在什么时候会改变</h4><h4 id="（12）-Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令"><a href="#（12）-Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令" class="headerlink" title="（12） Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令"></a>（12） Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令</h4><h4 id="（13）Linux中线程的同步方式有哪些？"><a href="#（13）Linux中线程的同步方式有哪些？" class="headerlink" title="（13）Linux中线程的同步方式有哪些？"></a>（13）Linux中线程的同步方式有哪些？</h4><h4 id="（14）怎么修改一个文件的权限"><a href="#（14）怎么修改一个文件的权限" class="headerlink" title="（14）怎么修改一个文件的权限"></a>（14）怎么修改一个文件的权限</h4>chmod 777  (177 277 477 等，权限组合是 1 2 4，分别代表r x w )<h4 id="（15）查看文件内容常用命令"><a href="#（15）查看文件内容常用命令" class="headerlink" title="（15）查看文件内容常用命令"></a>（15）查看文件内容常用命令</h4>详见： <a target="_blank" rel="noopener" href="http://blog.sina.com.cn/s/blog_7b4ce6b101018l8l.html">http://blog.sina.com.cn/s/blog_7b4ce6b101018l8l.html</a></li>
<li>cat 与 tac<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span>的功能是将文件从第一行开始连续的将内容输出在屏幕上。当文件大，行数比较多时，屏幕无法全部容下时，只能看到一部分内容。所以通常使用重定向的方式，输出满足指定格式的内容</span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span>语法：<span class="built_in">cat</span> [-n]  文件名 （-n ： 显示时，连行号一起输出）</span><br><span class="line"></span><br><span class="line"><span class="built_in">tac</span>的功能是将文件从最后一行开始倒过来将内容数据输出到屏幕上。我们可以发现，<span class="built_in">tac</span>实际上是<span class="built_in">cat</span>反过来写。这个命令不常用。</span><br><span class="line"></span><br><span class="line"><span class="built_in">tac</span>语法：<span class="built_in">tac</span> 文件名。</span><br></pre></td></tr></table></figure></li>
<li>more和less（常用）<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">more的功能是将文件从第一行开始，根据输出窗口的大小，适当的输出文件内容。当一页无法全部输出时，可以用“回车键”向下翻行，用“空格键”向下翻页。退出查看页面，请按“q”键。另外，more还可以配合管道符“|”（pipe）使用，例如<span class="symbol">:ls</span> -al | more</span><br><span class="line"></span><br><span class="line">more的语法：more 文件名</span><br><span class="line"></span><br><span class="line">Enter 向下<span class="built_in">n</span>行，需要定义，默认为<span class="number">1</span>行； </span><br><span class="line"></span><br><span class="line">Ctrl f 向下滚动一屏； </span><br><span class="line"></span><br><span class="line">空格键 向下滚动一屏； </span><br><span class="line"></span><br><span class="line">Ctrl b 返回上一屏； </span><br><span class="line"></span><br><span class="line">= 输出当前行的行号； </span><br><span class="line"></span><br><span class="line"><span class="symbol">:f</span> 输出文件名和当前行的行号； </span><br><span class="line"></span><br><span class="line">v 调用vi编辑器； </span><br><span class="line"></span><br><span class="line">! 命令 调用Shell，并执行命令； </span><br><span class="line"></span><br><span class="line">q 退出more</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">less的功能和more相似，但是使用more无法向前翻页，只能向后翻。</span><br><span class="line"></span><br><span class="line">less可以使用【pageup】和【pagedown】键进行前翻页和后翻页，这样看起来更方便。</span><br><span class="line"></span><br><span class="line">less的语法：less 文件名</span><br></pre></td></tr></table></figure></li>
<li>head和tail<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">head<span class="built_in">和tail</span>通常使用在只需要读取文件的前几行或者后几行的情况下使用<span class="built_in">。head</span>的功能是显示文件的前几行内容</span><br><span class="line"><span class="built_in"></span></span><br><span class="line"><span class="built_in">head</span>的语法<span class="built_in">：head</span> [n<span class="built_in"> number</span>] 文件名 <span class="built_in">(number</span> 显示行数)</span><br><span class="line"><span class="built_in"></span></span><br><span class="line"><span class="built_in">tail</span>的功能恰好<span class="built_in">和head</span>相反，只显示最后几行内容</span><br><span class="line"><span class="built_in"></span></span><br><span class="line"><span class="built_in">tail</span>的语法:tail [-n<span class="built_in"> number</span>] 文件名</span><br></pre></td></tr></table></figure></li>
<li>nl<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nl</span>的功能和<span class="built_in">cat</span> -n一样，同样是从第一行输出全部内容，并且把行号显示出来</span><br><span class="line"></span><br><span class="line"><span class="built_in">nl</span>的语法：<span class="built_in">nl</span> 文件名</span><br></pre></td></tr></table></figure></li>
<li>vim</li>
</ol>
<p>这个用的太普遍了，主要是用于编辑。</p>
<h4 id="（16）怎么找出含有关键字的前后4行"><a href="#（16）怎么找出含有关键字的前后4行" class="headerlink" title="（16）怎么找出含有关键字的前后4行"></a>（16）怎么找出含有关键字的前后4行</h4><h4 id="（17）Linux的GDB调试"><a href="#（17）Linux的GDB调试" class="headerlink" title="（17）Linux的GDB调试"></a>（17）Linux的GDB调试</h4><h4 id="（18）coredump是什么-怎么才能coredump"><a href="#（18）coredump是什么-怎么才能coredump" class="headerlink" title="（18）coredump是什么 怎么才能coredump"></a>（18）coredump是什么 怎么才能coredump</h4><p>coredump是程序由于异常或者bug在运行时异常退出或者终止，在一定的条件下生成的一个叫做core的文件，这个core文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。</p>
<p>coredump产生的条件</p>
<ol>
<li>shell资源控制限制，使用 ulimit -c 命令查看shell执行程序时的资源 ，如果为0，则不会产生coredump。可以用ulimit -c unlimited设置为不限大小。</li>
<li>读写越界，包括：数组访问越界，指针指向错误的内存，字符串读写越界</li>
<li>使用了线程不安全的函数，读写未加锁保护</li>
<li>错误使用指针转换</li>
<li>堆栈溢出<h4 id="（19）tcpdump常用命令"><a href="#（19）tcpdump常用命令" class="headerlink" title="（19）tcpdump常用命令"></a>（19）tcpdump常用命令</h4>用简单的话来定义tcpdump，就是：dump the traffic on a network，根据使用者的定义对网络上的数据包进行截获的包分析工具。 tcpdump可以将网络中传送的数据包的“头”完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息。</li>
</ol>
<p>实用命令实例</p>
<p>将某端口收发的数据包保存到文件<br><br><code>sudo tcpdump -i any port 端口 -w 文件名.cap</code></p>
<p>打印请求到屏幕<br><br><code>sudo tcpdump -i any port 端口 -Xnlps0</code></p>
<p>默认启动<br><br><code>tcpdump</code><br>普通情况下，直接启动tcpdump将监视第一个网络接口上所有流过的数据包。<br>监视指定网络接口的数据包<br><br><code>tcpdump -i eth1</code><br>如果不指定网卡，默认tcpdump只会监视第一个网络接口，一般是eth0，下面的例子都没有指定网络接口。　</p>
<h4 id="（20）-crontab命令"><a href="#（20）-crontab命令" class="headerlink" title="（20） crontab命令"></a>（20） crontab命令</h4><p>详见：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/peida/archive/2013/01/08/2850483.html">https://www.cnblogs.com/peida/archive/2013/01/08/2850483.html</a></p>
<p>corntab命令是用来指定用户计划任务的。用户将需要定时执行的任务写入crontab文件中，提交给crond进程定期执行。</p>
<ul>
<li><p>crontab命令用来对crontab文件进行管理</p>
<figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>．命令格式：</span><br><span class="line">crontab [-u <span class="literal">user</span>] <span class="keyword">file</span></span><br><span class="line">crontab [-u <span class="literal">user</span>] [ -e | -l | -r ]</span><br><span class="line"><span class="number">2</span>．命令功能：</span><br><span class="line">通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常设合周期性的日志分析或数据备份等工作。</span><br><span class="line"><span class="number">3</span>．命令参数：</span><br><span class="line">-u <span class="literal">user</span>：用来设定某个用户的crontab服务，例如，“-u ixdba”表示设定ixdba用户的crontab服务，此参数一般有root用户来运行。</span><br><span class="line"><span class="keyword">file</span>：<span class="keyword">file</span>是命令文件的名字,表示将<span class="keyword">file</span>做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。</span><br><span class="line">-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。</span><br><span class="line">-l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。</span><br><span class="line">-r：从/<span class="keyword">var</span>/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。</span><br><span class="line">-i：在删除用户的crontab文件时给确认提示。</span><br></pre></td></tr></table></figure>
</li>
<li><p>crontab文件内容</p>
</li>
</ul>
<p>crond是Linux下的周期性执行系统任务的守护进程，他会根据&#x2F;etc下的crontab配置文件的内容执行。用户需要将计划任务写入crontab文件中才能执行。</p>
<p>用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">minute</span>   <span class="built_in">hour</span>   <span class="built_in">day</span>   <span class="built_in">month</span>   <span class="built_in">week</span>   command</span><br><span class="line"></span><br><span class="line">其中：</span><br><span class="line"><span class="built_in">minute</span>： 表示分钟，可以是从<span class="number">0</span>到<span class="number">59</span>之间的任何整数。</span><br><span class="line"><span class="built_in">hour</span>：表示小时，可以是从<span class="number">0</span>到<span class="number">23</span>之间的任何整数。</span><br><span class="line"><span class="built_in">day</span>：表示日期，可以是从<span class="number">1</span>到<span class="number">31</span>之间的任何整数。</span><br><span class="line"><span class="built_in">month</span>：表示月份，可以是从<span class="number">1</span>到<span class="number">12</span>之间的任何整数。</span><br><span class="line"><span class="built_in">week</span>：表示星期几，可以是从<span class="number">0</span>到<span class="number">7</span>之间的任何整数，这里的<span class="number">0</span>或<span class="number">7</span>代表星期日。</span><br><span class="line">command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。</span><br><span class="line">在以上各个字段中，还可以使用以下特殊字符：</span><br><span class="line">星号（*）：代表所有可能的值，例如<span class="built_in">month</span>字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。</span><br><span class="line">逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>”</span><br><span class="line">中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“<span class="number">2</span><span class="number">-6</span>”表示“<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>”</span><br><span class="line">正斜线（/）：可以用正斜线指定时间的间隔频率，例如“<span class="number">0</span><span class="number">-23</span>/<span class="number">2</span>”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/<span class="number">10</span>，如果用在<span class="built_in">minute</span>字段，表示每十分钟执行一次。</span><br></pre></td></tr></table></figure>
<h4 id="（21）-查看后台进程"><a href="#（21）-查看后台进程" class="headerlink" title="（21） 查看后台进程"></a>（21） 查看后台进程</h4><ul>
<li>jobs</li>
</ul>
<p>查看当前控制台的后台进程</p>
<p>想要停止后台进程，使用jobs命令查看其进程号（比如为num），然后kill %num即可</p>
<ul>
<li>ps</li>
</ul>
<p>查看后台进程</p>
<ul>
<li>top</li>
</ul>
<p>查看所有进程和资源使用情况，类似Windows中的任务管理器</p>
<p>停止进程：界面是交互式的，在窗口输入k 之后输入PID，会提示输入停止进程模式 有SIGTERM和 SIGKILL 如果留空不输入，就是SIGTERM（优雅停止）</p>
<p>退出top：输入q即可</p>
<h1 id="5-操作系统"><a href="#5-操作系统" class="headerlink" title="5. 操作系统"></a>5. 操作系统</h1><h4 id="（1）-进程与线程的区别和联系（重点）"><a href="#（1）-进程与线程的区别和联系（重点）" class="headerlink" title="（1） 进程与线程的区别和联系（重点）"></a>（1） 进程与线程的区别和联系（重点）</h4><ul>
<li>区别</li>
</ul>
<ol>
<li>进程是对运行时程序的封装，是系统进行资源分配和调度的基本单元，而线程是进程的子任务，是CPU分配和调度的基本单元。</li>
<li>一个进程可以有多个线程，但是一个线程只能属于一个进程。</li>
<li>进程的创建需要系统分配内存和CPU，文件句柄等资源，销毁时也要进行相应的回收，所以进程的管理开销很大；但是线程的管理开销则很小。</li>
<li>进程之间不会相互影响；而一个线程崩溃会导致进程崩溃，从而影响同个进程里面的其他线程。</li>
</ol>
<ul>
<li>联系 进程与线程之间的关系：线程是存在进程的内部，一个进程中可以有多个线程，一个线程只能存在一个进程中。<h4 id="（2）-Linux理论上最多可以创建多少个进程？一个进程可以创建多少线程，和什么有关"><a href="#（2）-Linux理论上最多可以创建多少个进程？一个进程可以创建多少线程，和什么有关" class="headerlink" title="（2） Linux理论上最多可以创建多少个进程？一个进程可以创建多少线程，和什么有关"></a>（2） Linux理论上最多可以创建多少个进程？一个进程可以创建多少线程，和什么有关</h4>答：32768. 因为进程的pid是用pid_t来表示的，pid_t的最大值是32768.所以理论上最多有32768个进程。</li>
</ul>
<p>至于线程。进程最多可以创建的线程数是根据分配给调用栈的大小，以及操作系统（32位和64位不同）共同决定的。Linux32位下是300多个。</p>
<h4 id="（3）-冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）"><a href="#（3）-冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）" class="headerlink" title="（3） 冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）"></a>（3） 冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）</h4><ul>
<li><p>存储器：内存</p>
</li>
<li><p>控制器：南桥北桥</p>
</li>
<li><p>运算器：CPU</p>
</li>
<li><p>输入设备：键盘</p>
</li>
<li><p>输出设备：显示器、网卡</p>
<h4 id="（4）-进程之间的通信方法有哪几种-（重点）"><a href="#（4）-进程之间的通信方法有哪几种-（重点）" class="headerlink" title="（4） 进程之间的通信方法有哪几种 （重点）"></a>（4） 进程之间的通信方法有哪几种 （重点）</h4><p>进程之间的通信方式主要有六种，包括<strong>管道，信号量，消息队列，信号，共享内存，套接字</strong>。</p>
</li>
<li><p>管道：管道是半双工的，双方需要通信的时候，需要建立两个管道。管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据：管道一端的进程顺序地将进程数据写入缓冲区，另一端的进程则顺序地读取数据，该缓冲区可以看做一个循环队列，读和写的位置都是自动增加的，一个数据只能被读一次，读出以后再缓冲区都不复存在了。当缓冲区读空或者写满时，有一定的规则控制相应的读进程或写进程是否进入等待队列，当空的缓冲区有新数据写入或慢的缓冲区有数据读出时，就唤醒等待队列中的进程继续读写。管道是最容易实现的<br><img src="/fig/%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1.png" alt="fig/管道通信.png"></p>
<p>匿名管道pipe和命名管道除了建立，打开，删除的方式不同外，其余都是一样的。匿名管道只允许有亲缘关系的进程之间通信，也就是父子进程之间的通信，命名管道允许具有非亲缘关系的进程间通信。</p>
<p>管道的底层实现 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000009528245">https://segmentfault.com/a/1190000009528245</a></p>
</li>
<li><p>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。信号量只有等待和发送两种操作。等待(P(sv))就是将其值减一或者挂起进程，发送(V(sv))就是将其值加一或者将进程恢复运行。</p>
</li>
<li><p>信号：信号是Linux系统中用于进程之间通信或操作的一种机制，信号可以在任何时候发送给某一进程，而无须知道该进程的状态。如果该进程并未处于执行状态，则该信号就由内核保存起来，知道该进程恢复执行并传递给他为止。如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程。 信号是开销最小的</p>
</li>
<li><p>共享内存：共享内存允许两个或多个进程共享一个给定的存储区，这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中，就像由malloc()分配的内存一样使用。一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取读出，从而实现了进程间的通信。共享内存的效率最高，缺点是没有提供同步机制，需要使用锁等其他机制进行同步。</p>
</li>
<li><p>消息队列：消息队列就是一个消息的链表，是一系列保存在内核中消息的列表。用户进程可以向消息队列添加消息，也可以向消息队列读取消息。<br>消息队列与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。<br>可以把消息看做一个记录，具有特定的格式以及特定的优先级。对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息，对消息队列有读权限的进程可以从消息队列中读取消息。</p>
</li>
<li><p>套接字：套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。</p>
<h4 id="（5）-进程调度方法详细介绍"><a href="#（5）-进程调度方法详细介绍" class="headerlink" title="（5） 进程调度方法详细介绍"></a>（5） 进程调度方法详细介绍</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011080472/article/details/51217754">https://blog.csdn.net/u011080472/article/details/51217754</a></p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/leex_brave/article/details/51638300">https://blog.csdn.net/leex_brave/article/details/51638300</a></p>
<ul>
<li>先来先服务 （FCFS first come first serve）：按照作业到达任务队列的顺序调度  FCFS是非抢占式的，易于实现，效率不高，性能不好，有利于长作业（CPU繁忙性）而不利于短作业（I&#x2F;O繁忙性）。</li>
<li>短作业优先 （SHF short job first）：每次从队列里选择预计时间最短的作业运行。SJF是非抢占式的，优先照顾短作业，具有很好的性能，降低平均等待时间，提高吞吐量。但是不利于长作业，长作业可能一直处于等待状态，出现饥饿现象；完全未考虑作业的优先紧迫程度，不能用于实时系统。</li>
<li>最短剩余时间优先 该算法首先按照作业的服务时间挑选最短的作业运行，在该作业运行期间，一旦有新作业到达系统，并且该新作业的服务时间比当前运行作业的剩余服务时间短，则发生抢占；否则，当前作业继续运行。该算法确保一旦新的短作业或短进程进入系统，能够很快得到处理。</li>
<li>高响应比优先调度算法（Highest Reponse Ratio First, HRRF）是非抢占式的，主要用于作业调度。基本思想：每次进行作业调度时，先计算后备作业队列中每个作业的响应比，挑选最高的作业投入系统运行。响应比 &#x3D; （等待时间 + 服务时间） &#x2F; 服务时间 &#x3D; 等待时间 &#x2F; 服务时间 + 1。因为每次都需要计算响应比，所以比较耗费系统资源。</li>
<li>时间片轮转 用于分时系统的进程调度。基本思想：系统将CPU处理时间划分为若干个时间片（q），进程按照到达先后顺序排列。每次调度选择队首的进程，执行完1个时间片q后，计时器发出时钟中断请求，该进程移至队尾。以后每次调度都是如此。该算法能在给定的时间内响应所有用户的而请求，达到分时系统的目的。</li>
<li>多级反馈队列(Multilevel Feedback Queue) <h4 id="（6）-进程的执行过程是什么样的，执行一个进程需要做哪些工作？"><a href="#（6）-进程的执行过程是什么样的，执行一个进程需要做哪些工作？" class="headerlink" title="（6） 进程的执行过程是什么样的，执行一个进程需要做哪些工作？"></a>（6） 进程的执行过程是什么样的，执行一个进程需要做哪些工作？</h4>进程的执行需要经过三大步骤：编译，链接和装入。</li>
<li>编译：将源代码编译成若干模块</li>
<li>链接：将编译后的模块和所需要的库函数进行链接。链接包括三种形式：静态链接，装入时动态链接（将编译后的模块在链接时一边链接一边装入），运行时动态链接（在执行时才把需要的模块进行链接）</li>
<li>装入：将模块装入内存运行</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38623623/article/details/78306498">https://blog.csdn.net/qq_38623623/article/details/78306498</a></p>
<p>将进程装入内存时，通常使用分页技术，将内存分成固定大小的页，进程分为固定大小的块，加载时将进程的块装入页中，并使用页表记录。减少外部碎片。</p>
<p>通常操作系统还会使用虚拟内存的技术将磁盘作为内存的扩充。</p>
<h4 id="（6）-操作系统的内存管理说一下"><a href="#（6）-操作系统的内存管理说一下" class="headerlink" title="（6） 操作系统的内存管理说一下"></a>（6） 操作系统的内存管理说一下</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/peterYong/p/6556619.html">https://www.cnblogs.com/peterYong/p/6556619.html</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/141602175">https://zhuanlan.zhihu.com/p/141602175</a></p>
<p>操作系统的内存管理包括物理内存管理和虚拟内存管理</p>
<ul>
<li>物理内存管理包括交换与覆盖，分页管理，分段管理和段页式管理等；</li>
<li>虚拟内存管理包括虚拟内存的概念，页面置换算法，页面分配策略等；</li>
</ul>
<p>（面试官这样问的时候，其实是希望你能讲讲虚拟内存）</p>
<h4 id="（7）-实现一个LRU算法"><a href="#（7）-实现一个LRU算法" class="headerlink" title="（7） 实现一个LRU算法"></a>（7） 实现一个LRU算法</h4><p>用到两个数据结构：哈希+双向链表 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>,list&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; &gt; cache ;<span class="comment">// 存放键，迭代器</span></span><br><span class="line">list&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; auxlist; <span class="comment">// 存放 &lt;键，值&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="type">int</span> cap;</span><br><span class="line">    list&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; l;<span class="comment">// front:new back:old 存放值 新的放前面，因为前面的可以取得有效的迭代器</span></span><br><span class="line">    map&lt;<span class="type">int</span>,list&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt;::iterator &gt; cache;<span class="comment">// 存放键，迭代器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        cap=capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> mapitera = cache.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(mapitera==cache.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">// found</span></span><br><span class="line">            list&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;::iterator listItera = mapitera-&gt;second;</span><br><span class="line">            <span class="type">int</span> value = (*listItera).second;</span><br><span class="line"></span><br><span class="line">            l.<span class="built_in">erase</span>(listItera);</span><br><span class="line">            l.<span class="built_in">push_front</span>(&#123;key,value&#125;);</span><br><span class="line">            cache[key]=l.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> itera = cache.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(itera!=cache.<span class="built_in">end</span>())&#123;<span class="comment">// exist</span></span><br><span class="line">            list&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;::iterator listItera = itera-&gt;second;</span><br><span class="line"></span><br><span class="line">            l.<span class="built_in">erase</span>(listItera);</span><br><span class="line">            l.<span class="built_in">push_front</span>(&#123;key,value&#125;);</span><br><span class="line">            cache[key]=l.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">// not exist</span></span><br><span class="line">            <span class="keyword">if</span>(cache.<span class="built_in">size</span>()&gt;=cap)&#123;</span><br><span class="line">                pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; oldpair = l.<span class="built_in">back</span>();</span><br><span class="line">                l.<span class="built_in">pop_back</span>();</span><br><span class="line">                cache.<span class="built_in">erase</span>(oldpair.first);</span><br><span class="line">            &#125;</span><br><span class="line">            l.<span class="built_in">push_front</span>(&#123;key,value&#125;);</span><br><span class="line">            cache[key]=l.<span class="built_in">begin</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h4 id="（8）-死锁产生的必要条件（怎么检测死锁，解决死锁问题）"><a href="#（8）-死锁产生的必要条件（怎么检测死锁，解决死锁问题）" class="headerlink" title="（8） 死锁产生的必要条件（怎么检测死锁，解决死锁问题）"></a>（8） 死锁产生的必要条件（怎么检测死锁，解决死锁问题）</h4><p>（1） 互斥：一个资源每次只能被一个进程使用。<br><br>（2） 占有并请求：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br><br>（3） 不可剥夺:进程已获得的资源，在末使用完之前，不能强行剥夺。<br><br>（4） 循环等待:若干进程之间形成一种头尾相接的循环等待资源关系。<br></p>
<p>产生死锁的原因主要是：<br><br>（1） 因为系统资源不足。<br><br>（2） 进程运行推进的顺序不合适。<br><br>（3） 资源分配不当等。<br></p>
<h4 id="（8）-死锁的恢复"><a href="#（8）-死锁的恢复" class="headerlink" title="（8） 死锁的恢复"></a>（8） 死锁的恢复</h4><ol>
<li>重新启动：是最简单、最常用的死锁消除方法，但代价很大，因为在此之前所有进程已经完成的计算工作都将付之东流，不仅包括死锁的全部进程，也包括未参与死锁的全部进程。</li>
<li>终止进程(process termination)：终止参与死锁的进程并回收它们所占资源。<br> (1) 一次性全部终止；(2) 逐步终止(优先级，代价函数)</li>
<li>剥夺资源(resource preemption):剥夺死锁进程所占有的全部或者部分资源。<br> (1) 逐步剥夺：一次剥夺死锁进程所占有的一个或一组资源，如果死锁尚未解除再继续剥夺，直至死锁解除为止。<br> (2) 一次剥夺：一次性地剥夺死锁进程所占有的全部资源。</li>
<li>进程回退(rollback):让参与死锁的进程回退到以前没有发生死锁的某个点处，并由此点开始继续执行，希望进程交叉执行时不再发生死锁。但是系统开销很大：<br> (1) 要实现“回退”，必须“记住”以前某一点处的现场，而现场随着进程推进而动态变化，需要花费大量时间和空间。<br> (2) 一个回退的进程应当“挽回”它在回退点之间所造成的影响，如修改某一文件，给其它进程发送消息等，这些在实现时是难以做到的<h4 id="（8）什么是饥饿"><a href="#（8）什么是饥饿" class="headerlink" title="（8）什么是饥饿"></a>（8）什么是饥饿</h4>饥饿是由于资源分配策略不公引起的，当进程或线程无法访问它所需要的资源而不能继续执行时，就会发生饥饿现象。<h4 id="（9）-如果要你实现一个mutex互斥锁你要怎么实现？"><a href="#（9）-如果要你实现一个mutex互斥锁你要怎么实现？" class="headerlink" title="（9） 如果要你实现一个mutex互斥锁你要怎么实现？"></a>（9） 如果要你实现一个mutex互斥锁你要怎么实现？</h4><a target="_blank" rel="noopener" href="https://blog.csdn.net/kid551/article/details/84338619">https://blog.csdn.net/kid551/article/details/84338619</a></li>
</ol>
<p>实现mutex最重要的就是实现它的lock()方法和unlock()方法。我们保存一个全局变量flag，flag&#x3D;1表明该锁已经锁住，flag&#x3D;0表明锁没有锁住。<br>实现lock()时，使用一个while循环不断检测flag是否等于1，如果等于1就一直循环。然后将flag设置为1；unlock()方法就将flag置为0；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">TestAndSet</span>(&amp;flag,<span class="number">1</span>)==<span class="number">1</span>);</span><br><span class="line">  <span class="comment">//flag=1;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">  flag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为while有可能被重入，所以可以用TestandSet()方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">TestAndSet</span><span class="params">(<span class="type">int</span> *ptr, <span class="type">int</span> <span class="keyword">new</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> old = *ptr;</span><br><span class="line">    *ptr = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（10）线程之间的通信方式有哪些？-进程之间的同步方式又哪些？"><a href="#（10）线程之间的通信方式有哪些？-进程之间的同步方式又哪些？" class="headerlink" title="（10）线程之间的通信方式有哪些？ 进程之间的同步方式又哪些？"></a>（10）线程之间的通信方式有哪些？ 进程之间的同步方式又哪些？</h4><p>线程之间通信：</p>
<ul>
<li>使用全局变量</li>
<li>使用信号机制</li>
<li>使用事件</li>
</ul>
<p>进程之间同步：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sonic4x/archive/2011/07/05/2098036.html">https://www.cnblogs.com/sonic4x/archive/2011/07/05/2098036.html</a></p>
<ul>
<li><p>信号量</p>
</li>
<li><p>管程</p>
<h4 id="（13）-什么时候用多进程，什么时候用多线程"><a href="#（13）-什么时候用多进程，什么时候用多线程" class="headerlink" title="（13） 什么时候用多进程，什么时候用多线程"></a>（13） 什么时候用多进程，什么时候用多线程</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yu876876/article/details/82810178">https://blog.csdn.net/yu876876/article/details/82810178</a></p>
</li>
<li><p>频繁修改：需要频繁创建和销毁的优先使用<strong>多线程</strong></p>
</li>
<li><p>计算量：需要大量计算的优先使用<strong>多线程</strong>  因为需要消耗大量CPU资源且切换频繁，所以多线程好一点</p>
</li>
<li><p>相关性：任务间相关性比较强的用<strong>多线程</strong>，相关性比较弱的用多进程。因为线程之间的数据共享和同步比较简单。</p>
</li>
<li><p>多分布：可能要扩展到多机分布的用<strong>多进程</strong>，多核分布的用<strong>多线程</strong>。</p>
</li>
</ul>
<p>但是实际中更常见的是进程加线程的结合方式，并不是非此即彼的。</p>
<h4 id="（14）-文件读写使用的系统调用"><a href="#（14）-文件读写使用的系统调用" class="headerlink" title="（14） 文件读写使用的系统调用"></a>（14） 文件读写使用的系统调用</h4><h4 id="（15）-孤儿进程和僵尸进程分别是什么，怎么形成的？"><a href="#（15）-孤儿进程和僵尸进程分别是什么，怎么形成的？" class="headerlink" title="（15） 孤儿进程和僵尸进程分别是什么，怎么形成的？"></a>（15） 孤儿进程和僵尸进程分别是什么，怎么形成的？</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Anker/p/3271773.html">https://www.cnblogs.com/Anker/p/3271773.html</a></p>
<ul>
<li>孤儿进程是父进程退出后它的子进程还在执行，这时候这些子进程就成为孤儿进程。孤儿进程会被init进程收养并完成状态收集。</li>
<li>僵尸进程是指子进程完成并退出后父进程没有使用wait()或者waitpid()对它们进行状态收集，这些子进程的进程描述符仍然会留在系统中。这些子进程就成为僵尸进程。<h4 id="（16）-说一下PCB-x2F-说一下进程地址空间-x2F"><a href="#（16）-说一下PCB-x2F-说一下进程地址空间-x2F" class="headerlink" title="（16） 说一下PCB&#x2F;说一下进程地址空间&#x2F;"></a>（16） 说一下PCB&#x2F;说一下进程地址空间&#x2F;</h4><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38499859/article/details/80057427">https://blog.csdn.net/qq_38499859/article/details/80057427</a></li>
</ul>
<p>PCB就是进程控制块，是操作系统中的一种数据结构，用于表示进程状态，操作系统通过PCB对进程进行管理。</p>
<p>PCB中包含有：进程标识符，处理器状态，进程调度信息，进程控制信息</p>
<p><img src="https://img-blog.csdn.net/20140904215636015?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhbmd6aGVianV0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p>
<p>进程地址空间内有：</p>
<ul>
<li>代码段text：存放程序的二进制代码</li>
<li>初始化的数据Data：已经初始化的变量和数据</li>
<li>未初始化的数据BSS：还没有初始化的数据</li>
<li>栈</li>
<li>堆<h4 id="（17）-内核空间和用户空间是怎样区分的"><a href="#（17）-内核空间和用户空间是怎样区分的" class="headerlink" title="（17） 内核空间和用户空间是怎样区分的"></a>（17） 内核空间和用户空间是怎样区分的</h4>在Linux中虚拟地址空间范围为0到4G，最高的1G地址（0xC0000000到0xFFFFFFFF）供内核使用，称为内核空间，低的3G空间（0x00000000到0xBFFFFFFF）供各个进程使用，就是用户空间。</li>
</ul>
<p>内核空间中存放的是内核代码和数据，而进程的用户空间中存放的是用户程序的代码和数据。</p>
<h4 id="（18）-多线程是如何同步的（尤其是如果项目中用到了多线程，很大可能会结合讨论）"><a href="#（18）-多线程是如何同步的（尤其是如果项目中用到了多线程，很大可能会结合讨论）" class="headerlink" title="（18） 多线程是如何同步的（尤其是如果项目中用到了多线程，很大可能会结合讨论）"></a>（18） 多线程是如何同步的（尤其是如果项目中用到了多线程，很大可能会结合讨论）</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/s_lisheng/article/details/74278765">https://blog.csdn.net/s_lisheng/article/details/74278765</a></p>
<ul>
<li>临界区</li>
<li>信号量</li>
<li>事件</li>
<li>互斥量<h4 id="（19）-同一个进程内的线程会共享什么资源？"><a href="#（19）-同一个进程内的线程会共享什么资源？" class="headerlink" title="（19） 同一个进程内的线程会共享什么资源？"></a>（19） 同一个进程内的线程会共享什么资源？</h4></li>
<li>该进程的地址空间</li>
<li>全局变量</li>
<li>堆空间</li>
</ul>
<p>线程的栈空间是自己独有的</p>
<h4 id="（20）-异常和中断的区别"><a href="#（20）-异常和中断的区别" class="headerlink" title="（20） 异常和中断的区别"></a>（20） 异常和中断的区别</h4><h4 id="（21）-一般情况下在Linux-x2F-windows平台下栈空间的大小"><a href="#（21）-一般情况下在Linux-x2F-windows平台下栈空间的大小" class="headerlink" title="（21） 一般情况下在Linux&#x2F;windows平台下栈空间的大小"></a>（21） 一般情况下在Linux&#x2F;windows平台下栈空间的大小</h4><p>在Linux下栈空间通常是8M，Windows下是1M</p>
<h4 id="（22）虚拟内存的了解"><a href="#（22）虚拟内存的了解" class="headerlink" title="（22）虚拟内存的了解"></a>（22）虚拟内存的了解</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Przz/p/6876988.html">https://www.cnblogs.com/Przz/p/6876988.html</a></p>
<p>在运行一个进程的时候，它所需要的内存空间可能大于系统的物理内存容量。通常一个进程会有4G的空间，但是物理内存并没有这么大，所以这些空间都是虚拟内存，它的地址都是逻辑地址，每次在访问的时候都需要映射成物理地址。<br>当进程访问某个逻辑地址的时候，会去查看页表，如果页表中没有相应的物理地址，说明内存中没有这页的数据，发生缺页异常，这时候进程需要把数据从磁盘拷贝到物理内存中。如果物理内存已经满了，就需要覆盖已有的页，如果这个页曾经被修改过，那么还要把它写回磁盘。</p>
<h4 id="（23）服务器高并发的解决方案"><a href="#（23）服务器高并发的解决方案" class="headerlink" title="（23）服务器高并发的解决方案"></a>（23）服务器高并发的解决方案</h4><ol>
<li><p>应用数据与静态资源分离<br>将静态资源（图片，视频，js，css等）单独保存到专门的静态资源服务器中，在客户端访问的时候从静态资源服务器中返回静态资源，从主服务器中返回应用数据。</p>
</li>
<li><p>客户端缓存<br>因为效率最高，消耗资源最小的就是纯静态的html页面，所以可以把网站上的页面尽可能用静态的来实现，在页面过期或者有数据更新之后再将页面重新缓存。或者先生成静态页面，然后用ajax异步请求获取动态数据。</p>
</li>
<li><p>集群和分布式<br>（集群是所有的服务器都有相同的功能，请求哪台都可以，主要起分流作用）<br><br>（分布式是将不同的业务放到不同的服务器中，处理一个请求可能需要使用到多台服务器，起到加快请求处理的速度。）<br><br>可以使用服务器集群和分布式架构，使得原本属于一个服务器的计算压力分散到多个服务器上。同时加快请求处理的速度。</p>
</li>
<li><p>反向代理<br>在访问服务器的时候，服务器通过别的服务器获取资源或结果返回给客户端。</p>
<h4 id="（24）协程了解吗（高频）"><a href="#（24）协程了解吗（高频）" class="headerlink" title="（24）协程了解吗（高频）"></a>（24）协程了解吗（高频）</h4><p>协程和微线程是一个东西。</p>
</li>
</ol>
<p>协程就是子程序在执行时中断并转去执行别的子程序，在适当的时候又返回来执行。<br>这种子程序间的跳转不是函数调用，也不是多线程执行，所以省去了线程切换的开销，效率很高，并且不需要多线程间的锁机制，不会发生变量写冲突。</p>
<h4 id="（25）那协程的底层是怎么实现的，怎么使用协程？"><a href="#（25）那协程的底层是怎么实现的，怎么使用协程？" class="headerlink" title="（25）那协程的底层是怎么实现的，怎么使用协程？"></a>（25）那协程的底层是怎么实现的，怎么使用协程？</h4><p>协程进行中断跳转时将函数的上下文存放在其他位置中，而不是存放在函数堆栈里，当处理完其他事情跳转回来的时候，取回上下文继续执行原来的函数。</p>
<h4 id="（23）进程的状态以及转换图"><a href="#（23）进程的状态以及转换图" class="headerlink" title="（23）进程的状态以及转换图"></a>（23）进程的状态以及转换图</h4><ul>
<li><p>三态模型<br>三态模型包括三种状态：</p>
<ol>
<li>执行：进程分到CPU时间片，可以执行</li>
<li>就绪：进程已经就绪，只要分配到CPU时间片，随时可以执行</li>
<li>阻塞：有IO事件或者等待其他资源<br><img src="/fig/%E4%B8%89%E6%80%81%E6%A8%A1%E5%9E%8B.png"></li>
</ol>
</li>
<li><p>五态模型</p>
<ol>
<li>新建态：进程刚刚创建。</li>
<li>就绪态：</li>
<li>运行态：</li>
<li>等待态：出现等待事件</li>
<li>终止态：进程结束<br> <img src="/fig/%E4%BA%94%E6%80%81%E6%A8%A1%E5%9E%8B.png"></li>
</ol>
</li>
<li><p>七态模型</p>
<ol>
<li>新建态</li>
<li>就绪挂起态</li>
<li>就绪态</li>
<li>运行态</li>
<li>等待态</li>
<li>挂起等待态</li>
<li>终止态<br><img src="/fig/%E4%B8%83%E6%80%81%E6%A8%A1%E5%9E%8B.png"></li>
</ol>
</li>
</ul>
<h4 id="（24）在执行malloc申请内存的时候，操作系统是怎么做的？-x2F-内存分配的原理说一下-x2F-malloc函数底层是怎么实现的？-x2F-进程是怎么分配内存的？"><a href="#（24）在执行malloc申请内存的时候，操作系统是怎么做的？-x2F-内存分配的原理说一下-x2F-malloc函数底层是怎么实现的？-x2F-进程是怎么分配内存的？" class="headerlink" title="（24）在执行malloc申请内存的时候，操作系统是怎么做的？&#x2F;内存分配的原理说一下&#x2F;malloc函数底层是怎么实现的？&#x2F;进程是怎么分配内存的？"></a>（24）在执行malloc申请内存的时候，操作系统是怎么做的？&#x2F;内存分配的原理说一下&#x2F;malloc函数底层是怎么实现的？&#x2F;进程是怎么分配内存的？</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yusiguyuan/article/details/39496057">https://blog.csdn.net/yusiguyuan/article/details/39496057</a></p>
<p>从操作系统层面上看，malloc是通过两个系统调用来实现的： brk和mmap</p>
<ul>
<li>brk是将进程数据段(.data)的最高地址指针向高处移动，这一步可以扩大进程在运行时的堆大小</li>
<li>mmap是在进程的虚拟地址空间中寻找一块空闲的虚拟内存，这一步可以获得一块可以操作的堆内存。</li>
</ul>
<p>通常，分配的内存小于128k时，使用brk调用来获得虚拟内存，大于128k时就使用mmap来获得虚拟内存。</p>
<p>进程先通过这两个系统调用获取或者扩大进程的虚拟内存，获得相应的虚拟地址，在访问这些虚拟地址的时候，通过缺页中断，让内核分配相应的物理内存，这样内存分配才算完成。</p>
<h4 id="（25）什么是字节序？怎么判断是大端还是小端？有什么用？"><a href="#（25）什么是字节序？怎么判断是大端还是小端？有什么用？" class="headerlink" title="（25）什么是字节序？怎么判断是大端还是小端？有什么用？"></a>（25）什么是字节序？怎么判断是大端还是小端？有什么用？</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/broglie/p/5645200.html">https://www.cnblogs.com/broglie/p/5645200.html</a></p>
<p>字节序是对象在内存中存储的方式，大端即为最高有效位在前面，小端即为最低有效位在前面。<br>判断大小端的方法：使用一个union数据结构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span>&#123;</span><br><span class="line">  <span class="type">short</span> s;</span><br><span class="line">  <span class="type">char</span> c[<span class="number">2</span>]; <span class="comment">// sizeof(short)=2;</span></span><br><span class="line">&#125;un;</span><br><span class="line">un.s=<span class="number">0x0102</span>;</span><br><span class="line"><span class="keyword">if</span>(un.c[<span class="number">0</span>]==<span class="number">1</span> <span class="keyword">and</span> un.c[<span class="number">1</span>]==<span class="number">2</span>) cout&lt;&lt;<span class="string">&quot;大端&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(un.c[<span class="number">0</span>]==<span class="number">2</span> <span class="keyword">and</span> un.c[<span class="number">1</span>]==<span class="number">1</span>) cout&lt;&lt;<span class="string">&quot;小端&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>在网络编程中不同字节序的机器发送和接收的顺序不同。</p>
<h1 id="6-场景题-x2F-算法题"><a href="#6-场景题-x2F-算法题" class="headerlink" title="6. 场景题&#x2F;算法题"></a>6. 场景题&#x2F;算法题</h1><h4 id="（0）-leetcode-hot100至少刷两遍，剑指offer至少刷两遍-重中之重！！"><a href="#（0）-leetcode-hot100至少刷两遍，剑指offer至少刷两遍-重中之重！！" class="headerlink" title="（0） leetcode hot100至少刷两遍，剑指offer至少刷两遍 重中之重！！"></a>（0） leetcode hot100至少刷两遍，剑指offer至少刷两遍 重中之重！！</h4><p>面试中90%的算法题都从leetcode hot100和剑指offer中出 刷两遍非常有必要</p>
<h4 id="（1）-介绍熟悉的设计模式（单例，简单工厂模式）"><a href="#（1）-介绍熟悉的设计模式（单例，简单工厂模式）" class="headerlink" title="（1） 介绍熟悉的设计模式（单例，简单工厂模式）"></a>（1） 介绍熟悉的设计模式（单例，简单工厂模式）</h4><h4 id="（2）-写单例模式，线程安全版本"><a href="#（2）-写单例模式，线程安全版本" class="headerlink" title="（2） 写单例模式，线程安全版本"></a>（2） 写单例模式，线程安全版本</h4><figure class="highlight c++"><figcaption><span>version</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;</span><br><span class="line">      <span class="comment">// initialize</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(instance==<span class="literal">nullptr</span>) instance=<span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="（3）-写三个线程交替打印ABC"><a href="#（3）-写三个线程交替打印ABC" class="headerlink" title="（3） 写三个线程交替打印ABC"></a>（3） 写三个线程交替打印ABC</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex mymutex;</span><br><span class="line">condition_variable cv;</span><br><span class="line"><span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lk</span><span class="params">(mymutex)</span></span>;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(count&lt;<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(flag!=<span class="number">0</span>) cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;thread 1: a&quot;</span>&lt;&lt;endl;</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;my thread 1 finish&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printb</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lk</span><span class="params">(mymutex)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(flag!=<span class="number">1</span>) cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;thread 2: b&quot;</span>&lt;&lt;endl;</span><br><span class="line">        flag=<span class="number">2</span>;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;my thread 2 finish&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lk</span><span class="params">(mymutex)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(flag!=<span class="number">2</span>) cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;thread 3: c&quot;</span>&lt;&lt;endl;</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;my thread 3 finish&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">th2</span><span class="params">(printa)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">th1</span><span class="params">(printb)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">th3</span><span class="params">(printc)</span></span>;</span><br><span class="line"></span><br><span class="line">    th1.<span class="built_in">join</span>();</span><br><span class="line">    th2.<span class="built_in">join</span>();</span><br><span class="line">    th3.<span class="built_in">join</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot; main thread &quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（4）-二维码登录的实现过程-场景题"><a href="#（4）-二维码登录的实现过程-场景题" class="headerlink" title="（4） 二维码登录的实现过程 场景题"></a>（4） 二维码登录的实现过程 场景题</h4><p><img src="/fig/%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B.png"></p>
<h4 id="（5）-不使用临时变量实现swap函数"><a href="#（5）-不使用临时变量实现swap函数" class="headerlink" title="（5） 不使用临时变量实现swap函数"></a>（5） 不使用临时变量实现swap函数</h4><ul>
<li>使用异或&#x2F;加减等方式，下面给出使用异或的实现方法<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a,<span class="type">int</span>&amp; b)</span></span>&#123;</span><br><span class="line">  a=a^b;</span><br><span class="line">  b=a^b;</span><br><span class="line">  a=a^b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（6）-实现一个strcpy函数（或者memcpy），如果内存可能重叠呢"><a href="#（6）-实现一个strcpy函数（或者memcpy），如果内存可能重叠呢" class="headerlink" title="（6） 实现一个strcpy函数（或者memcpy），如果内存可能重叠呢"></a>（6） 实现一个strcpy函数（或者memcpy），如果内存可能重叠呢</h4><h4 id="（7）-实现快排"><a href="#（7）-实现快排" class="headerlink" title="（7） 实现快排"></a>（7） 实现快排</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec,<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    vec[a]=vec[a]^vec[b];</span><br><span class="line">    vec[b]=vec[a]^vec[b];</span><br><span class="line">    vec[a]=vec[a]^vec[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec,<span class="type">int</span> start,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot=vec[start+(end-start)/<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end <span class="keyword">and</span> vec[start]&lt;pivot) start++;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end <span class="keyword">and</span> vec[end]&gt;pivot) end--;</span><br><span class="line">        <span class="keyword">if</span>(start&lt;end) <span class="built_in">swap</span>(vec,start,end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec,<span class="type">int</span> start,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start&gt;end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> pivot=<span class="built_in">partition</span>(vec,start,end);</span><br><span class="line">    <span class="built_in">quickSort</span>(vec,start,pivot<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(vec,pivot+<span class="number">1</span>,end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（8）-实现一个堆排序"><a href="#（8）-实现一个堆排序" class="headerlink" title="（8） 实现一个堆排序"></a>（8） 实现一个堆排序</h4>堆排序的基本过程：</li>
<li>将n个元素的序列构建一个大顶堆或小顶堆</li>
<li>将堆顶的元素放到序列末尾</li>
<li>将前n-1个元素重新构建大顶堆或小顶堆，重复这个过程，直到所有元素都已经排序</li>
</ul>
<p>整体时间复杂度为nlogn</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    arr[a]=arr[a]^arr[b];</span><br><span class="line">    arr[b]=arr[a]^arr[b];</span><br><span class="line">    arr[a]=arr[a]^arr[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adjust</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr,<span class="type">int</span> len,<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> maxid=index;</span><br><span class="line">    <span class="comment">// 计算左右子节点的下标   left=2*i+1  right=2*i+2  parent=(i-1)/2</span></span><br><span class="line">    <span class="type">int</span> left=<span class="number">2</span>*index+<span class="number">1</span>,right=<span class="number">2</span>*index+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找当前以index为根的子树中最大/最小的元素的下标</span></span><br><span class="line">    <span class="keyword">if</span>(left&lt;len <span class="keyword">and</span> arr[left]&lt;arr[maxid]) maxid=left;</span><br><span class="line">    <span class="keyword">if</span>(right&lt;len <span class="keyword">and</span> arr[right]&lt;arr[maxid]) maxid=right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行交换，记得要递归进行adjust,传入的index是maxid</span></span><br><span class="line">    <span class="keyword">if</span>(maxid!=index)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr,maxid,index);</span><br><span class="line">        <span class="built_in">adjust</span>(arr,len,maxid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapsort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;arr,<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 初次构建堆，i要从最后一个非叶子节点开始，所以是(len-1-1)/2，0这个位置要加等号</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=(len<span class="number">-1</span><span class="number">-1</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="built_in">adjust</span>(arr,len,i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最后一个元素的下标开始往前遍历，每次将堆顶元素交换至当前位置，并且缩小长度（i为长度），从0处开始adjust</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr,<span class="number">0</span>,i);</span><br><span class="line">        <span class="built_in">adjust</span>(arr,i,<span class="number">0</span>);<span class="comment">// 注意每次adjust是从根往下调整，所以这里index是0！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr=&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;before: &quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> item:arr) cout&lt;&lt;item&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">heapsort</span>(arr,arr.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;after: &quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> item:arr)cout&lt;&lt;item&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（8）-实现一个插入排序"><a href="#（8）-实现一个插入排序" class="headerlink" title="（8） 实现一个插入排序"></a>（8） 实现一个插入排序</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/left_la/article/details/8656425">https://blog.csdn.net/left_la/article/details/8656425</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">    <span class="type">int</span> key=nums[i];</span><br><span class="line">    <span class="type">int</span> j=i<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&gt;=<span class="number">0</span> <span class="keyword">and</span> nums[j]&gt;key)&#123;</span><br><span class="line">      nums[j+<span class="number">1</span>]=nums[j];</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[j+<span class="number">1</span>]=key;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（9）-快排存在的问题，如何优化"><a href="#（9）-快排存在的问题，如何优化" class="headerlink" title="（9） 快排存在的问题，如何优化"></a>（9） 快排存在的问题，如何优化</h4><ul>
<li>3 种快排基准选择方法：</li>
</ul>
<p>随机（rand函数）、固定（队首、队尾）、三数取中（队首、队中和队尾的中间数）</p>
<ul>
<li>4种优化方式：</li>
</ul>
<p>优化1：当待排序序列的长度分割到一定大小后，使用插入排序</p>
<p>优化2：在一次分割结束后，可以把与Key相等的元素聚在一起，继续下次分割时，不用再对与key相等元素分割</p>
<p>优化3：优化递归操作</p>
<p>优化4：使用并行或多线程处理子序列</p>
<h4 id="（10）-反转一个链表（招银网络二面）"><a href="#（10）-反转一个链表（招银网络二面）" class="headerlink" title="（10） 反转一个链表（招银网络二面）"></a>（10） 反转一个链表（招银网络二面）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* root)</span></span>&#123;</span><br><span class="line">  ListNode* pre=<span class="literal">nullptr</span>,cur=root,nxt;</span><br><span class="line">  <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">    nxt=cur-&gt;next;</span><br><span class="line">    cur-&gt;next=pre;</span><br><span class="line">    pre=cur;cur=nxt;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（11）-Top-K问题（可以采取的方法有哪些，各自优点？）（重点）"><a href="#（11）-Top-K问题（可以采取的方法有哪些，各自优点？）（重点）" class="headerlink" title="（11） Top K问题（可以采取的方法有哪些，各自优点？）（重点）"></a>（11） Top K问题（可以采取的方法有哪些，各自优点？）（重点）</h4><p><em>Top K 问题的常见形式：</em></p>
<blockquote>
<p>给定10000个整数，找第K大（第K小）的数<br><br> 给定10000个整数，找出最大（最小）的前K个数<br><br>给定100000个单词，求前K词频的单词<br></p>
</blockquote>
<p><em>解决Top K问题若干种方法</em></p>
<ul>
<li>使用最大最小堆。求最大的数用最小堆，求最小的数用最大堆。</li>
<li>Quick Select算法。使用类似快排的思路，根据pivot划分数组。</li>
<li>使用排序方法，排序后再寻找top K元素。</li>
<li>使用选择排序的思想，对前K个元素部分排序。</li>
<li>将1000…..个数分成m组，每组寻找top K个数，得到m×K个数，在这m×k个数里面找top K个数。</li>
</ul>
<ol>
<li>使用最大最小堆的思路 （以top K 最大元素为例）<br><br>按顺序扫描这10000个数，先取出K个元素构建一个大小为K的最小堆。每扫描到一个元素，如果这个元素大于堆顶的元素（这个堆最小的一个数），就放入堆中，并删除堆顶的元素，同时整理堆。如果这个元素小于堆顶的元素，就直接pass。最后堆中剩下的元素就是最大的前Top K个元素，最右的叶节点就是Top 第K大的元素。</li>
</ol>
<blockquote>
<p>note：最小堆的插入时间复杂度为log(n)，n为堆中元素个数，在这里是K。最小堆的初始化时间复杂度是nlog(n)</p>
</blockquote>
<p>C++中的最大最小堆要用标准库的priority_queue来实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line">    <span class="built_in">Node</span> (<span class="type">int</span> v, <span class="type">int</span> i): <span class="built_in">value</span>(v), <span class="built_in">idx</span>(i) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> <span class="keyword">struct</span> Node &amp;n1, <span class="type">const</span> <span class="keyword">struct</span> Node &amp;n2) ; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> <span class="keyword">struct</span> Node &amp;n1, <span class="type">const</span> <span class="keyword">struct</span> Node &amp;n2) &#123;</span><br><span class="line">    <span class="keyword">return</span> n1.value &lt; n2.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;Node&gt; pq; <span class="comment">// 此时pq为最大堆</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用Quick Select的思路（以寻找第K大的元素为例）<br><br>Quick Select脱胎于快速排序，提出这两个算法的都是同一个人。算法的过程是这样的：<br>首先选取一个枢轴，然后将数组中小于该枢轴的数放到左边，大于该枢轴的数放到右边。<br>此时，如果左边的数组中的元素个数大于等于K，则第K大的数肯定在左边数组中，继续对左边数组执行相同操作；<br>如果左边的数组元素个数等于K-1，则第K大的数就是pivot；<br>如果左边的数组元素个数小于K，则第K大的数肯定在右边数组中，对右边数组执行相同操作。</li>
</ol>
<p>这个算法与快排最大的区别是，每次划分后只处理左半边或者右半边，而快排在划分后对左右半边都继续排序。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此为Java实现</span></span><br><span class="line">public <span class="built_in">int</span> find<span class="constructor">KthLargest(<span class="params">int</span>[] <span class="params">nums</span>, <span class="params">int</span> <span class="params">k</span>)</span> &#123;</span><br><span class="line">  return quick<span class="constructor">Select(<span class="params">nums</span>, <span class="params">k</span>, 0, <span class="params">nums</span>.<span class="params">length</span> - 1)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// quick select to find the kth-largest element</span></span><br><span class="line">public <span class="built_in">int</span> quick<span class="constructor">Select(<span class="params">int</span>[] <span class="params">arr</span>, <span class="params">int</span> <span class="params">k</span>, <span class="params">int</span> <span class="params">left</span>, <span class="params">int</span> <span class="params">right</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (left<span class="operator"> == </span>right) return arr<span class="literal">[<span class="identifier">right</span>]</span>;</span><br><span class="line">  <span class="built_in">int</span> index = partition(arr, left, right);</span><br><span class="line">  <span class="keyword">if</span> (index - left + <span class="number">1</span> &gt; k)</span><br><span class="line">    return quick<span class="constructor">Select(<span class="params">arr</span>, <span class="params">k</span>, <span class="params">left</span>, <span class="params">index</span> - 1)</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (index - left + <span class="number">1</span><span class="operator"> == </span>k)</span><br><span class="line">    return arr<span class="literal">[<span class="identifier">index</span>]</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    return quick<span class="constructor">Select(<span class="params">arr</span>, <span class="params">k</span> - (<span class="params">index</span> - <span class="params">left</span> + 1)</span>, index + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用选择排序的思想对前K个元素排序 （ 以寻找前K大个元素为例）<br><br>扫描一遍数组，选出最大的一个元素，然后再扫描一遍数组，找出第二大的元素，再扫描一遍数组，找出第三大的元素。。。。。以此类推，找K个元素，时间复杂度为O(N*K)<h4 id="（12）-8G的int型数据，计算机的内存只有2G，怎么对它进行排序？（外部排序）（百度一面）"><a href="#（12）-8G的int型数据，计算机的内存只有2G，怎么对它进行排序？（外部排序）（百度一面）" class="headerlink" title="（12） 8G的int型数据，计算机的内存只有2G，怎么对它进行排序？（外部排序）（百度一面）"></a>（12） 8G的int型数据，计算机的内存只有2G，怎么对它进行排序？（外部排序）（百度一面）</h4>我们可以使用外部排序来对它进行处理。首先将整个文件分成许多份，比如说m份，划分的依据就是使得每一份的大小都能放到内存里。然后我们用快速排序或者堆排序等方法对每一份数据进行一个内部排序，变成有序子串。接着对这m份有序子串进行m路归并排序。取这m份数据的最小元素，进行排序，输出排序后最小的元素到结果中，同时从该元素所在子串中读入一个元素，直到所有数据都被输出到结果中为止。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ailunlee/article/details/84548950">https://blog.csdn.net/ailunlee/article/details/84548950</a></p>
<h4 id="（13）-自己构建一棵二叉树，使用带有null标记的前序遍历序列"><a href="#（13）-自己构建一棵二叉树，使用带有null标记的前序遍历序列" class="headerlink" title="（13） 自己构建一棵二叉树，使用带有null标记的前序遍历序列"></a>（13） 自己构建一棵二叉树，使用带有null标记的前序遍历序列</h4><p>在写二叉树相关算法的时候，如果需要自己构造测试用例（自己构造一棵二叉树），往往是一件很麻烦的事情，我们可以用一个带有null标记的前序遍历序列来进行构造。 <strong>需要注意的是vec2tree()参数中的start是引用传递，而不是简单的参数值传递</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">treeNode</span>&#123;</span><br><span class="line">    string val;</span><br><span class="line">    treeNode* left,*right;</span><br><span class="line">    <span class="built_in">treeNode</span>(string val):<span class="built_in">val</span>(val)&#123;</span><br><span class="line">        left=<span class="literal">nullptr</span>;</span><br><span class="line">        right=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">treeNode* <span class="title">vec2tree</span><span class="params">(vector&lt;string&gt;&amp; vec,<span class="type">int</span>&amp; start)</span></span>&#123;</span><br><span class="line">    treeNode* root;</span><br><span class="line">    <span class="keyword">if</span>(vec[start]==<span class="string">&quot;null&quot;</span>)&#123;</span><br><span class="line">        start+=<span class="number">1</span>;</span><br><span class="line">        root=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        root=<span class="keyword">new</span> <span class="built_in">treeNode</span>(vec[start]);</span><br><span class="line">        start+=<span class="number">1</span>;</span><br><span class="line">        root-&gt;left=<span class="built_in">vec2tree</span>(vec,start);</span><br><span class="line">        root-&gt;right=<span class="built_in">vec2tree</span>(vec,start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tree2vec</span><span class="params">(treeNode *root,vector&lt;string&gt;&amp; vec)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">tree2vec</span>(root-&gt;left,vec);</span><br><span class="line">        <span class="built_in">tree2vec</span>(root-&gt;right,vec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;string&gt; vec=&#123;<span class="string">&quot;2&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;null&quot;</span>,<span class="string">&quot;null&quot;</span>,<span class="string">&quot;null&quot;</span>,<span class="string">&quot;null&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;null&quot;</span>,<span class="string">&quot;null&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;null&quot;</span>,<span class="string">&quot;null&quot;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> index=<span class="number">0</span>,&amp;start=index;</span><br><span class="line">    treeNode* root=<span class="built_in">vec2tree</span>(vec,start);</span><br><span class="line">    <span class="comment">//displaytree(root);</span></span><br><span class="line">    vector&lt;string&gt; mvec;</span><br><span class="line">    <span class="built_in">tree2vec</span>(root,mvec);</span><br><span class="line">    <span class="keyword">for</span>(string item:mvec) cout&lt;&lt;item&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h4 id="（14）-介绍一下b树和它的应用场景有哪些"><a href="#（14）-介绍一下b树和它的应用场景有哪些" class="headerlink" title="（14） 介绍一下b树和它的应用场景有哪些"></a>（14） 介绍一下b树和它的应用场景有哪些</h4><p>B树也叫做B-树，或者平衡多路树，它是每个节点最多有m个子树的<strong>平衡树</strong>。一个m阶的B树具有如下几个特征：</p>
<ol>
<li>根结点至少有两个子女。</li>
<li>每个中间节点都包含至多m个子树 ， 每个节点包含的元素个数是其子树个数-1（其中 m&#x2F;2 &lt;&#x3D; k &lt;&#x3D; m）</li>
<li>所有的叶子结点都位于同一层。</li>
<li>每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个子树包含的元素的值域分划。</li>
</ol>
<p>b树主要应用于文件系统中，在数据库中（mongoDB）也有应用，与B+树相比好处应该是有时不需要访问到叶节点就可以获取数据。</p>
<p>查询时间复杂度是logN</p>
<h4 id="（15）-介绍一下b-树和它的应用场景有哪些"><a href="#（15）-介绍一下b-树和它的应用场景有哪些" class="headerlink" title="（15） 介绍一下b+树和它的应用场景有哪些"></a>（15） 介绍一下b+树和它的应用场景有哪些</h4><p>B+树是一种特殊的B树，它把数据都存储在叶子节点，并且叶节点间有指针连接。内部只存关键字（其中叶子节点的最小值作为索引）和孩子指针，简化了内部节点。</p>
<p>应用场景主要是数据库的索引</p>
<p>查询时间复杂度也是logN<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/110202102">https://zhuanlan.zhihu.com/p/110202102</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hguisu/article/details/7786014">https://blog.csdn.net/hguisu/article/details/7786014</a></p>
<h4 id="（16）-介绍一下红黑树和它的应用场景有哪些"><a href="#（16）-介绍一下红黑树和它的应用场景有哪些" class="headerlink" title="（16） 介绍一下红黑树和它的应用场景有哪些"></a>（16） 介绍一下红黑树和它的应用场景有哪些</h4><p>红黑树是一种特殊的二叉查找树，它在每一个节点上都使用红色或黑色进行标记，通过一些性质确保它是始终平衡的。<br>它的性质是这样的：</p>
<ol>
<li>每个节点不是红色就是黑色。</li>
<li>根节点是黑色的。</li>
<li>叶节点的空节点是黑色的。</li>
<li>如果一个节点是红色的，那么它的两个子节点是黑色的。</li>
<li>对于任意节点，从它到叶节点的每条路径上都有相同数目的黑色节点。</li>
</ol>
<p>红黑树的插入，查询，删除在一般情况和最坏情况下的时间复杂度都是O(log(n))</p>
<p>应用场景主要是STL中map，set的实现，优点在于支持频繁的修改，因为查询删除插入时间复杂度都是logN</p>
<h4 id="（17）-怎么写sql取表的前1000行数据（招银网络二面）"><a href="#（17）-怎么写sql取表的前1000行数据（招银网络二面）" class="headerlink" title="（17） 怎么写sql取表的前1000行数据（招银网络二面）"></a>（17） 怎么写sql取表的前1000行数据（招银网络二面）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> limit <span class="number">1000</span></span><br><span class="line"><span class="keyword">from</span> t1</span><br></pre></td></tr></table></figure>
<h4 id="（18）-N个骰子出现和为m的概率"><a href="#（18）-N个骰子出现和为m的概率" class="headerlink" title="（18） N个骰子出现和为m的概率"></a>（18） N个骰子出现和为m的概率</h4><h4 id="（19）-海量数据问题（可参考左神的书）"><a href="#（19）-海量数据问题（可参考左神的书）" class="headerlink" title="（19） 海量数据问题（可参考左神的书）"></a>（19） 海量数据问题（可参考左神的书）</h4><h4 id="（20）-一致性哈希"><a href="#（20）-一致性哈希" class="headerlink" title="（20） 一致性哈希"></a>（20） 一致性哈希</h4><h4 id="（21）希尔排序说一下-x2F-手撕"><a href="#（21）希尔排序说一下-x2F-手撕" class="headerlink" title="（21）希尔排序说一下&#x2F;手撕"></a>（21）希尔排序说一下&#x2F;手撕</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chengxiao/p/6104371.html">https://www.cnblogs.com/chengxiao/p/6104371.html</a><br>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>
<h4 id="（22）Dijkstra算法说一下"><a href="#（22）Dijkstra算法说一下" class="headerlink" title="（22）Dijkstra算法说一下"></a>（22）Dijkstra算法说一下</h4><h4 id="（23）实现一个动态数组要怎么实现，说思路（腾讯teg一面）"><a href="#（23）实现一个动态数组要怎么实现，说思路（腾讯teg一面）" class="headerlink" title="（23）实现一个动态数组要怎么实现，说思路（腾讯teg一面）"></a>（23）实现一个动态数组要怎么实现，说思路（腾讯teg一面）</h4><p>模拟STL中vector的实现即可，去看一下vector的源码。</p>
<h4 id="（24）最小生成树算法说一下"><a href="#（24）最小生成树算法说一下" class="headerlink" title="（24）最小生成树算法说一下"></a>（24）最小生成树算法说一下</h4><h4 id="（25）-海量数据的bitmap使用原理"><a href="#（25）-海量数据的bitmap使用原理" class="headerlink" title="（25） 海量数据的bitmap使用原理"></a>（25） 海量数据的bitmap使用原理</h4><p>bitmap算法就是使用一个比特映射一个值，它可以用在整数排序和数据压缩上，因为使用一个比特位去存储一个数，所以它可以大大节省空间。</p>
<p>它的具体过程是：先根据数组中元素最大的数N计算需要分配多大的空间。<br>如果使用int型数组的形式来保存的话，一个int &#x3D; 4字节  &#x3D;4*8比特 &#x3D; 32比特。也就是一个int数可以映射32个数据（图1），然后需要找到最大的数Max，表示最多需要的位数，所以需要开辟的数组空间为int a[1+Max&#x2F;32]。<br>然后需要推导一个整数a内如何映射32个数据，方法是将待存储的数据模32，然后将a中相应位置的比特置为1。<br>依此方法映射每一个元素，待读取的时候扫描每个比特位，遇到值为1的就还原该数字。<br><img src="/fig/bitmap1.png"></p>
<p><strong>移位计算公式：</strong><br>N&#x2F;32就是将N的二进制右移log32（也就是5）位 ： N&gt;&gt;5<br><br>N%32就是求N的后5位：N&amp; 0x1F  (0x1F &#x3D; 00011111)<br><br>模32然后相应位置置为1： a[i] |&#x3D; 1&lt;&lt; N &amp; 0x1F<br></p>
<p>所以总的公式为： a[ N&gt;&gt;5 ] |&#x3D; 1&lt;&lt; N &amp; 0x1F<br></p>
<p><strong>BitMap算法评价</strong></p>
<ul>
<li>优点：<ol>
<li>运算效率高，不进行比较和移位；</li>
<li>占用内存少，比如最大的数MAX&#x3D;10000000；只需占用内存为MAX&#x2F;8&#x3D;1250000Byte&#x3D;1.25M。</li>
</ol>
</li>
<li>缺点：<ol>
<li>所有的数据不能重复，即不可对重复的数据进行排序。（少量重复数据查找还是可以的，用2-bitmap）。</li>
<li>所需要的空间随着最大元素的增大而增大，当数据类似（1，1000，10万）只有3个数据的时候，用bitmap时间复杂度和空间复杂度相当大，只有当数据比较密集时才有优势。</li>
</ol>
</li>
</ul>
<h4 id="（26）-布隆过滤器原理与优点"><a href="#（26）-布隆过滤器原理与优点" class="headerlink" title="（26） 布隆过滤器原理与优点"></a>（26） 布隆过滤器原理与优点</h4><p>布隆过滤器是一个比特向量或者比特数组，它本质上是一种概率型数据结构，用来查找一个元素是否在集合中，支持高效插入和查询某条记录。常作为针对超大数据量下高效查找数据的一种方法。</p>
<p><strong>它的具体工作过程是这样子的：</strong><br>假设布隆过滤器的大小为m（比特向量的长度为m），有k个哈希函数，它对每个数据用这k个哈希函数计算哈希，得到k个哈希值，然后将向量中相应的位设为1。在查询某个数据是否存在的时候，对这个数据用k个哈希函数得到k个哈希值，再在比特向量中相应的位查找是否为1，如果某一个相应的位不为1，那这个数据就肯定不存在。但是如果全找到了，则这个数据有可能存在。</p>
<p><strong>为什么说有可能存在呢？</strong><br>因为不同的数据经过哈希后可能有相同的哈希值，在比特向量上某个位置查找到1也可能是由于某个另外的数据映射得到的。</p>
<p><strong>支持删除操作吗</strong><br>目前布隆过滤器只支持插入和查找操作，不支持删除操作，如果要支持删除，就要另外使用一个计数变量，每次将相应的位置为1则计数加一，删除则减一。</p>
<p>布隆过滤器中哈希函数的个数需要选择。如果太多则很快所有位都置为1，如果太少会容易误报。</p>
<p><strong>布隆过滤器的大小以及哈希函数的个数怎么选择？</strong><br>k 为哈希函数个数，m 为布隆过滤器长度，n 为插入的元素个数，p 为误报率<br><img src="/fig/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.png"></p>
<h4 id="（27）-布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题"><a href="#（27）-布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题" class="headerlink" title="（27） 布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题"></a>（27） 布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题</h4><h4 id="（28）实现一个队列，并且使它支持多线程，队列有什么应用场景（阿里三面）"><a href="#（28）实现一个队列，并且使它支持多线程，队列有什么应用场景（阿里三面）" class="headerlink" title="（28）实现一个队列，并且使它支持多线程，队列有什么应用场景（阿里三面）"></a>（28）实现一个队列，并且使它支持多线程，队列有什么应用场景（阿里三面）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//评测题目: </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FIFOQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(initCap,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> start=<span class="number">0</span>,end=<span class="number">0</span>;</span><br><span class="line">condition_variable cv;</span><br><span class="line">mutex m;</span><br><span class="line"><span class="type">bool</span> flag=<span class="literal">false</span>;<span class="comment">// isFull</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">enqueue</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  	unique_lock&lt;mutex&gt;&lt;/mutex&gt; <span class="built_in">lk</span>(m);</span><br><span class="line">    <span class="keyword">while</span>(flag==<span class="literal">true</span>) cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">        end=(end+<span class="number">1</span>)%initCap;</span><br><span class="line">        vec[end]=v;</span><br><span class="line">        cv.<span class="built_in">notifyall</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  unique_lock&lt;mutex&gt;&lt;/mutex&gt; <span class="built_in">lk</span>(m);</span><br><span class="line">  	<span class="keyword">if</span>(start!=end)&#123;</span><br><span class="line">    	<span class="type">int</span> val = vec[start];</span><br><span class="line">    	start=(start+<span class="number">1</span>)%initCap;</span><br><span class="line">        flag=<span class="literal">false</span>;</span><br><span class="line">    	cv.<span class="built_in">notifyall</span>();</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    	flag=<span class="literal">false</span>;</span><br><span class="line">    	cv.<span class="built_in">notifyall</span>();</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码是面试时写的，并没有运行，也许有错误，请客观参考</p>
<h1 id="7-智力题"><a href="#7-智力题" class="headerlink" title="7. 智力题"></a>7. 智力题</h1><h4 id="（1）-100层楼，只有2个鸡蛋，想要判断出那一层刚好让鸡蛋碎掉，给出策略（滴滴笔试中两个铁球跟这个是一类题）"><a href="#（1）-100层楼，只有2个鸡蛋，想要判断出那一层刚好让鸡蛋碎掉，给出策略（滴滴笔试中两个铁球跟这个是一类题）" class="headerlink" title="（1） 100层楼，只有2个鸡蛋，想要判断出那一层刚好让鸡蛋碎掉，给出策略（滴滴笔试中两个铁球跟这个是一类题）"></a>（1） 100层楼，只有2个鸡蛋，想要判断出那一层刚好让鸡蛋碎掉，给出策略（滴滴笔试中两个铁球跟这个是一类题）</h4><ul>
<li>（给定了楼层数和鸡蛋数的情况）二分法+线性查找  从100&#x2F;2&#x3D;50楼扔起，如果破了就用另一个从0扔起直到破。如果没破就从50&#x2F;2&#x3D;25楼扔起，重复。</li>
<li>动态规划<h4 id="（2）-毒药问题，1000瓶水，其中有一瓶可以无限稀释的毒药，要快速找出哪一瓶有毒，需要几只小白鼠"><a href="#（2）-毒药问题，1000瓶水，其中有一瓶可以无限稀释的毒药，要快速找出哪一瓶有毒，需要几只小白鼠" class="headerlink" title="（2） 毒药问题，1000瓶水，其中有一瓶可以无限稀释的毒药，要快速找出哪一瓶有毒，需要几只小白鼠"></a>（2） 毒药问题，1000瓶水，其中有一瓶可以无限稀释的毒药，要快速找出哪一瓶有毒，需要几只小白鼠</h4>用二进制的思路解决问题。2的十次方是1024，使用十只小鼠喝一次即可。方法是先将每瓶水编号，同时10个小鼠分别表示二进制中的一个位。将每瓶水混合到水瓶编号中二进制为1的小鼠对应的水中。喝完后统计，将死亡小鼠对应的位置为1，没死的置为0，根据死亡小鼠的编号确定有毒的是哪瓶水，如0000001010表示10号水有毒。<h4 id="（3）"><a href="#（3）" class="headerlink" title="（3）"></a>（3）</h4><h4 id="（4）-先手必胜策略问题：100本书，每次能够拿1-5本，怎么拿能保证最后一次是你拿"><a href="#（4）-先手必胜策略问题：100本书，每次能够拿1-5本，怎么拿能保证最后一次是你拿" class="headerlink" title="（4） 先手必胜策略问题：100本书，每次能够拿1-5本，怎么拿能保证最后一次是你拿"></a>（4） 先手必胜策略问题：100本书，每次能够拿1-5本，怎么拿能保证最后一次是你拿</h4>寻找每个回合固定的拿取模式。最后一次是我拿，那么上个回合最少剩下6本。那么只要保持每个回合结束后都剩下6的倍数，并且在这个回合中我拿的和对方拿的加起来为6（这样这个回合结束后剩下的还是6的倍数），就必胜。关键是第一次我必须先手拿（100%6&#x3D;4）本（这不算在第一回合里面）。<h4 id="（5）-放n只蚂蚁在一条树枝上，蚂蚁与蚂蚁之间碰到就各自往反方向走，问总距离或者时间。"><a href="#（5）-放n只蚂蚁在一条树枝上，蚂蚁与蚂蚁之间碰到就各自往反方向走，问总距离或者时间。" class="headerlink" title="（5） 放n只蚂蚁在一条树枝上，蚂蚁与蚂蚁之间碰到就各自往反方向走，问总距离或者时间。"></a>（5） 放n只蚂蚁在一条树枝上，蚂蚁与蚂蚁之间碰到就各自往反方向走，问总距离或者时间。</h4>碰到就当没发生，继续走，相当于碰到的两个蚂蚁交换了一下身体。其实就是每个蚂蚁从当前位置一直走直到停止的总距离或者时间。<h4 id="（6）-瓶子换饮料问题：1000瓶饮料，3个空瓶子能够换1瓶饮料，问最多能喝几瓶"><a href="#（6）-瓶子换饮料问题：1000瓶饮料，3个空瓶子能够换1瓶饮料，问最多能喝几瓶" class="headerlink" title="（6） 瓶子换饮料问题：1000瓶饮料，3个空瓶子能够换1瓶饮料，问最多能喝几瓶"></a>（6） 瓶子换饮料问题：1000瓶饮料，3个空瓶子能够换1瓶饮料，问最多能喝几瓶</h4>拿走3瓶，换回1瓶，相当于减少2瓶。但是最后剩下4瓶的时候例外，这时只能换1瓶。所以我们计算1000减2能减多少次，直到剩下4.（1000-4&#x3D;996，996&#x2F;2&#x3D;498）所以1000减2能减498次直到剩下4瓶，最后剩下的4瓶还可以换一瓶，所以总共是1000+498+1&#x3D;1499瓶。<h4 id="（7）在24小时里面时针分针秒针可以重合几次"><a href="#（7）在24小时里面时针分针秒针可以重合几次" class="headerlink" title="（7）在24小时里面时针分针秒针可以重合几次"></a>（7）在24小时里面时针分针秒针可以重合几次</h4>24小时中时针走2圈，而分针走24圈，时针和分针重合24-2&#x3D;22次，而只要时针和分针重合，秒针一定有机会重合，所以总共重合22次<h4 id="（8）-有一个天平，九个砝码，一个轻一些，用天平至少几次能找到轻的？"><a href="#（8）-有一个天平，九个砝码，一个轻一些，用天平至少几次能找到轻的？" class="headerlink" title="（8） 有一个天平，九个砝码，一个轻一些，用天平至少几次能找到轻的？"></a>（8） 有一个天平，九个砝码，一个轻一些，用天平至少几次能找到轻的？</h4>至少2次：第一次，一边3个，哪边轻就在哪边，一样重就是剩余的3个；<br>第二次，一边1个，哪边轻就是哪个，一样重就是剩余的那个；<h4 id="（9）-有十组砝码每组十个，每个砝码重10g，其中一组每个只有9g，有能显示克数的秤最少几次能找到轻的那一组砝码？"><a href="#（9）-有十组砝码每组十个，每个砝码重10g，其中一组每个只有9g，有能显示克数的秤最少几次能找到轻的那一组砝码？" class="headerlink" title="（9） 有十组砝码每组十个，每个砝码重10g，其中一组每个只有9g，有能显示克数的秤最少几次能找到轻的那一组砝码？"></a>（9） 有十组砝码每组十个，每个砝码重10g，其中一组每个只有9g，有能显示克数的秤最少几次能找到轻的那一组砝码？</h4>砝码分组1~10，第一组拿一个，第二组拿两个以此类推。。第十组拿十个放到秤上称出克数x，则y &#x3D; 550 - x，第y组就是轻的那组<h4 id="（10）生成随机数问题：给定生成1到5的随机数Rand5-，如何得到生成1到7的随机数函数Rand7-？"><a href="#（10）生成随机数问题：给定生成1到5的随机数Rand5-，如何得到生成1到7的随机数函数Rand7-？" class="headerlink" title="（10）生成随机数问题：给定生成1到5的随机数Rand5()，如何得到生成1到7的随机数函数Rand7()？"></a>（10）生成随机数问题：给定生成1到5的随机数Rand5()，如何得到生成1到7的随机数函数Rand7()？</h4>思路：由大的生成小的容易，比如由Rand7()生成Rand5()，所以我们先构造一个大于7的随机数生成函数。<br>记住下面这个式子：<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">RandNN</span>= <span class="function"><span class="title">N</span>( <span class="title">RandN</span>()-<span class="number">1</span> ) + <span class="title">RandN</span>() ;<span class="comment">// 生成1到N^2之间的随机数</span></span></span><br><span class="line"><span class="function">可以看作是在数轴上撒豆子。<span class="variable">N</span>是跨度/步长，是<span class="title">RandN</span>()生成的数的范围长度，<span class="title">RandN</span>()-<span class="number">1</span>的目的是生成<span class="number">0</span>到<span class="variable">N</span>-<span class="number">1</span>的数，是跳数。后面+<span class="title">RandN</span>()的目的是填满中间的空隙</span></span><br></pre></td></tr></table></figure>
比如<code> Rand25= 5( Rand5()-1 ) + Rand5()</code>可以生成1到25之间的随机数。我们可以只要1到21（3*7）之间的数字，所以可以这么写<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">rand7</span>()</span>&#123;</span><br><span class="line">  <span class="built_in">int</span> x=INT_MAX;</span><br><span class="line">  <span class="keyword">while</span>(x&gt;<span class="number">21</span>)&#123;</span><br><span class="line">    x=<span class="number">5</span>*(rand5()<span class="number">-1</span>)+rand5();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x%<span class="number">7</span>+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="赛马：有25匹马，每场比赛只能赛5匹，至少要赛多少场才能找到最快的3匹马？"><a href="#赛马：有25匹马，每场比赛只能赛5匹，至少要赛多少场才能找到最快的3匹马？" class="headerlink" title="赛马：有25匹马，每场比赛只能赛5匹，至少要赛多少场才能找到最快的3匹马？"></a>赛马：有25匹马，每场比赛只能赛5匹，至少要赛多少场才能找到最快的3匹马？</h4></li>
<li>第一次，分成5个赛道ABCDE，每个赛道5匹马，每个赛道比赛一场，每个赛道的第12345名记为 A1,A2,A3,A4,A5  B1,B2,B3,B4,B5等等，这一步要赛5场。 </li>
<li>第二次，我们将每个赛道的前三名，共15匹。分成三组，然后每组进行比赛。这一步要赛3场。</li>
<li>第三次，我们取每组的前三名。共9匹，第一名赛道的马编号为1a,1b,1c，第二名赛道的马编号为2a,2b,2c，第三名赛道的马编号为3a,3b,3c。这时进行分析，1a表示第一名里面的第一名，绝对是所有马中的第一，所以不用再比了。2c表示第二名的三匹里头的最后一匹，3b和3c表示第三名里面的倒数两匹，不可能是所有马里面的前三名，所以也直接排除，剩下1b,1c,2a,2b,,3a，共5匹，再赛跑一次取第一第二名，加上刚筛选出来的1a就是所有马里面的最快3匹了。这一步要赛1场。</li>
<li>所以一共是5+3+1&#x3D;9场。<h4 id="烧-香-x2F-绳子-x2F-其他-确定时间问题：有两根不均匀的香，燃烧完都需要一个小时，问怎么确定15分钟的时长？"><a href="#烧-香-x2F-绳子-x2F-其他-确定时间问题：有两根不均匀的香，燃烧完都需要一个小时，问怎么确定15分钟的时长？" class="headerlink" title="烧 香&#x2F;绳子&#x2F;其他 确定时间问题：有两根不均匀的香，燃烧完都需要一个小时，问怎么确定15分钟的时长？"></a>烧 香&#x2F;绳子&#x2F;其他 确定时间问题：有两根不均匀的香，燃烧完都需要一个小时，问怎么确定15分钟的时长？</h4>（说了求15分钟，没说开始的15分钟还是结束的15分钟，这里是可以求最后的15分钟）点燃一根A，同时点燃另一根B的两端，当另一根B烧完的时候就是半小时，这是再将A的另一端也点燃，从这时到A燃烧完就正好15分钟。</li>
</ul>
<h4 id="掰巧克力问题-NM块巧克力，每次掰一块的一行或一列，掰成11的巧克力需要多少次？（1000个人参加辩论赛，1V1，输了就退出，需要安排多少场比赛）"><a href="#掰巧克力问题-NM块巧克力，每次掰一块的一行或一列，掰成11的巧克力需要多少次？（1000个人参加辩论赛，1V1，输了就退出，需要安排多少场比赛）" class="headerlink" title="掰巧克力问题 NM块巧克力，每次掰一块的一行或一列，掰成11的巧克力需要多少次？（1000个人参加辩论赛，1V1，输了就退出，需要安排多少场比赛）"></a>掰巧克力问题 N<em>M块巧克力，每次掰一块的一行或一列，掰成1</em>1的巧克力需要多少次？（1000个人参加辩论赛，1V1，输了就退出，需要安排多少场比赛）</h4><p>每次拿起一块巧克力，掰一下（无论横着还是竖着）都会变成两块，因为所有的巧克力共有N*M块，所以要掰N*M-1次，-1是因为最开始的一块是不用算进去的。</p>
<p>每一场辩论赛参加两个人，消失一个人，所以可以看作是每一场辩论赛减少一个人，直到最后剩下1个人，所以是1000-1&#x3D;999场。</p>
<h1 id="8-大数据"><a href="#8-大数据" class="headerlink" title="8. 大数据"></a>8. 大数据</h1><h4 id="1-介绍一下Hadoop"><a href="#1-介绍一下Hadoop" class="headerlink" title="1. 介绍一下Hadoop"></a>1. 介绍一下Hadoop</h4><p>Hadoop是一套大数据解决方案，提供了一套分布式的系统基础架构，包括HDFS，MapReduce和YARN。</p>
<ul>
<li>HDFS提供分布式的数据存储</li>
<li>MapReduce负责进行数据运算 </li>
<li>YARN负责任务调度</li>
</ul>
<p>HDFS是主从架构的，包括namenode，secondarynamenode和datanode。datanode负责存储数据，namenode负责管理HDFS的目录树和文件元信息。<br><br>MapReduce包括jobtracker,tasktracker和client。Jobtracker负责进行资源调度和作业监控。tasktracker会周期性的通过心跳向jobtracker汇报资源使用情况。</p>
<h4 id="2-说一下MapReduce的运行机制"><a href="#2-说一下MapReduce的运行机制" class="headerlink" title="2. 说一下MapReduce的运行机制"></a>2. 说一下MapReduce的运行机制</h4><p>MapReduce包括输入分片、map阶段、combine阶段、shuffle阶段和reduce阶段。分布式计算框架包括client，jobtracker和tasktracker和调度器。</p>
<ul>
<li>输入分片阶段，mapreduce会根据输入文件计算分片，每个分片对应一个map任务</li>
<li>map阶段会根据mapper方法的业务逻辑进行计算，映射成键值对</li>
<li>combine阶段是在节点本机进行一个reduce，减少传输结果对带宽的占用</li>
<li>shuffle阶段是对map阶段的结果进行分区，排序，溢出然后写入磁盘。将map端输出的无规则的数据整理成为有一定规则的数据，方便reduce端进行处理，有点像洗牌的逆过程。  <a target="_blank" rel="noopener" href="https://blog.csdn.net/ASN_forever/article/details/81233547">https://blog.csdn.net/ASN_forever/article/details/81233547</a></li>
<li>reduce阶段是根据reducer方法的业务逻辑进行计算，最终结果会存在hdfs上。</li>
</ul>
<h4 id="3-介绍一下kafka"><a href="#3-介绍一下kafka" class="headerlink" title="3. 介绍一下kafka"></a>3. 介绍一下kafka</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_29186199/article/details/80827085">https://blog.csdn.net/qq_29186199/article/details/80827085</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/student__software/article/details/81486431">https://blog.csdn.net/student__software/article/details/81486431</a></p>
<p>kafka是一个分布式消息队列，包括producer、broker和consumer。kafka会对每个消息根据topic进行归类，每个topic又会分成多个partition，消息会根据先进先出的方式存储。消费者通过offset进行消费。 </p>
<p>kafka的特点是吞吐量高，可以进行持久化，高可用。</p>
<h4 id="4-为什么kafka吞吐量高？-x2F-介绍一下零拷贝"><a href="#4-为什么kafka吞吐量高？-x2F-介绍一下零拷贝" class="headerlink" title="4. 为什么kafka吞吐量高？&#x2F;介绍一下零拷贝"></a>4. 为什么kafka吞吐量高？&#x2F;介绍一下零拷贝</h4><p>kafka吞吐量高是因为一个利用了磁盘顺序读写的特性，速度比随机读写要快很多，另一个是使用了零拷贝，数据直接在内核进行输入和输出，减少了用户空间和内核空间的切换。</p>
<p>零拷贝：传统文件读取并发送至网络的步骤是：先将文件从磁盘拷贝到内核空间，然后内核空间拷贝到用户空间的缓冲区，再从用户空间拷贝到内核空间的socket缓冲区，最后拷贝到网卡并发送。而零拷贝技术是先将文件从磁盘空间拷贝到内核缓冲区，然后直接拷贝至网卡进行发送，减少了重复拷贝操作。</p>
<h4 id="5-介绍一下spark"><a href="#5-介绍一下spark" class="headerlink" title="5. 介绍一下spark"></a>5. 介绍一下spark</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011204847/article/details/51010205">https://blog.csdn.net/u011204847/article/details/51010205</a></p>
<p>spark是一个通用内存并行计算框架。它可以在内存中对数据进行计算，效率很高，spark的数据被抽象成RDD（弹性分布式数据集）并且拥有DAG执行引擎，兼容性和通用性很好。可以和Hadoop协同工作。</p>
<h4 id="6-介绍一下spark-streaming"><a href="#6-介绍一下spark-streaming" class="headerlink" title="6. 介绍一下spark-streaming"></a>6. 介绍一下spark-streaming</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yu0_zhang0/article/details/80569946">https://blog.csdn.net/yu0_zhang0/article/details/80569946</a></p>
<p>spark-streaming是spark的核心组件之一。主要提供高效的流计算能力。spark-streaming的原理是将输入数据流以时间片进行拆分，然后经过spark引擎以类似批处理的方式处理每个时间片数据。</p>
<p>spark-streaming将输入根据时间片划分成一段一段的Dstream（也就是离散数据流），然后将每一段数据转换成RDD进行操作。 </p>
<h4 id="7-spark的transformation和action有什么区别"><a href="#7-spark的transformation和action有什么区别" class="headerlink" title="7. spark的transformation和action有什么区别"></a>7. spark的transformation和action有什么区别</h4><p>spark的算子分成transformation和action两类</p>
<ul>
<li>transformation是变换算子，这类算子不会触发提交，是延迟执行的。也就是说执行到transformation算子的时候数据并没有马上进行计算，只是记住了对RDD的逻辑操作 </li>
<li>action算子是执行算子，会出发spark提交作业，并将数据输出到spark<h4 id="8-spark常用的算子说几个"><a href="#8-spark常用的算子说几个" class="headerlink" title="8. spark常用的算子说几个"></a>8. spark常用的算子说几个</h4>spark的算子分为两类：transformation和action</li>
</ul>
<p>常用的transformation算子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// union 求并集</span></span><br><span class="line"><span class="keyword">val</span> rdd8 = rdd6.union(rdd7)</span><br><span class="line"></span><br><span class="line"><span class="comment">// intersection 求交集 </span></span><br><span class="line"><span class="keyword">val</span> rdd9 = rdd6.intersection(rdd7)</span><br><span class="line"></span><br><span class="line"><span class="comment">// join 将rdd进行聚合连接，类似数据库的join </span></span><br><span class="line"><span class="keyword">val</span> rdd3 = rdd1.join(rdd2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// map flatMap mapPartition 传入一个函数对数据集中的每一个数据进行操作 </span></span><br><span class="line"><span class="keyword">val</span> arr1 = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">val</span> arr2 = rdd1.map(_+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// countByKey reduceByKey partitionByKey 统计每个key有多少个键值对 </span></span><br></pre></td></tr></table></figure>
<p>常用的action算子</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reduce 按照一定的方法将元素进行合并 </span></span><br><span class="line"><span class="keyword">val</span> rdd2 = rdd1.reduce(_+_)</span><br><span class="line"></span><br><span class="line"><span class="comment">// collect 将RDD转换为数组</span></span><br><span class="line">rdd1.collect</span><br><span class="line"></span><br><span class="line"><span class="comment">// top 返回最大的k个元素</span></span><br><span class="line">rdd1.top(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h4 id="9-如何保证kafka的消息不丢失"><a href="#9-如何保证kafka的消息不丢失" class="headerlink" title="9. 如何保证kafka的消息不丢失"></a>9. 如何保证kafka的消息不丢失</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/liudashuang2017/article/details/88576274">https://blog.csdn.net/liudashuang2017/article/details/88576274</a></p>
<p>我们可以从三个方面保证kafka不丢失消息</p>
<ul>
<li>首先从producer生产者方面，为send()方法注册一个回调函数，可以得知消息发送有没有成功；将重试次数retrie设置为3；设置acks参数为all，当消息被写入所有同步副本之后才算发送成功。</li>
<li>在consumer消费者方面，关闭自动提交；</li>
<li>在broker集群方面，设置复制系数replica.factor为大于等于3<h4 id="10-kafka如何选举leader"><a href="#10-kafka如何选举leader" class="headerlink" title="10. kafka如何选举leader"></a>10. kafka如何选举leader</h4>首先启动的broker在zookeeper中创建一个临时节点并让自己称为leader，其他的节点会创建watch对象进行监听并成为follower，当broker宕机的时候，其他follower会尝试创建这个临时节点，但是只有一个能够创建成功，创建成功的broker就会成为leader。</li>
</ul>
<h4 id="11-说下spark中的宽依赖和窄依赖"><a href="#11-说下spark中的宽依赖和窄依赖" class="headerlink" title="11. 说下spark中的宽依赖和窄依赖"></a>11. 说下spark中的宽依赖和窄依赖</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/a1043498776/article/details/54889922">https://blog.csdn.net/a1043498776/article/details/54889922</a></p>
<ul>
<li>宽依赖：指子RDD的分区依赖于父RDD的所有分区，举例：groupbykey,join</li>
<li>窄依赖：指父RDD的每个分区被最多一个子RDD的分区所依赖,举例：map，filter<br><img src="https://img-blog.csdn.net/20170206221148299?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTEwNDM0OTg3NzY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"><h4 id="12-说下spark中stage是依照什么划分的"><a href="#12-说下spark中stage是依照什么划分的" class="headerlink" title="12. 说下spark中stage是依照什么划分的"></a>12. 说下spark中stage是依照什么划分的</h4><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/57124273">https://zhuanlan.zhihu.com/p/57124273</a></li>
</ul>
<p>spark中的stage其实是一组并行的任务，spark会将多个RDD根据依赖关系划分成有向无环图DAG，DAG会被划分成多个stage，划分的依据是RDD之间的宽窄依赖。遇到宽依赖就划分stage。因为宽依赖与窄依赖的区别之一就是宽依赖会发生shuffle操作，所以也可以说stage的划分依据是是否发生shuffle操作。</p>
<h4 id="13-spark的内存管理是怎样的"><a href="#13-spark的内存管理是怎样的" class="headerlink" title="13. spark的内存管理是怎样的"></a>13. spark的内存管理是怎样的</h4><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4f1e551553ae">https://www.jianshu.com/p/4f1e551553ae</a> </p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wzj4858/p/8204282.html">https://www.cnblogs.com/wzj4858/p/8204282.html</a></p>
<p>spark的内存包括静态内存管理和统一内存管理两种机制。静态内存管理中存储和执行两块内存区域是分开的，统一内存管理中两块内存之间可以相互借用<br></p>
<ul>
<li>静态内存管理：静态内存管理机制下堆内内存包括安全内存，存储内存，shuffle内存和unroll内存</li>
</ul>
<p><img src="/fig/spark%E5%86%85%E5%AD%98%E4%B8%80.png"></p>
<ul>
<li>统一内存管理：统一内存管理机制下内存分为spark内存，用户内存和保留内存三部分。用户内存存放用户代码逻辑和自定义数据结构等，保留内存存放的是spark的内部对象和逻辑。<br>  <img src="https://upload-images.jianshu.io/upload_images/195230-f119edabb5683f38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp"></li>
</ul>
<h4 id="14-spark的容错机制是什么样的"><a href="#14-spark的容错机制是什么样的" class="headerlink" title="14. spark的容错机制是什么样的"></a>14. spark的容错机制是什么样的</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/dengxing1234/article/details/73613484">https://blog.csdn.net/dengxing1234/article/details/73613484</a></p>
<p>spark的容错机制是通过血统（lineage）和checkpoint来实现的 。</p>
<ul>
<li>RDD的lineage可以看作是一个重做日志（redo log）记录的是它粗粒度上的transformation操作。当rdd的分区数据丢失时，它可以根据lineage重新计算来恢复数据。 在窄依赖上可以直接计算父RDD的节点数据进行恢复，在宽依赖上则要等到父RDD所有数据计算完后并将结果shuffle到子RDD上才能完成恢复。</li>
<li>如果DAG中的lineage过长，或者在宽依赖上进行checkpoint的收益更大，就会使用checkpoint进行容错，将RDD写入磁盘进行持久化存储，如果节点数据丢失，就从磁盘读取数据进行恢复。</li>
</ul>
<h1 id="9-HR面"><a href="#9-HR面" class="headerlink" title="9. HR面"></a>9. HR面</h1><h4 id="1-自我介绍"><a href="#1-自我介绍" class="headerlink" title="1. 自我介绍"></a>1. 自我介绍</h4><p>（HR面试的自我介绍可以侧重软实力部分，项目技术方面介绍可以适当少一些）</p>
<h4 id="2-项目中遇到的最大难点"><a href="#2-项目中遇到的最大难点" class="headerlink" title="2. 项目中遇到的最大难点"></a>2. 项目中遇到的最大难点</h4><ul>
<li><p>在项目中曾经遇到了新的框架不知道该如何上手的问题，以及面对新的概念，新的技术不知道从何学起。解决的办法是在官网寻找说明文档和demo，按照说明文档上的内容一步步了解，以及咨询身边有用过这个框架的同学，或者在CSDN上寻找相关博客。</p>
</li>
<li><p>项目的时间比较紧迫，没有那么多的时间可以用。解决方法是把还没有完成的项目分一个轻重缓急，在有限的时间里，先做重要而且紧急的，然后完成紧急的，再做重要的。利用轻重缓急做一个取舍。</p>
<h4 id="3-项目中的收获"><a href="#3-项目中的收获" class="headerlink" title="3. 项目中的收获"></a>3. 项目中的收获</h4><p>一个是了解了相关框架的使用方法（比如Dataframe的使用，xgboost的使用等等），这些框架或者技术可以在以后的开发中使用到。和对自己开发能力的锻炼。</p>
</li>
</ul>
<p>一个是锻炼了与他人的交流能力，因为在团队项目里经常会跟别人汇报自己的想法和进度，同时也会跟其他成员沟通模块之间的交互，所以在这个过程中对自己的表达能力和理解能力都是一个很大的提升。</p>
<h4 id="4-可以实习的时间，实习时长"><a href="#4-可以实习的时间，实习时长" class="headerlink" title="4. 可以实习的时间，实习时长"></a>4. 可以实习的时间，实习时长</h4><p>一定要往长了说！半年起步，最好七八个月，因为实习生是可以随时跑路的。而且实习时间越长HR越青睐。</p>
<h4 id="5-哪里人"><a href="#5-哪里人" class="headerlink" title="5. 哪里人"></a>5. 哪里人</h4><h4 id="6-说一下自己的性格"><a href="#6-说一下自己的性格" class="headerlink" title="6. 说一下自己的性格"></a>6. 说一下自己的性格</h4><p>我是比较内向谨慎的人，平时做的多说的少。比较善于总结，在与人交流的时候更倾向于倾听别人的意见后才发言。并且别人都说我办事认真靠谱。</p>
<h4 id="7-你的优缺点是什么"><a href="#7-你的优缺点是什么" class="headerlink" title="7. 你的优缺点是什么"></a>7. 你的优缺点是什么</h4><p>我的缺点是容易在一些细节的地方花费太多的时间，有时候过分追求细节。并且我的实习经验比较缺乏，对于实际项目的业务流程和工作流程不是很了解。（所以我打算通过实习来熟悉实际的软件开发的流程和技术。）</p>
<p>我的优点是责任心比较强，做事比较负责，在校期间我负责的大创项目进展很顺利，我经常组织组员们进行讨论和推进项目的开发，最后这个项目得到了92的评分，在同级别里面是比较高的。</p>
<h4 id="8-有什么兴趣爱好，画的怎么样-x2F-球打的如何-x2F-游戏打的怎么样"><a href="#8-有什么兴趣爱好，画的怎么样-x2F-球打的如何-x2F-游戏打的怎么样" class="headerlink" title="8. 有什么兴趣爱好，画的怎么样&#x2F;球打的如何&#x2F;游戏打的怎么样"></a>8. 有什么兴趣爱好，画的怎么样&#x2F;球打的如何&#x2F;游戏打的怎么样</h4><p>平时的爱好是画画打游戏，在CSDN写写博客，还有就是看书，我很喜欢学到新知识掌握新技能的感觉。</p>
<h4 id="9-看过最好的一本书是什么"><a href="#9-看过最好的一本书是什么" class="headerlink" title="9. 看过最好的一本书是什么"></a>9. 看过最好的一本书是什么</h4><p>技术类：编程之美 机器学习西瓜书 STL源码剖析 剑指offer C++primer plus</p>
<p>非技术类：明朝那些事儿 香水（聚斯金德） 解忧杂货店 人类简史 沉默的大多数 与时间做朋友（李笑来） 千年历史千年诗</p>
<h4 id="10-学习技术中有什么难点"><a href="#10-学习技术中有什么难点" class="headerlink" title="10. 学习技术中有什么难点"></a>10. 学习技术中有什么难点</h4><h4 id="11-怎么看待加班"><a href="#11-怎么看待加班" class="headerlink" title="11. 怎么看待加班"></a>11. 怎么看待加班</h4><p>我觉得 任何一家单位都有可能要加班。如果自己的工作没有按时完成，那自觉加班是理所当然的，当然，自己要不断提高工作效率，避免这种原因导致的加班。如果遇到紧急任务或者突发状况时，为了顺利配合团队完成任务，我会尽自己所能加班共同完成。</p>
<h4 id="12-觉得深圳怎么样（或者其他地点）"><a href="#12-觉得深圳怎么样（或者其他地点）" class="headerlink" title="12. 觉得深圳怎么样（或者其他地点）"></a>12. 觉得深圳怎么样（或者其他地点）</h4><h4 id="13-遇见过最大的挫折是什么，怎么解决的"><a href="#13-遇见过最大的挫折是什么，怎么解决的" class="headerlink" title="13. 遇见过最大的挫折是什么，怎么解决的"></a>13. 遇见过最大的挫折是什么，怎么解决的</h4><h4 id="14-职业规划"><a href="#14-职业规划" class="headerlink" title="14. 职业规划"></a>14. 职业规划</h4><p>在工作的第一个阶段，先尽快适应工作的环境，包括开发环境开发工具和工作流程等，把自己负责的部分快速的完成，不能出差错。第二个阶段要熟悉整个项目的业务流程，所有模块的结构和依赖关系，知道每个模块为什么要这么设计，以及它们的实现细节。第三个阶段要培养独立设计一个项目的能力，可以独立或者在别人的协作下设计项目的模块分工和架构。</p>
<p>在工作和项目中多写博客或者笔记，积累技术影响力，将经验总结成文档。同时与同事搞好关系，尝试培养领导能力和组织能力。</p>
<h4 id="15-目前的offer情况"><a href="#15-目前的offer情况" class="headerlink" title="15. 目前的offer情况"></a>15. 目前的offer情况</h4><p>可以如实说</p>
<h4 id="16-你最大的优势和劣势是什么"><a href="#16-你最大的优势和劣势是什么" class="headerlink" title="16. 你最大的优势和劣势是什么"></a>16. 你最大的优势和劣势是什么</h4><ul>
<li>优势：做事情有主动性，不拖沓，有责任心。举个例子：在做论文课题的时候，几乎都是我自己找老师汇报进度和找老师讨论问题，很少有被老师催的时候。每一次跟老师讨论之后都会将讨论的内容和老师提出的意见进行详细记录。在中软杯的比赛中，主动承担答辩ppt的制作，并且每次排练之后都迅速对ppt的修改意见进行落实修改，前前后后改了十几版。</li>
<li>劣势：有时候做事情比较急躁，容易导致粗心。<h4 id="17-介绍在项目里面充当的角色"><a href="#17-介绍在项目里面充当的角色" class="headerlink" title="17. 介绍在项目里面充当的角色"></a>17. 介绍在项目里面充当的角色</h4><h4 id="18-介绍一下本科获得的全国赛奖项的情况"><a href="#18-介绍一下本科获得的全国赛奖项的情况" class="headerlink" title="18. 介绍一下本科获得的全国赛奖项的情况"></a>18. 介绍一下本科获得的全国赛奖项的情况</h4><h4 id="19-最有成就感的事情-x2F-最骄傲的一件事情"><a href="#19-最有成就感的事情-x2F-最骄傲的一件事情" class="headerlink" title="19. 最有成就感的事情&#x2F;最骄傲的一件事情"></a>19. 最有成就感的事情&#x2F;最骄傲的一件事情</h4></li>
<li>本科的时候跟优秀的队友们一起参加中国软件杯比赛努力了四个月，最后获得了该赛题的第一名和全国一等奖的好成绩</li>
<li>保研夏令营拿到了四个学校的offer<h4 id="20-在实验室中担任什么角色，参加的XXX能聊聊吗"><a href="#20-在实验室中担任什么角色，参加的XXX能聊聊吗" class="headerlink" title="20. 在实验室中担任什么角色，参加的XXX能聊聊吗"></a>20. 在实验室中担任什么角色，参加的XXX能聊聊吗</h4><h4 id="22-用两个词来形容自己"><a href="#22-用两个词来形容自己" class="headerlink" title="22. 用两个词来形容自己"></a>22. 用两个词来形容自己</h4>踏实 认真</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cachefish.github.io/2022/02/22/1-%E4%BB%A3%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2229.jfif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="来世做春风，浪漫且自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cachecatのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/22/1-%E4%BB%A3%E7%90%86/" class="post-title-link" itemprop="url">网络代理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-22 19:30:00" itemprop="dateCreated datePublished" datetime="2022-02-22T19:30:00+08:00">2022-02-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-03 09:19:27" itemprop="dateModified" datetime="2022-03-03T09:19:27+08:00">2022-03-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/network/" itemprop="url" rel="index"><span itemprop="name">network</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="两种代理"><a href="#两种代理" class="headerlink" title="两种代理"></a>两种代理</h2><p>正向代理（Forward Proxy）<br>一般来说都是直接叫做『代理』，代理是什么呢？</p>
<blockquote>
<p>正向代理是指用户利用代理服务器访问目标服务器。</p>
</blockquote>
<hr>
<p>正向代理的用处主要有以下几种：</p>
<p>访问『404』网站<br>这种情况下，就类似饿了么『跑腿代购』，我们并不能直接在网上购买香烟这类禁止网上销售或者没有在外卖平台上架的商品（404），但是我们可以通过骑手（代理服务器），去指定的店铺（目标服务器）购买我们需要的东西（目标资源），送到我们面前。</p>
<p>加速访问<br>比较常见的便是『网游加速器』，比如《吃鸡》这种国外游戏产商的游戏服务器一般部署在国外，我们家里的网络环境如果直接进行游戏，『延迟』『卡顿』会伴随着我们整个游戏过程。<br>通过连接游戏加速器提供的代理服务器，利用代理服务器和目标游戏服务器之间优化过、甚至是专线的网络，我们便能愉快『吃鸡』了。</p>
<hr>
<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><blockquote>
<p>正向代理代理的是用户，而反向代理则相反，代理对象是目标服务器，是指服务端利用代理服务器给用户提供服务。</p>
</blockquote>
<hr>
<p>和正向代理相比，二者都是利用代理服务器实现的，不过反向代理的主语是服务端，所以说反向代理对于用户来说是透明的，在用户的视野里，代理服务器便是目标服务器。</p>
<p>类似饿了么『专星送』服务，我们（用户）在想喝咖啡的时候，并不需要知道我们附近哪个广场哪个角落有家星巴克（目标服务器），我们只需要打开专星送（代理服务器），直接下单就是，其会自动分配合适的门店为我们提供咖啡。</p>
<p>从上面的例子可以想到，反向代理在实际应用可以起到保护和隐藏真正提供服务的那个星巴克门店，也可以在区域分店爆单或者停业时，对用户的需要提供负载均衡，自动派单给相近的门店。</p>
<hr>
<h3 id="四层代理（L4-Switch-四层交换）"><a href="#四层代理（L4-Switch-四层交换）" class="headerlink" title="四层代理（L4 Switch 四层交换）"></a>四层代理（L4 Switch 四层交换）</h3><p>这个四层指的便是『运输层』，我们的四层代理服务器在接收到数据报文后会进行拆包工作，且只做到第4层运输层。</p>
<p>在运输层拆包拿到的数据报文，除了包括应用层需要的数据报文，在标头信息中包括了端口信息，再结合网络层拆包所得的 IP，通常是根据这个 IP+PORT 得到实际的目标服务器信息，再修改报文的 IP 地址为目标服务器的 IP 地址信息。</p>
<p>所以说，如果数据报文是个 TCP 连接，客户端最终将与真实的目标服务器建立连接。</p>
<h3 id="七层代理（L7-Switch-七层交换）"><a href="#七层代理（L7-Switch-七层交换）" class="headerlink" title="七层代理（L7 Switch 七层交换）"></a>七层代理（L7 Switch 七层交换）</h3><p>七层代理便是指拆包到应用层后，再根据应用层数据特征来判断目标服务器。举个栗子，Nginx 便是我们经常用来搭建七层代理的服务器软件，我们在访问一个 URL 里，Nginx 会根据 URL 进行判断，分配请求到目标服务器</p>
<p>因为七层代理依赖应用层信息，所以用户在访问网站的时候，会先与七层代理服务器三次握手建立连接，再发送具体的请求报文给代理服务器，代理服务器再跟目标服务器三次握手建立连接，然后由代理服务器来访问目标服务器。</p>
<h3 id="其他层代理"><a href="#其他层代理" class="headerlink" title="其他层代理"></a>其他层代理</h3><p>既然有四层、七层代理，那么当然是有二层和三层代理<br>二层代理是根据数据链路层报文的 MAC 地址完成代理（一般称为二层转发）<br>三层代理则根据网络层报文的 IP 地址完成数据交换</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cachefish.github.io/2022/02/22/2-%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E4%BF%A1%E6%81%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2229.jfif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="来世做春风，浪漫且自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cachecatのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/22/2-%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E4%BF%A1%E6%81%AF/" class="post-title-link" itemprop="url">网络端口占用信息</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-22 19:30:00" itemprop="dateCreated datePublished" datetime="2022-02-22T19:30:00+08:00">2022-02-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-03 09:19:33" itemprop="dateModified" datetime="2022-03-03T09:19:33+08:00">2022-03-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/network/" itemprop="url" rel="index"><span itemprop="name">network</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><input checked="" disabled="" type="checkbox"> 1端口  -  tcpmux</li>
<li><input checked="" disabled="" type="checkbox"> 7端口  -  echo</li>
<li><input checked="" disabled="" type="checkbox"> 9端口  -  discard</li>
<li><input checked="" disabled="" type="checkbox"> 11端口  -  systat</li>
<li><input checked="" disabled="" type="checkbox"> 13端口  -  daytime</li>
<li><input checked="" disabled="" type="checkbox"> 15端口  -  netstat</li>
<li><input checked="" disabled="" type="checkbox"> 17端口  -  qotd</li>
<li><input checked="" disabled="" type="checkbox"> 19端口  -  chargen</li>
<li><input checked="" disabled="" type="checkbox"> 20端口  -  ftp data</li>
<li><input checked="" disabled="" type="checkbox"> 21端口  -  ftp access</li>
<li><input checked="" disabled="" type="checkbox"> 22端口  -  ssh</li>
<li><input checked="" disabled="" type="checkbox"> 23端口  -  telnet</li>
<li><input checked="" disabled="" type="checkbox"> 25端口  -  smtp</li>
<li><input checked="" disabled="" type="checkbox"> 37端口  -  time</li>
<li><input checked="" disabled="" type="checkbox"> 42端口  -  name</li>
<li><input checked="" disabled="" type="checkbox"> 43端口  -  nicname</li>
<li><input checked="" disabled="" type="checkbox"> 53端口  -  domain</li>
<li><input checked="" disabled="" type="checkbox"> 69端口  -  tftp</li>
<li><input checked="" disabled="" type="checkbox"> 77端口  -  priv-rjs</li>
<li><input checked="" disabled="" type="checkbox"> 79端口  -  finger</li>
<li><input checked="" disabled="" type="checkbox"> 87端口  -  ttylink</li>
<li><input checked="" disabled="" type="checkbox"> 95端口  -  supdup</li>
<li><input checked="" disabled="" type="checkbox"> 101端口  -  hostriame</li>
<li><input checked="" disabled="" type="checkbox"> 102端口  -  iso-tsap</li>
<li><input checked="" disabled="" type="checkbox"> 103端口  -  gppitnp</li>
<li><input checked="" disabled="" type="checkbox"> 104端口  -  acr-nema</li>
<li><input checked="" disabled="" type="checkbox"> 109端口  -  pop2</li>
<li><input checked="" disabled="" type="checkbox"> 110端口  -  pop3</li>
<li><input checked="" disabled="" type="checkbox"> 111端口  -  sunrpc</li>
<li><input checked="" disabled="" type="checkbox"> 113端口  -  auth</li>
<li><input checked="" disabled="" type="checkbox"> 115端口  -  sftp</li>
<li><input checked="" disabled="" type="checkbox"> 117端口  -  uucp-path</li>
<li><input checked="" disabled="" type="checkbox"> 119端口  -  nntp</li>
<li><input checked="" disabled="" type="checkbox"> 123端口  -  NTP</li>
<li><input checked="" disabled="" type="checkbox"> 135端口  -  loc-srv &#x2F;epmap</li>
<li><input checked="" disabled="" type="checkbox"> 137端口  -  netbios</li>
<li><input checked="" disabled="" type="checkbox"> 139端口  -  netbios</li>
<li><input checked="" disabled="" type="checkbox"> 143端口  -  imap2</li>
<li><input checked="" disabled="" type="checkbox"> 161端口  -  snmp</li>
<li><input checked="" disabled="" type="checkbox"> 179端口  -  BGP</li>
<li><input checked="" disabled="" type="checkbox"> 389端口  -  ldap</li>
<li><input checked="" disabled="" type="checkbox"> 427端口  -  SLP (Also used by Apple Filing Protocol)</li>
<li><input checked="" disabled="" type="checkbox"> 465端口  -  smtp+ssl</li>
<li><input checked="" disabled="" type="checkbox"> 512端口  -  print &#x2F; exec</li>
<li><input checked="" disabled="" type="checkbox"> 513端口  -  login</li>
<li><input checked="" disabled="" type="checkbox"> 514端口  -  shell</li>
<li><input checked="" disabled="" type="checkbox"> 515端口  -  printer</li>
<li><input checked="" disabled="" type="checkbox"> 526端口  -  tempo</li>
<li><input checked="" disabled="" type="checkbox"> 530端口  -  courier</li>
<li><input checked="" disabled="" type="checkbox"> 531端口  -  chat</li>
<li><input checked="" disabled="" type="checkbox"> 532端口  -  netnews</li>
<li><input checked="" disabled="" type="checkbox"> 540端口  -  uucp</li>
<li><input checked="" disabled="" type="checkbox"> 548端口  -  AFP (Apple Filing Protocol)</li>
<li><input checked="" disabled="" type="checkbox"> 554端口  -  rtsp</li>
<li><input checked="" disabled="" type="checkbox"> 556端口  -  remotefs</li>
<li><input checked="" disabled="" type="checkbox"> 563端口  -  nntp+ssl</li>
<li><input checked="" disabled="" type="checkbox"> 587端口  -  smtp (rfc6409)</li>
<li><input checked="" disabled="" type="checkbox"> 601端口  -  syslog-conn (rfc3195)</li>
<li><input checked="" disabled="" type="checkbox"> 636端口  -  ldap+ssl</li>
<li><input checked="" disabled="" type="checkbox"> 993端口  -  ldap+ssl</li>
<li><input checked="" disabled="" type="checkbox"> 995端口  -  pop3+ssl</li>
<li><input checked="" disabled="" type="checkbox"> 1719端口  -  h323gatestat</li>
<li><input checked="" disabled="" type="checkbox"> 1720端口  -  h323hostcall</li>
<li><input checked="" disabled="" type="checkbox"> 1723端口  -  pptp</li>
<li><input checked="" disabled="" type="checkbox"> 2049端口  -  nfs</li>
<li><input checked="" disabled="" type="checkbox"> 3659端口  -  apple-sasl &#x2F; PasswordServer</li>
<li><input checked="" disabled="" type="checkbox"> 4045端口  -  lockd</li>
<li><input checked="" disabled="" type="checkbox"> 5060端口  -  sip</li>
<li><input checked="" disabled="" type="checkbox"> 5061端口  -  sips</li>
<li><input checked="" disabled="" type="checkbox"> 6000端口  -  X11</li>
<li><input checked="" disabled="" type="checkbox"> 6566端口  -  sane-port</li>
<li><input checked="" disabled="" type="checkbox"> 6665端口  -  Alternate IRC [Apple addition]</li>
<li><input checked="" disabled="" type="checkbox"> 6666端口  -  Alternate IRC [Apple addition]</li>
<li><input checked="" disabled="" type="checkbox"> 6667端口  -  Standard IRC [Apple addition]</li>
<li><input checked="" disabled="" type="checkbox"> 6668端口  -  Alternate IRC [Apple addition]</li>
<li><input checked="" disabled="" type="checkbox"> 6669端口  -  Alternate IRC [Apple addition]</li>
<li><input checked="" disabled="" type="checkbox"> 6697端口  -  IRC + TLS</li>
<li><input checked="" disabled="" type="checkbox"> 10080端口  -  Amanda</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cachefish.github.io/2022/02/22/9-tcp%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2229.jfif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="来世做春风，浪漫且自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cachecatのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/22/9-tcp%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/" class="post-title-link" itemprop="url">tcp正向代理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-22 19:30:00" itemprop="dateCreated datePublished" datetime="2022-02-22T19:30:00+08:00">2022-02-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-03 09:20:27" itemprop="dateModified" datetime="2022-03-03T09:20:27+08:00">2022-03-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/network/" itemprop="url" rel="index"><span itemprop="name">network</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>代理服务器可谓是无处不在。许多爬虫需要大量的 TCP 代理来伪造自己的 IP 地址，从而防止因为访问过快而被网站拉入黑名单。这里主要介绍代理服务器原理以及服务器端的基础。</p>
<h2 id="2-简单的代理模型介绍"><a href="#2-简单的代理模型介绍" class="headerlink" title="2.简单的代理模型介绍"></a>2.简单的代理模型介绍</h2><h3 id="2-1-使用-Socks5-协议的架构"><a href="#2-1-使用-Socks5-协议的架构" class="headerlink" title="2.1 使用 Socks5 协议的架构"></a>2.1 使用 Socks5 协议的架构</h3><p>Chrome 可以安装一个 SwitchyOmega 插件来更好地支持 Socks5 协议的代理。他的架构如下：</p>
<p>浏览器&lt;—&gt;代理服务器&lt;—&gt;饿了么网站</p>
<hr>
<p>浏览器在开启代理模式下，当打开一个网站时，会先连上代理服务器，并进行必要的握手步骤。 Socks5 的握手分两步。</p>
<ol>
<li><p>第一步握手是无聊且几乎固定的问答，俗称「对暗号」。</p>
</li>
<li><p>第二步握手, 浏览器发给代理服务器的报文中会包含需要代访问的 IP 地址（或者域名）。代理服务器连接（connect）上饿了么网站服务器后，会发送响应报文给浏览器，告诉他成功了 。</p>
</li>
</ol>
<p>到现在，握手完成。浏览器会发送数据给代理服务器，代理服务器将 TCP 报文原封不动发送给饿了么网站， 再将饿了么网站返回的数据也原封不动返回给浏览器。浏览器最终将页面渲染并显示在屏幕上。代理服务器甚至感知不到 HTTP 协议的存在，因为它只做 TCP 字节流的转发。</p>
<hr>
<h2 id="2-2-使用-Shadowsocks-协议的架构"><a href="#2-2-使用-Shadowsocks-协议的架构" class="headerlink" title="2.2 使用 Shadowsocks 协议的架构"></a>2.2 使用 Shadowsocks 协议的架构</h2><p>Shadowsocks 将 2.2 的代理服务器拆分成两部分，一部分依然在本机，我们称之为 SSlocal ，一部分设在远程，我们称它为 SSServer 。由于 2.2 的协议传输的都是明文，Shadowsocks 对数据的转发进行了加密混淆处理。他虽然不能保证绝对安全，但至少能尽量混淆数据。</p>
<hr>
<p>浏览器&lt;—&gt;SSlocal&lt;—&gt;SSServer&lt;—&gt;网站<br>Shadowsocks 也有握手过程，和 Socks5 的协议比较像，这节不做重点介绍。在握手成功后，代理会执行转发任务。SSlocal 会将浏览器发来的数据加密，发送给 SSServer ， SSServer 把数据解密后发给网站。返回来的数据也是同理，都会有个加密解密的过程。一般来说比较建议用 AES-256-CFB 这种比较安全的加密方式。</p>
<hr>
<h2 id="3-TCP-服务端程序并发模型"><a href="#3-TCP-服务端程序并发模型" class="headerlink" title="3. TCP 服务端程序并发模型"></a>3. TCP 服务端程序并发模型</h2><p>代理服务器如果用的人多，那么并发压力就会很大。不同的语言有不同的最佳模型。</p>
<h3 id="3-1-多线程同步阻塞式"><a href="#3-1-多线程同步阻塞式" class="headerlink" title="3.1 多线程同步阻塞式"></a>3.1 多线程同步阻塞式</h3><p>多线程同步式通常用一个线程处理一个 TCP 连接。现如今的多线程同步，很少再用 pthread 里的线程去写并发，因为一个线程栈可能 8Mib，线程一多内存就撑不住了。再加上线程切换的开销，使得这种传统的并发方式连 10k 都够呛。一般来说，线程数等于 CPU 核心数的时候，线程切换的开销最小。</p>
<p>好在 Golang 里有轻量级的 Goroutine 替代传统线程，使得这种同步模型实现高并发成为可能。通常这种同步阻塞式写法如下：</p>
<p>&#x2F;&#x2F; go 伪代码<br>func main() {<br>    while (true) {<br>        conn &#x3D; acceptor.accept()<br>        go handleConn(conn)<br>    }<br>}<br>func handleConn(conn) {<br>    &#x2F;&#x2F; 第一次握手<br>    err &#x3D; handshake(conn)<br>    checkError(err)<br>    addr, port &#x3D; getAddr(conn)<br>    &#x2F;&#x2F; 尝试连接客户端发来的 IP 地址<br>    server, err &#x3D; connect(addr, port)<br>    checkError(err)<br>    &#x2F;&#x2F; 成功连上要通知客户端，这里省略代码<br>    …<br>    &#x2F;&#x2F; 将客户端发来的消息发送至远程服务器<br>    go io.Copy(server, conn)<br>    &#x2F;&#x2F; 将服务端发来的消息转发至客户端<br>    io.Copy(conn, server)<br>}</p>
<hr>
<p>说明：通常主函数就是一个大循环，有新连接就开个 Goroutine 处理这个客户端连接。客户端连接先进行握手后会发送想要访问的目的服务器地址，代理服务器先尝试 connect ，成功连接上则通知客户端，客户端开始发送真正的数据。这时候做一下数据的转发就可以了。由于 TCP 是全双工的协议，收发独立，再加上 Goroutine 已经相当廉价了，所以可以开启两个 Goroutine， 一个负责收，一个负责发，互相不影响。不可以开启多个线程（Goroutine）去对同一个 TCP 连接并行地发送数据，因为这样发送的数据是交错在一起的，是错误的。</p>
<hr>
<h2 id="3-2-Reactor-同步非阻塞"><a href="#3-2-Reactor-同步非阻塞" class="headerlink" title="3.2 Reactor 同步非阻塞"></a>3.2 Reactor 同步非阻塞</h2><p>一般来说，在 Linux 下，C&#x2F;C++，Python 这种比较多使用 Reactor 模式。 Reactor 通常是一个主线程大循环，由于使用了 I&#x2F;O 多路复用技术，使得单线程也能有很好的 I&#x2F;O 性能。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c++伪代码</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        err, events = poller.wait(interval)</span><br><span class="line">        processTimerTask() <span class="comment">//处理定时器任务</span></span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="comment">//处理错误</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">event</span> : events) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">event</span>.isReadable()) &#123;</span><br><span class="line">                <span class="comment">//处理读事件</span></span><br><span class="line">                handleRead(<span class="keyword">event</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">event</span>.isWriteable()) &#123;</span><br><span class="line">                <span class="comment">//处理写事件</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">event</span>.isClosed()) &#123;</span><br><span class="line">                <span class="comment">//处理关闭套接字事件</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">event</span>.hasError()) &#123;</span><br><span class="line">                <span class="comment">//处理错误事件</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>poller 底层一般有 select，epoll 等。通常情况下使用 epoll 性能最好。单线程可以很容易支撑好几万并发。</p>
<h2 id="3-2-1-「异步」代码的「保存上下文」"><a href="#3-2-1-「异步」代码的「保存上下文」" class="headerlink" title="3.2.1 「异步」代码的「保存上下文」"></a>3.2.1 「异步」代码的「保存上下文」</h2><p>无论是 Proactor 还是 Reactor ，凡是接近 Node.js 那种异步的写法，都需要主动保存「上下文」在自己的内存中。「上下文」通常包含没收完整的数据 buffer ，目前的状态 state。</p>
<p>&#x2F;&#x2F;c++伪代码<br>struct ConnContext {<br>    Buffer buffer; &#x2F;&#x2F; 接收的消息（可能还不是一个完整的消息）<br>    State state;   &#x2F;&#x2F; 状态<br>}</p>
<hr>
<p>read 函数一次性读的字节数也是不确定的，有时需要多次调用 read 才能接受完完整的数据。由于数据不完整，并不能执行接下来的流程，所以要先把数据缓存在一个地方，然后无奈返回。等数据接收完整了，才能进入下一个处理程序。一般每个连接都有一个上下文，由 map 保存对应关系。有些协议实现起来状态比较多，比如有好几次握手，必要时还需要使用状态机保存状态。每次有读事件的时候，都会调用 handleRead 函数，这时候根据之前保存的状态，很容易恢复到之前执行的函数的位置（通过switch case分发）。</p>
<hr>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c++ 伪代码</span></span><br><span class="line"><span class="keyword">void</span> handleRead(conn) &#123;</span><br><span class="line">    <span class="keyword">context</span> = contexts[conn]</span><br><span class="line">    switch (<span class="keyword">context</span><span class="variable">.state</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> eSTATE_HANDSHAKE1:</span><br><span class="line">            handshake1(conn, <span class="keyword">context</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> eSTATE_HANDSHAKE2:</span><br><span class="line">            handshake2(conn, <span class="keyword">context</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment">// 省略</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> handshake1(conn, <span class="keyword">context</span>) &#123;</span><br><span class="line">    data = read_some(conn)</span><br><span class="line">    append(<span class="keyword">context</span><span class="variable">.buffer</span>, data)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">context</span><span class="variable">.buffer</span> 不是一个完整的数据) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发送一些东西</span></span><br><span class="line">    send_some(...)</span><br><span class="line">    <span class="comment">// 将 context.buffer 处理过的数据清理掉</span></span><br><span class="line">    <span class="comment">// 现在handleshake1状态结束了，更改为下一个状态</span></span><br><span class="line">    <span class="keyword">context</span><span class="variable">.state</span> = eSTATE_HANDSHAKE2</span><br><span class="line">    <span class="comment">// 下一次读事件将会调用 handshake2 函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-2-gethostbyname-是阻塞的"><a href="#3-2-2-gethostbyname-是阻塞的" class="headerlink" title="3.2.2 gethostbyname 是阻塞的"></a>3.2.2 gethostbyname 是阻塞的</h2><p>由于用到了域名，所以需要 DNS 服务将域名转换成为 IP 地址。</p>
<p>Linux 下 gethostbyname 似乎是阻塞的。这与同步非阻塞式的代码可谓格格不入。可以换一个非阻塞的实现。除此之外，Golang的 DNS 函数库并没有做缓存处理，这就意味着可能会频繁访问 DNS 服务器，速度没有优势，可能对 DNS 服务器也是个不小的负担。所以可以自行设计一个 DNS 缓存，是个不错的主意。</p>
<h2 id="4-TCP协议"><a href="#4-TCP协议" class="headerlink" title="4. TCP协议"></a>4. TCP协议</h2><p>假设读者对 TCP 协议有了基本了解，知道滑动窗口，知道拥塞控制。</p>
<h3 id="4-1-滑动窗口与数据转发"><a href="#4-1-滑动窗口与数据转发" class="headerlink" title="4.1 滑动窗口与数据转发"></a>4.1 滑动窗口与数据转发</h3><p>我们再看一下这个结构：</p>
<p>浏览器&lt;—&gt;代理服务器&lt;—&gt;饿了么网站<br>考虑一下这个情况，浏览器和代理服务器连通速度很好，收发很快；而代理服务器和饿了么站点收发很慢。这样一个收发速度不相等的情况，会出现怎样的问题？</p>
<hr>
<ol>
<li><p>对于阻塞同步模型，基本上不用考虑这个问题。因为他的收和发是串行的，这意味着它会自动调整滑动窗口大小。当代理服务器收到了浏览器的10Kib数据，代理服务器就会慢慢发送这10Kib数据给饿了么网站，这时候如果浏览器还想发数据给代理服务器，只会保存在代理服务器的内核缓冲区里，由于代理服务器程序在执行发送的任务（顾不上收数据），并没有从缓冲区取数据，缓冲区的数据会越来越多，剩余空间越来越小，在TCP层面，就会通知调整滑动窗口大小。当读缓冲区满了以后，通知滑动窗口为0，客户端就会停止发送数据。等代理服务器发送完数据，开始从缓冲区取浏览器的数据，浏览器到代理服务器的发送窗口又会从0变大，浏览器又可以发送数据了。</p>
</li>
<li><p>对于非阻塞模型，这是一个大问题。由于没有阻塞功能，代理服务器会一个劲儿的收下浏览器的所有数据，读取内核缓冲区的数据，再转发数据，并保存在自己的某个缓冲区中（sendBuffer）。有点类似于生产者消费者模型，生产得快，消费得慢，内存会一直膨胀下去。其实我们很容易做1情况的模拟，只要发现 sendBuffer 过大就停止读缓冲区的数据，等 sendBuffer 消下去了再开始读就行了。</p>
</li>
</ol>
<hr>
<h2 id="4-2-TCP-可靠性"><a href="#4-2-TCP-可靠性" class="headerlink" title="4.2 TCP 可靠性"></a>4.2 TCP 可靠性</h2><p>TCP 可靠性体现在不乱，不重，不漏。他能很好地防止报文意外丢失，但不能100%防止人为篡改报文，当报文+校验和一起被替换，还是很难被察觉的。TCP 可靠传输并不等于他有数据安全，这是两个概念。但事实上，TCP 在不断发展。 它的 29 号选项 TCP Authentication Option 使用了 SHA 哈希大大提高了篡改数据的难度。对于一个代理服务器来说，只需要单纯转发数据就可以，可以不用过于关心数据的篡改问题。</p>
<h2 id="tcp代理服务"><a href="#tcp代理服务" class="headerlink" title="tcp代理服务"></a>tcp代理服务</h2><p>proxy server接收client的tcp链接请求，并把client端的数据发送给代理服务器，代理服务器把数据发送给后端的被代理服务器server1…serverN，并把server1…serverN的执行结果再返回给client。</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">              |<span class="string">-----------------</span>|<span class="string">            </span>|<span class="string">---------------</span>|<span class="string"> </span></span><br><span class="line"><span class="string">client &lt;-----&gt;  </span>|<span class="string"> proxy server    </span>|<span class="string"> &lt;-----&gt;    </span>|<span class="string">     server 1  </span>|</span><br><span class="line">                |<span class="string">-----------------</span>|<span class="string">            </span>|<span class="string">---------------</span>|</span><br><span class="line">                            /|<span class="string">\                   ... ...</span></span><br><span class="line"><span class="string">                             </span>|<span class="string">                 </span>|<span class="string">---------------</span>|</span><br><span class="line">                             |<span class="string">----------------&gt;</span>|<span class="string">     server N  </span>|</span><br><span class="line">                                               |<span class="string">---------------</span>|</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cachefish.github.io/2022/02/21/7-markdown%E8%AF%AD%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2229.jfif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="来世做春风，浪漫且自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cachecatのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/21/7-markdown%E8%AF%AD%E6%B3%95/" class="post-title-link" itemprop="url">初学markdown语法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-21 19:30:00" itemprop="dateCreated datePublished" datetime="2022-02-21T19:30:00+08:00">2022-02-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-03 09:20:20" itemprop="dateModified" datetime="2022-03-03T09:20:20+08:00">2022-03-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>Markdown 中，你只需要在文本前面加上 # 即可，同理、你还可以增加二级标题、三级标题、四级标题、五级标题和六级标题，总共六级，只需要增加 # 即可，标题字号相应降低。例如：</p>
<pre><code># 一级标题
## 二级标题
### 三级标题
#### 四级标题
##### 五级标题
###### 六级标题 
</code></pre>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>在 Markdown 中，在文字前面加上 -  ，例如：</p>
<pre><code>- 文本1
- 文本2
- 文本3
</code></pre>
<p>如果你希望有序列表，<br>也可以在文字前面加上 1. 2. 3. 就可以了，例如:</p>
<pre><code>1. 文本1
2. 文本2
3. 文本3
</code></pre>
<h2 id="链接与图片"><a href="#链接与图片" class="headerlink" title="链接与图片"></a>链接与图片</h2><hr>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">&quot;picture&quot;</span>&gt;</span> 链接和图片<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>
<hr>
<p>在 Markdown 中，插入链接不需要其他按钮，你只需要使用 <a href="%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80">显示文本</a> 这样的语法即可，例如：<code>[简书](http://www.jianshu.com)</code><br>在 Markdown 中，插入图片不需要其他按钮，你只需要使用 <img src="/%E5%9B%BE%E7%89%87%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80"> 这样的语法即可，例如：<code> ![](http://upload-images.jianshu.io/upload_images/259-0ad0d0bfc1c608b6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</code></p>
<p>注：插入图片的语法和链接的语法很像，只是前面多了一个 ！</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>在我们写作的时候经常需要引用他人的文字，这个时候引用这个格式就很有必要了，在 Markdown 中，你只需要在你希望引用的文字前面加上 &gt; 就好了，例如：</p>
<pre><code>&gt; 一盏灯， 一片昏黄； 一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。
注：&gt; 和文本之间要保留一个字符的空格 **
</code></pre>
<h2 id="粗体和斜体"><a href="#粗体和斜体" class="headerlink" title="粗体和斜体"></a>粗体和斜体</h2><p>用两个 * 包含一段文本就是粗体的语法，用一个 * 包含一段文本就是斜体的语法。例如：</p>
<pre><code>*一盏灯*， 一片昏黄；
**一简书**，
一杯淡茶。 
守着那一份淡定， 品读属于自己的寂寞。
保持淡定， 才能欣赏到最美丽的风景！
保持淡定， 人生从此不再寂寞。
</code></pre>
<h2 id="代码引用"><a href="#代码引用" class="headerlink" title="代码引用"></a>代码引用</h2><p>需要引用代码时，如果引用的语句只有一段，不分行，可以用 &#96; 将语句包起来。<br>如果引用的语句为多行，可以将&#96;&#96;&#96;置于这段代码的首行和末行。</p>
<p><code>hello world</code></p>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>相关代码：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string"> Tables        </span>|<span class="string"> Are           </span>|<span class="string"> Cool  </span>|</span><br><span class="line">|<span class="string"> ------------- </span>|<span class="string">:-------------:</span>|<span class="string"> -----:</span>|</span><br><span class="line">|<span class="string"> col 3 is      </span>|<span class="string"> right-aligned </span>|<span class="string"> $1600 </span>|</span><br><span class="line">|<span class="string"> col 2 is      </span>|<span class="string"> centered      </span>|<span class="string">   $12 </span>|</span><br><span class="line">|<span class="string"> zebra stripes </span>|<span class="string"> are neat      </span>|<span class="string">    $1 </span>|</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>表头</th>
<th>表头</th>
</tr>
</thead>
<tbody><tr>
<td>单元格</td>
<td>单元格</td>
</tr>
<tr>
<td>单元格</td>
<td>单元格</td>
</tr>
</tbody></table>
<h2 id="显示链接中带括号的图片"><a href="#显示链接中带括号的图片" class="headerlink" title="显示链接中带括号的图片"></a>显示链接中带括号的图片</h2><p>![][1]<br>[1]: <a target="_blank" rel="noopener" href="http://latex.codecogs.com/gif.latex?%5Cprod%20(n_%7Bi%7D)+1">http://latex.codecogs.com/gif.latex?\prod%20(n_{i})+1</a></p>
<p>![][1]<br>[1]: <a target="_blank" rel="noopener" href="http://latex.codecogs.com/gif.latex?%5Cprod%20%5C(n_%7Bi%7D%5C)+1">http://latex.codecogs.com/gif.latex?\prod%20\(n_{i}\)+1</a></p>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">*斜体文本*</span></span><br><span class="line"><span class="emphasis">_斜体文本_</span></span><br><span class="line"><span class="strong">**粗体文本**</span></span><br><span class="line"><span class="emphasis">__粗体文本__</span></span><br><span class="line"><span class="strong">***粗斜体文本**</span>*</span><br><span class="line"><span class="emphasis">___粗斜体文本__</span>_</span><br></pre></td></tr></table></figure>

<h2 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h2><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br><span class="line"><span class="emphasis"><span class="strong">*</span> <span class="emphasis">* *</span></span></span><br><span class="line"><span class="strong">**</span><span class="strong">**<span class="emphasis">*</span></span></span><br><span class="line"><span class="emphasis"><span class="strong">- - - </span></span></span><br><span class="line"><span class="emphasis"><span class="strong"></span></span></span><br></pre></td></tr></table></figure>


<hr>
<hr>
<hr>
<hr>
<hr>
<h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><p>下划线可以通过 HTML 的<code> &lt;u&gt;</code> 标签来实现：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">u</span>&gt;</span>带下划线文本<span class="tag">&lt;/<span class="name">u</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h2><p>列表嵌套只需在子列表中的选项前面添加四个空格即可：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 第一项：</span><br><span class="line"><span class="bullet">    -</span> 第一项嵌套的第一个元素</span><br><span class="line"><span class="bullet">    -</span> 第一项嵌套的第二个元素</span><br><span class="line"><span class="bullet">2.</span> 第二项：</span><br><span class="line"><span class="bullet">    -</span> 第二项嵌套的第一个元素</span><br><span class="line"><span class="bullet">    -</span> 第二项嵌套的第二个元素</span><br><span class="line"><span class="code">    </span></span><br></pre></td></tr></table></figure>
<ol>
<li>第一项：<ul>
<li>第一项嵌套的第一个元素</li>
<li>第一项嵌套的第二个元素</li>
</ul>
</li>
<li>第二项：<ul>
<li>第二项嵌套的第一个元素</li>
<li>第二项嵌套的第二个元素</li>
</ul>
</li>
</ol>
<h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>另外区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推：</p>
<figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> <span class="language-javascript">最外层</span></span><br><span class="line"><span class="meta">&gt;</span> <span class="language-javascript">&gt; 第一层嵌套</span></span><br><span class="line"><span class="meta">&gt;</span> <span class="language-javascript">&gt; &gt; 第二层嵌套</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>最外层</p>
<blockquote>
<p>第一层嵌套</p>
<blockquote>
<p>第二层嵌套</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="区块中使用列表"><a href="#区块中使用列表" class="headerlink" title="区块中使用列表"></a>区块中使用列表</h3><p>区块中使用列表实例如下：</p>
<figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> <span class="language-javascript">区块中使用列表</span></span><br><span class="line"><span class="meta">&gt;</span> <span class="language-javascript"><span class="number">1.</span> 第一项</span></span><br><span class="line"><span class="meta">&gt;</span> <span class="language-javascript"><span class="number">2.</span> 第二项</span></span><br><span class="line"><span class="meta">&gt;</span> <span class="language-javascript">+ 第一项</span></span><br><span class="line"><span class="meta">&gt;</span> <span class="language-javascript">+ 第二项</span></span><br><span class="line"><span class="meta">&gt;</span> <span class="language-javascript">+ 第三项</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>区块中使用列表</p>
<ol>
<li>第一项</li>
<li>第二项</li>
</ol>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt=""
      src="/images/2229.jfif">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description">来世做春风，浪漫且自由</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">49</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/cachefish" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cachefish" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/cachefish@163g.com" title="E-Mail → cachefish@163g.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cachecat</span>
</div>
<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"left","width":240,"height":360},"mobile":{"show":false},"react":{"opacityDefault":1,"opacityOnHover":1},"log":false,"tagMode":false});</script></body>
</html>
