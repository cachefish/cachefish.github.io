<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cachefish.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="来世做春风，浪漫且自由">
<meta property="og:type" content="website">
<meta property="og:title" content="cachecatのBlog">
<meta property="og:url" content="https://cachefish.github.io/index.html">
<meta property="og:site_name" content="cachecatのBlog">
<meta property="og:description" content="来世做春风，浪漫且自由">
<meta property="og:locale" content="zh_CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://cachefish.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>cachecatのBlog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">cachecatのBlog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">localhost</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">8</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">8</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">23</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cachefish.github.io/2022/03/14/systemctl/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2229.jfif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="来世做春风，浪漫且自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cachecatのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/14/systemctl/" class="post-title-link" itemprop="url">linux</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-14 19:30:00" itemprop="dateCreated datePublished" datetime="2022-03-14T19:30:00+08:00">2022-03-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-02 09:32:09" itemprop="dateModified" datetime="2022-04-02T09:32:09+08:00">2022-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/systemctl/" itemprop="url" rel="index"><span itemprop="name">systemctl</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="systemctl是什么？"><a href="#systemctl是什么？" class="headerlink" title="systemctl是什么？"></a>systemctl是什么？</h3><p>在Centos 中 systemctl 是设置系统服务的命令，即 service,   它融合之前service和chkconfig的功能于一体。可以使用它永久性或只在当前会话中启用&#x2F;禁用服务。</p>
<h3 id="systemctl的功能"><a href="#systemctl的功能" class="headerlink" title="systemctl的功能"></a>systemctl的功能</h3><p>作为系统启动和服务器守护进程管理器，负责在系统启动或运行时，激活系统资源，服务器进程和其它进程<br>新特性：<br> &#x3D;&#x3D;系统引导时实现服务并行启动&#x3D;&#x3D;<br> &#x3D;&#x3D;按需启动守护进程&#x3D;&#x3D;<br> &#x3D;&#x3D;自动化的服务依赖关系管理&#x3D;&#x3D;</p>
<h4 id="systemd核心概念unit（单元）类型"><a href="#systemd核心概念unit（单元）类型" class="headerlink" title="systemd核心概念unit（单元）类型"></a>systemd核心概念unit（单元）类型</h4><p>unit表示不同类型的systemd对象，通过配置文件进行标识和配置；<br> 文件中主要包含了系统服务、监听socket、保存的系统快照以及其它与init相关的信息</p>
<h5 id="unit类型-："><a href="#unit类型-：" class="headerlink" title="unit类型  ："></a>unit类型  ：</h5><p>service ：文件扩展名为.service, 用于定义系统服务<br>target ：文件扩展名为.target，用于模拟实现运行级别<br>device  ：用于定义内核识别的设备<br>mount：定义文件系统挂载点<br>socket：用于标识进程间通信用的socket文件，也可在系统启动时，延迟启动服务，实现按需启动<br>snapshot ：管理系统快照<br>swap：用于标识swap设备<br>automount ：文件系统的自动挂载点<br>path：用于定义文件系统中的一个文件或目录使用,常用于当文件系统变化时，延迟激活服务<br>那么如何查看这些类型呢?<br>我们以target为例：<br> <img src="https://note.youdao.com/yws/res/3666/WEBRESOURCEff108212b0d8a904dc1d91e8100f4968" alt="image.png"><br>命令中的systemctl是什么呢？其实systemctl就是centos7中systemd的管理工具<br>systemctl命令的格式：systemctl COMMAND name.service     service可以省略不写<br><img src="https://note.youdao.com/yws/res/3667/WEBRESOURCE186f49f03e24dd339827df6546abbecb" alt="image.png"></p>
<ul>
<li>关闭服务    systemctl stop 服务名</li>
<li>查看服务状态    systemctl status 服务名</li>
<li>查看某服务当前的激活状态    systemctl is-active 服务名</li>
<li>查看已经激活的服务    systemctl list-units -t service</li>
<li>查看所有的服务包括开启和关闭的    systemctl list-units -t service a</li>
<li>显示当前服务的状态    systemctl list-unit-files -t service -a</li>
</ul>
<p>以上就是systemctl的一些常用命令和功能，下面是一些其他的命令以供参考：</p>
<figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">显示所有单元状态</span><br><span class="line"> <span class="string">systemctl</span> 或 <span class="string">systemctl</span> <span class="built_in">list-units</span></span><br><span class="line">只显示服务单元的状态</span><br><span class="line"> <span class="string">systemctl</span> <span class="built_in">--type=service</span></span><br><span class="line">显示<span class="string">sshd</span>服务单元</span><br><span class="line"> <span class="string">systemctl</span> –<span class="string">l</span> <span class="string">status</span> <span class="string">sshd</span>.<span class="string">service</span></span><br><span class="line">验证<span class="string">sshd</span>服务当前是否活动</span><br><span class="line"> <span class="string">systemctl</span> <span class="string">is-active</span> <span class="string">sshd</span></span><br><span class="line">启动，停止和重启<span class="string">sshd</span>服务</span><br><span class="line"> <span class="string">systemctl</span> <span class="string">start</span> <span class="string">sshd</span>.<span class="string">service</span></span><br><span class="line"> <span class="string">systemctl</span> <span class="string">stop</span> <span class="string">sshd</span>.<span class="string">service</span></span><br><span class="line"> <span class="string">systemctl</span> <span class="string">restart</span> <span class="string">sshd</span>.<span class="string">service</span></span><br><span class="line">重新加载配置</span><br><span class="line"> <span class="string">systemctl</span> <span class="string">reload</span> <span class="string">sshd</span>.<span class="string">service</span></span><br><span class="line">列出活动状态的所有服务单元</span><br><span class="line"> <span class="string">systemctl</span> <span class="built_in">list-units</span> <span class="built_in">--type=service</span></span><br><span class="line">列出所有服务单元</span><br><span class="line"> <span class="string">systemctl</span> <span class="built_in">list-units</span> <span class="built_in">--type=service</span> <span class="built_in">--all</span></span><br><span class="line">查看服务单元的启用和禁用状态</span><br><span class="line"> <span class="string">systemctl</span> <span class="built_in">list-unit-files</span> <span class="built_in">--type=service</span></span><br><span class="line">列出失败的服务</span><br><span class="line"> <span class="string">systemctl</span> <span class="built_in">--failed</span> <span class="built_in">--type=service</span></span><br><span class="line">列出依赖的单元</span><br><span class="line"> <span class="string">systemctl</span> <span class="built_in">list-dependencies</span> <span class="string">sshd</span></span><br><span class="line">验证<span class="string">sshd</span>服务是否开机启动</span><br><span class="line"> <span class="string">systemctl</span> <span class="string">is-enabled</span> <span class="string">sshd</span></span><br><span class="line">禁用<span class="string">network</span>，使之不能自动启动,但手动可以</span><br><span class="line"> <span class="string">systemctl</span> <span class="string">disable</span> <span class="string">network</span></span><br><span class="line">启用<span class="string">network</span></span><br><span class="line"> <span class="string">systemctl</span> <span class="string">enable</span> <span class="string">network</span></span><br><span class="line">禁用<span class="string">network</span>，使之不能手动或自动启动</span><br><span class="line"> <span class="string">systemctl</span> <span class="string">mask</span> <span class="string">network</span></span><br><span class="line">启用<span class="string">network</span></span><br><span class="line"> <span class="string">systemctl</span> <span class="string">unmask</span> <span class="string">network</span></span><br><span class="line">其它常用命令：</span><br><span class="line"> 传统命令<span class="string">init</span>，<span class="string">poweroff</span>，<span class="string">halt</span>，<span class="string">reboot</span>都成为</span><br><span class="line">       <span class="string">systemctl</span>的软链接</span><br><span class="line"> 关机：<span class="string">systemctl</span> <span class="string">halt</span>、<span class="string">systemctl</span> <span class="string">poweroff</span></span><br><span class="line"> 重启：<span class="string">systemctl</span> <span class="string">reboot</span></span><br><span class="line"> 挂起：<span class="string">systemctl</span> <span class="string">suspend</span></span><br><span class="line"> 休眠：<span class="string">systemctl</span> <span class="string">hibernate</span></span><br><span class="line"> 休眠并挂起：<span class="string">systemctl</span> <span class="string">hybrid-sleep</span></span><br></pre></td></tr></table></figure>
<p>三、将自己的程序注册为服务<br>将 服务脚本放置到  &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;  即可 </p>
<p>[Unit]区块：设置管理启动顺序与依赖关系。<br>  <img src="https://note.youdao.com/yws/res/3668/WEBRESOURCE911e21a102fe6874dc57ea2c3b0bc180" alt="image.png"><br>[Service]区块：<br> <img src="https://note.youdao.com/yws/res/3669/WEBRESOURCE77c9501ad141241c559598c1474acf3a" alt="image.png"><br>所有的启动设置之前，都可以加上一个连词号（-），表示”抑制错误”，即发生错误的时候，不影响其他命令的执行。例如：ExecStop&#x3D;-&#x2F;bin&#x2F;sh &#x2F;server&#x2F;scripts&#x2F;xx.sh</p>
<p>[Install]区块：定义如何安装这个配置文件，即怎样做到开机启动<br> <img src="https://note.youdao.com/yws/res/3670/WEBRESOURCE0b0df6ac6cf9a8842412e36194585b28" alt="image.png"></p>
<p> <img src="https://note.youdao.com/yws/res/3671/WEBRESOURCE6a9999621169169958f59ca021e85469" alt="image.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cachefish.github.io/2022/03/11/STL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2229.jfif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="来世做春风，浪漫且自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cachecatのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/11/STL/" class="post-title-link" itemprop="url">c++ stl</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-11 19:30:00" itemprop="dateCreated datePublished" datetime="2022-03-11T19:30:00+08:00">2022-03-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-02 09:31:41" itemprop="dateModified" datetime="2022-04-02T09:31:41+08:00">2022-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-base/" itemprop="url" rel="index"><span itemprop="name">c++ base</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
</blockquote>
<p> <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5</a></p>
<p>• STL库是用模板（template）写出来的，模板是STL库的基础。STL大致由以下几部分组成：</p>
<pre><code>• 容器（container）
• 迭代器（iterator） ---&gt; 指针
• 适配器（Adapter）
• 算法（algorithm）
• 函数对象（functor）
• 配置器（allocator） ---  透明的
</code></pre>
<p>容器、迭代器、容器适配器都是用类模板实现的，迭代器用于遍历容器中的每一个元素，&#x3D;&#x3D;算法用于操作数据&#x3D;&#x3D;</p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>• 如果没有STL的支持，在处理一些复杂问题时，要自行设计存储模式，如数组管理，插入删除操作等，这不但很繁琐，而且bug频出，是程序出问题最多的地方。STL运用模板类库机制，为数据存储，查找和其他操作提供了一整套方案，大大提高了程序的正确性。不仅如此，类库对常用的很多操作进行了优化处理，大大提高了程序的效率。<br>• 容器是可容纳一些数据的类模板，STL中有vector、list、deque、set&#x2F;multiset、map&#x2F;multimap等容器。</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><ul>
<li>在有的专业书籍中，迭代器也称游标，可以将迭代器初步理解为广义指针，迭代器和指针功能很像，迭代器是通过重载一元的”*”和”-&gt;”来从容器中间接地返回一个值。</li>
<li>迭代器有5种，依次为:<ul>
<li><pre><code> 随机访问迭代器（Random Access Iterator）
</code></pre>
</li>
<li><pre><code> 双向迭代器（Bidirectional Iterator）
</code></pre>
</li>
<li><pre><code>前向迭代器（Forward Iterator）
</code></pre>
</li>
<li><pre><code> 输入迭代器（Input Iterator）
</code></pre>
</li>
<li><pre><code> 输出迭代器（Output Iterator）
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h3><p>• 适配器就是Interface(接口)，&#x3D;&#x3D;对容器、迭代器和算法进行包装&#x3D;&#x3D;，但其实质还是容器、迭代器和算法，只是不依赖于具体的标准容器、迭代器和算法类型，容器适配器可以理解为容器的模板，迭代器适配器可理解为迭代器的模板，算法适配器可理解为算法的模板。<br>• 常见的容器适配器有：<br>    stack、queue、priority_queue<br>    （不支持迭代器访问）</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul>
<li>STL包含了很多对容器进行处理的函数，它们的处理思路大体相同：使用迭代器来标识要处理的数据或数据段、以及结果的存放位置，有的函数还作为对象参数传递给另一个函数，实现数据的处理。</li>
</ul>
<h4 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h4><p>vector，字面翻译为向量(动态数组)，其用法类似于数组，但其功能比数组更强大。简单地说，vector是数组的类表示，它提供了自动管理内存的功能，可以动态改变vector对象的长度，并随着元素的增删而增大或缩小(?)，提供了对元素的随机访问，和数组一样，在vector尾部添加和删除元素（push_back和pop_back）的时间是固定的，但在vector中间或头部增删元素(insert,erase)的时间和复杂度线性正比于vector容器对象中元素的多少。</p>
<h4 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a>deque容器</h4><ul>
<li>deque表示双端队列（double-ended queue），deque容器对象支持下标随机访问，在deque头部和尾部添加删除元素时的时间都是固定的，因此，如果有很多操作是针对序列的头部位置的，建议使用deque容器。但是，如果是在deque的中间进行元素的增删处理，操作的复杂度和时间正比于deque对象中元素的多少。</li>
</ul>
<h4 id="list容器"><a href="#list容器" class="headerlink" title="list容器"></a>list容器</h4><ul>
<li>list类模板表示双向链表，除了首尾元素外，list容器对象中的每个元素都和前面的元素相链接，list不支持下标随机访问，只能通过迭代器双向遍历。</li>
<li>和vector和deque不同的是，在list的任何位置增删元素的时间都是固定的。</li>
</ul>
<h4 id="set容器"><a href="#set容器" class="headerlink" title="set容器"></a>set容器</h4><ul>
<li>使用set容器必须#include <set>。</li>
<li>其使用形式如下：<br>  set&lt;存储类型[,排序函数或对象]&gt; 容器对象名;<br>  第1个参数用以指定存储类型，第2个参数是可选的，用来指定对关键字进行排序的函数或函数对象(函数对象后面介绍)，在默认情况下，将使用less&lt;&gt;类模板，字面意义上可理解为按从小到大进行排列。可以自己设定排序方式：set&lt;int, greater<int>&gt;</li>
<li>根据set的特点，STL提供了3种创建set的方式：<ul>
<li>创建空set容器对象，如：<br>  set<int> obS;</li>
<li>将迭代器的区间作为参数的构造函数，如：<br>  int sz[9]&#x3D;{1,2,3,4,5,6,3,5,6};<br>  set<int> A(sz,sz+9);</li>
<li>根据已有同类型的容器创建新容器，如<br>  set<int> B(A);<br>• set不支持[]下标式的随机访问，必须通过迭代器访问元素。</li>
</ul>
</li>
</ul>
<h4 id="map容器"><a href="#map容器" class="headerlink" title="map容器"></a>map容器</h4><ul>
<li><p>使用map必须包括头文件<map>。</p>
</li>
<li><p>map的元素是一对对的“关键字-值”组合，“关键字”用于搜寻，而“值”用来表示我们要存取的数据。</p>
</li>
<li><p>在map容器中，每个关键字只能出现一次，不能重复。</p>
</li>
<li><p>可使用类模板pair&lt;class T1,class T2&gt;来表示map容器中形如“关键字-值”的每个元素。如下述语句就生成了map容器对象的一个元素t：</p>
<ul>
<li>pair&lt;const int, string&gt; t(600036,”招商银行”);<br>  ○ cout &lt;&lt; t.first &lt;&lt; t.second &lt;&lt; endl;<br>t.first表示600036，t.second表示,”招商银行”<br>   也可创建pair&lt;class T1,class T2&gt;的匿名元素：<br>  • pair&lt;const int, string&gt;(600036,”招商银行”);<br>  • const表示关键字是只读的。</li>
</ul>
</li>
<li><p>创建map容器对象的格式如下，各参数含义和set的类似：<br>  map&lt;关键字类型,值类型[,排序函数或对象]&gt; 容器对象名;</p>
</li>
<li><p>创建方式也是3种：</p>
<ul>
<li>1.创建空map容器对象，如：<br>  map&lt;int,string&gt; obM;</li>
<li>2.将迭代器的区间作为参数的构造函数，如<br>  pair&lt;int,string&gt; sz[4]&#x3D;{<br>  pair&lt;int,string&gt;(1,”北京”),pair&lt;int,string&gt;(2,”深圳”),<br>  pair&lt;int,string&gt;(3,”广州”),pair&lt;int,string&gt;(2,”苏州”)};<br>   map&lt;int,string&gt; obM(sz,sz+4);</li>
<li>3.根据已有同类型的容器创建新容器<br>  map&lt;int,string&gt; B(A);</li>
</ul>
</li>
<li><p>map支持[]下标式的随机访问，也支持迭代器访问元素。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cachefish.github.io/2022/03/10/c-11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2229.jfif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="来世做春风，浪漫且自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cachecatのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/10/c-11/" class="post-title-link" itemprop="url">c++ 11</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-10 19:30:00" itemprop="dateCreated datePublished" datetime="2022-03-10T19:30:00+08:00">2022-03-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-02 09:31:09" itemprop="dateModified" datetime="2022-04-02T09:31:09+08:00">2022-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-base/" itemprop="url" rel="index"><span itemprop="name">c++ base</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-nullptr"><a href="#1-nullptr" class="headerlink" title="1. nullptr"></a>1. nullptr</h3><hr>
<p>实际开发中，避免产生“野指针”最有效的方法，就是在定义指针的同时完成初始化操作，即便该指针的指向尚未明确，也要将其初始化为空指针。<br>所谓“野指针”，又称“悬挂指针”，指的是没有明确指向的指针。野指针往往指向的是那些不可用的内存区域，这就意味着像操作普通指针那样使用野指针（例如 &amp;p），极可能导致程序发生异常。</p>
<hr>
<p>C++98&#x2F;03 标准中，将一个指针初始化为空指针的方式有 2 种：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int *p <span class="operator">=</span> <span class="number">0</span><span class="comment">;</span></span><br><span class="line">int *p <span class="operator">=</span> NULL<span class="comment">; //推荐使用</span></span><br></pre></td></tr></table></figure>
<p>例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">isnull</span><span class="params">(<span class="type">void</span> *c)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;void*c&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">isnull</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int n&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">isnull</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">isnull</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">程序执行结果为：</span><br><span class="line"><span class="type">int</span> n</span><br><span class="line"><span class="type">int</span> n</span><br></pre></td></tr></table></figure>
<p>对于这两个函数来说，如果 NULL 又被定义为了 0 那么 foo(NULL); 这个语句将会去调用 foo(int)，从而导致代码混乱。</p>
<p>为了解决这个问题，C++11 引入了 nullptr 关键字，专门用来区分空指针、0。</p>
<p>&#x3D;&#x3D;nullptr 的类型为nullptr_t&#x3D;&#x3D;，专用于初始化空类型指针，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * a1 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">char</span> * a2 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">double</span> * a3 = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">编译器分别将 <span class="literal">nullptr</span> 隐式转换成 <span class="type">int</span>*、<span class="type">char</span>* 以及 <span class="type">double</span>* 指针类型。</span><br></pre></td></tr></table></figure>
<p>&#x3D;&#x3D;当需要使用 NULL 时候，养成直接使用 nullptr的习惯。&#x3D;&#x3D;</p>
<h3 id="2-auto类型推导"><a href="#2-auto类型推导" class="headerlink" title="2. auto类型推导"></a>2. auto类型推导</h3><p>c+98之前，定义变量或者声明变量之前都必须指明它的类型，比如 int、char 等；<br>auto 关键字基本的使用语法如下：<br>auto name &#x3D; value;<br>&#x2F;&#x2F;auto 仅仅是一个占位符，在编译器期间它会被真正的类型所替代。或者说，C++ 中的变量必须是有明确类型的，只是这个类型是由编译器自己推导出来的。</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">auto n = 10;  //int</span><br><span class="line">auto f = 12.8;  //double</span><br><span class="line"><span class="section">auto p = &amp;n; //int*</span></span><br><span class="line"><span class="section">-------</span></span><br><span class="line">int n = 20; </span><br><span class="line"><span class="section">auto *p = &amp;n, m = 99; //int  </span></span><br><span class="line"><span class="section">-------</span></span><br><span class="line">int  x = 0;</span><br><span class="line">auto <span class="strong">*p1 = &amp;x;   //p1 为 int *，auto 推导为 int</span></span><br><span class="line"><span class="strong">auto  p2 = &amp;x;   //p2 为 int*，auto 推导为 int*</span></span><br><span class="line">auto &amp;r1  = x;   //r1 为 int&amp;，auto 推导为 int</span><br><span class="line"><span class="section">auto r2 = r1;    //r2 为  int，auto 推导为 int</span></span><br><span class="line"><span class="section">-------</span></span><br><span class="line">int  x = 0;</span><br><span class="line">const  auto n = x;  //n 为 const int ，auto 被推导为 int</span><br><span class="line">auto f = n;      //f 为 const int，auto 被推导为 int（const 属性被抛弃）</span><br><span class="line">const auto &amp;r1 = x;  //r1 为 const int&amp; 类型，auto 被推导为 int</span><br><span class="line">auto &amp;r2 = r1;  //r1 为 const int&amp; 类型，auto 被推导为 const int 类型(当 const 和引用结合时，auto 的推导将保留表达式的 const 类型。)</span><br><span class="line"></span><br><span class="line">使用 auto 类型推导的变量必须马上初始化</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>具体类型推导可看c++培训文档-&gt;类型推导一栏</p>
<h5 id="auto-的限制"><a href="#auto-的限制" class="headerlink" title="auto 的限制"></a>auto 的限制</h5><ol>
<li>auto 不能在函数的参数中使用</li>
<li>auto 不能作用于类的非静态成员变量（也就是没有 static 关键字修饰的成员变量）中</li>
<li>auto 关键字不能定义数组 <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char url[] <span class="operator">=</span> <span class="string">&quot;hello&quot;</span><span class="comment">;</span></span><br><span class="line">auto  str[] <span class="operator">=</span> url<span class="comment">;  //arr 为数组，不能使用 auto</span></span><br></pre></td></tr></table></figure></li>
<li>auto 不能作用于模板参数 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A&lt;<span class="type">int</span>&gt; C1;</span><br><span class="line">    A&lt;<span class="keyword">auto</span>&gt; C2 = C1;  <span class="comment">//错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>auto并不是一个真正的类型。auto仅仅是一个占位符。不能使用sizeof来测试大小。<h5 id="auto最常用使用"><a href="#auto最常用使用" class="headerlink" title="auto最常用使用"></a>auto最常用使用</h5><h6 id="使用-auto-定义迭代器"><a href="#使用-auto-定义迭代器" class="headerlink" title="使用 auto 定义迭代器"></a>使用 auto 定义迭代器</h6><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vector&lt; vector&lt;<span class="type">int</span>&gt; &gt; v;</span><br><span class="line">vector&lt; vector&lt;<span class="type">int</span>&gt; &gt;::iterator i = v.<span class="built_in">begin</span>();</span><br><span class="line">------</span><br><span class="line">vector&lt; vector&lt;<span class="type">int</span>&gt; &gt; v;</span><br><span class="line"><span class="keyword">auto</span> i = v.<span class="built_in">begin</span>();  <span class="comment">//使用 auto 代替具体的类型</span></span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; map_;  </span><br><span class="line">map&lt;<span class="type">int</span>, map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;::const_iterator itr1 = map_.<span class="built_in">begin</span>();  </span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> itr2 = map_.<span class="built_in">begin</span>(); </span><br></pre></td></tr></table></figure></li>
</ol>
<h6 id="范围for"><a href="#范围for" class="headerlink" title="范围for"></a>范围for</h6><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">int</span> array[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="attribute">for</span> (auto&amp; e : array)</span><br><span class="line">	<span class="attribute">e</span> *= <span class="number">2</span>;</span><br><span class="line"><span class="attribute">for</span> (auto e : array)</span><br><span class="line">	<span class="attribute">cout</span> &lt;&lt; e &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure>

<h6 id="泛型编程-用于类型推导"><a href="#泛型编程-用于类型推导" class="headerlink" title="泛型编程(用于类型推导)"></a>泛型编程(用于类型推导)</h6><p>使用模板技术时，如果某个变量的类型依赖于模板参数，<br>不使用auto将很难确定变量的类型（使用auto后，将由编译器自动进行确定）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">U</span>&gt;  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Multiply</span><span class="params">(T t, U u)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">auto</span> v = t * u;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">get</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> val = T::<span class="built_in">get</span>();</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>&lt;A&gt;();</span><br><span class="line">    <span class="built_in">func</span>&lt;B&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">get</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;http://c.biancheng.net/cplus/&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;  <span class="comment">//额外增加一个模板参数 T2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    T2 val = T1::<span class="built_in">get</span>();</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//调用时也要手动给模板参数赋值</span></span><br><span class="line">    <span class="built_in">func</span>&lt;A, <span class="type">int</span>&gt;();</span><br><span class="line">    <span class="built_in">func</span>&lt;B, <span class="type">const</span> <span class="type">char</span>*&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-decltype类型推导"><a href="#3-decltype类型推导" class="headerlink" title="3. decltype类型推导"></a>3. decltype类型推导</h3><p>decltype 和 auto 的功能一样，都用来在&#x3D;&#x3D;编译时期进行自动类型推导&#x3D;&#x3D;<br>auto 和 decltype 关键字都可以自动推导出变量的类型，但它们的用法是有区别的：<br>auto 根据&#x3D;右边的初始值 value 推导出变量的类型，而 decltype 根据 exp 表达式推导出变量的类型，跟&#x3D;右边的 value 没有关系。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto varname <span class="operator">=</span> value<span class="comment">;</span></span><br><span class="line">decltype(exp) varname <span class="operator">=</span> value<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>例如:</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="attribute">decltype</span>(a) b = <span class="number">1</span>;  //b 被推导成了 int</span><br><span class="line"><span class="attribute">decltype</span>(<span class="number">10</span>.<span class="number">8</span>) x = <span class="number">5</span>.<span class="number">5</span>;  //x 被推导成了 double</span><br><span class="line"><span class="attribute">decltype</span>(x + <span class="number">100</span>) y;  //y 被推导成了 double</span><br></pre></td></tr></table></figure>

<h4 id="decltype-推导规则"><a href="#decltype-推导规则" class="headerlink" title="decltype 推导规则"></a>decltype 推导规则</h4><p>当使用 decltype(exp)获取类型时，编译器将根据以下三条规则得出结果：</p>
<ul>
<li>如果 exp 是一个不被括号()包围的表达式，或者是一个类成员访问表达式，或者是一个单独的变量，那么 decltype(exp) 的类型就和 exp 一致，这是最普遍最常见的情况。</li>
<li>如果 exp 是函数调用，那么 decltype(exp) 的类型就和函数返回值的类型一致。</li>
<li>如果 exp 是一个左值，或者被括号( )包围，那么 decltype(exp) 的类型就是 exp 的引用；假设 exp 的类型为 T，那么 decltype(exp) 的类型就是 T&amp;。</li>
</ul>
<p>【实例1】exp 是一个普通表达式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> total;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> scores;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Student::total = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;r = n;</span><br><span class="line">    Student stu;</span><br><span class="line">    <span class="keyword">decltype</span>(n) a = n;  <span class="comment">//n 为 int 类型，a 被推导为 int 类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(r) b = n;     <span class="comment">//r 为 const int&amp; 类型, b 被推导为 const int&amp; 类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(Student::total) c = <span class="number">0</span>;  <span class="comment">//total 为类 Student 的一个 int 类型的成员变量，c 被推导为 int 类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(stu.name) url = <span class="string">&quot;hello&quot;</span>;  <span class="comment">//total 为类 Student 的一个 string 类型的成员变量， url 被推导为 string 类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【实例2】exp 为函数调用：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="built_in">int</span>&amp; func<span class="constructor">_int_r(<span class="params">int</span>, <span class="params">char</span>)</span>;  <span class="comment">//返回值为 int&amp;</span></span><br><span class="line"><span class="built_in">int</span>&amp;&amp; func<span class="constructor">_int_rr(<span class="params">void</span>)</span>;  <span class="comment">//返回值为 int&amp;&amp;</span></span><br><span class="line"><span class="built_in">int</span> func<span class="constructor">_int(<span class="params">double</span>)</span>;  <span class="comment">//返回值为 int</span></span><br><span class="line"></span><br><span class="line">const <span class="built_in">int</span>&amp; <span class="keyword">fun</span><span class="constructor">_cint_r(<span class="params">int</span>, <span class="params">int</span>, <span class="params">int</span>)</span>;  <span class="comment">//返回值为 const int&amp;</span></span><br><span class="line">const <span class="built_in">int</span>&amp;&amp; func<span class="constructor">_cint_rr(<span class="params">void</span>)</span>;  <span class="comment">//返回值为 const int&amp;&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//decltype类型推导</span></span><br><span class="line"><span class="built_in">int</span> n = <span class="number">100</span>;</span><br><span class="line">decltype(func<span class="constructor">_int_r(100, &#x27;A&#x27;)</span>) a = n;  <span class="comment">//a 的类型为 int&amp;</span></span><br><span class="line">decltype(func<span class="constructor">_int_rr()</span>) b = <span class="number">0</span>;  <span class="comment">//b 的类型为 int&amp;&amp;</span></span><br><span class="line">decltype(func<span class="constructor">_int(10.5)</span>) c = <span class="number">0</span>;   <span class="comment">//c 的类型为 int</span></span><br><span class="line"></span><br><span class="line">decltype(<span class="keyword">fun</span><span class="constructor">_cint_r(1,2,3)</span>)  x = n;    <span class="comment">//x 的类型为 const int &amp;</span></span><br><span class="line">decltype(func<span class="constructor">_cint_rr()</span>) y = <span class="number">0</span>;  <span class="comment">// y 的类型为 const int&amp;&amp;</span></span><br></pre></td></tr></table></figure>
<p>exp 中调用函数时需要带上括号和参数，这仅仅是形式，并不会真的去执行函数代码。</p>
<p>【实例3】exp 是左值，或者被( )包围：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> Base obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//带有括号的表达式</span></span><br><span class="line">    <span class="keyword">decltype</span>(obj.x) a = <span class="number">0</span>;  <span class="comment">//obj.x 为类的成员访问表达式，符合推导规则一，a 的类型为 int</span></span><br><span class="line">    <span class="keyword">decltype</span>((obj.x)) b = a;  <span class="comment">//obj.x 带有括号，符合推导规则三，b 的类型为 int&amp;。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//加法表达式</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(n + m) c = <span class="number">0</span>;  <span class="comment">//n+m 得到一个右值，符合推导规则一，所以推导结果为 int</span></span><br><span class="line">    <span class="keyword">decltype</span>(n = n + m) d = c;  <span class="comment">//n=n+m 得到一个左值，符号推导规则三，所以推导结果为 int&amp;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">左值是指那些在表达式执行结束后依然存在的数据，也就是持久性的数据；右值是指那些在表达式执行结束后不再存在的数据，也就是临时性的数据。</span><br></pre></td></tr></table></figure>

<h5 id="decltype最常使用"><a href="#decltype最常使用" class="headerlink" title="decltype最常使用"></a>decltype最常使用</h5><h6 id="用于推到类的非静态成员"><a href="#用于推到类的非静态成员" class="headerlink" title="用于推到类的非静态成员"></a>用于推到类的非静态成员</h6><p>auto 只能用于类的静态成员，不能用于类的非静态成员（普通成员），如果我们想推导非静态成员的类型，这个时候就必须使用 decltype 了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp; container)</span> </span>&#123;</span><br><span class="line">        m_it = container.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typename</span> T::iterator m_it;  <span class="comment">//注意这里</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    Base&lt;<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&gt; obj;</span><br><span class="line">    obj.<span class="built_in">func</span>(v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">-----------</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp; container)</span> </span>&#123;</span><br><span class="line">        m_it = container.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">decltype</span>(<span class="built_in">T</span>().<span class="built_in">begin</span>()) m_it;  <span class="comment">//注意这里</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>单独看 Base 类中 m_it 成员的定义，很难看出会有什么错误，但在使用 Base 类的时候，如果传入一个 const 类型的容器，编译器马上就会弹出一大堆错误信息。原因就在于，T::iterator并不能包括所有的迭代器类型，当 T 是一个 const 容器时，应当使用 const_iterator。</p>
<h3 id="4-返回值类型后置"><a href="#4-返回值类型后置" class="headerlink" title="4. 返回值类型后置"></a>4. 返回值类型后置</h3><p>在泛型编程中，可能需要通过参数的运算来得到返回值的类型。考虑下面这个场景：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">R <span class="title">add</span><span class="params">(T t, U u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t+u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>; <span class="type">float</span> b = <span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">auto</span> c = <span class="built_in">add</span>&lt;<span class="keyword">decltype</span>(a + b)&gt;(a, b);</span><br></pre></td></tr></table></figure>
<p>我们并不关心 a+b 的类型是什么，因此，只需要通过 decltype(a+b) 直接得到返回值类型即可。但是像上面这样使用十分不方便，因为外部其实并不知道参数之间应该如何运算，只有 add 函数才知道返回值应当如何推导<br>可行的写法如下：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, typename U&gt;</span><br><span class="line">decltype(T() + U()) <span class="keyword">add</span>(T t, U u)</span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    return t + u;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line">考虑到 T、U 可能是没有无参构造函数的类</span><br><span class="line">template &lt;typename T, typename U&gt;</span><br><span class="line">decltype(<span class="comment">(*(T*)</span><span class="number">0</span>) + <span class="comment">(*(U*)</span><span class="number">0</span>)) <span class="keyword">add</span>(T t, U u)</span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    return t + u;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
<p>虽然成功地使用 decltype 完成了返回值的推导，但写法过于晦涩，会大大增加 decltype 在返回值类型推导上的使用难度并降低代码的可读性。</p>
<p>返回类型后置语法是通过 auto 和 decltype 结合起来使用的。上面的 add 函数，使用新的语法可以写成：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, typename U&gt;</span><br><span class="line">auto <span class="built_in">add</span>(T t, U u) -&gt; <span class="built_in">decltype</span>(t + u)</span><br><span class="line">&#123;</span><br><span class="line">    return t + u;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------</span><br><span class="line">int&amp; <span class="built_in">foo</span>(int&amp; i);</span><br><span class="line"><span class="attribute">float</span> <span class="built_in">foo</span>(float&amp; f);</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">auto <span class="built_in">func</span>(T&amp; val) -&gt; <span class="built_in">decltype</span>(foo(val))</span><br><span class="line">&#123;</span><br><span class="line">    return <span class="built_in">foo</span>(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 decltype 结合返回值后置语法很容易推导出了 foo(val) 可能出现的返回值类型，并将其用到了 func 上。</p>
<p>返回值类型后置语法，是为了解决函数返回值类型依赖于参数而导致难以确定返回值类型的问题。有了这种语法以后，对返回值类型的推导就可以用清晰的方式（直接通过参数做运算）描述出来，而不需要像 C++98&#x2F;03 那样使用晦涩难懂的写法。</p>
<h3 id="5-使用using定义别名"><a href="#5-使用using定义别名" class="headerlink" title="5. 使用using定义别名"></a>5. 使用using定义别名</h3><p>在 C++ 中可以通过 typedef 重定义一个类型：<br>typedef unsigned int uint_t;</p>
<p>被重定义的类型并不是一个新的类型，仅仅只是原有的类型取了一个新的名字</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">uint_t</span>)</span></span>;  <span class="comment">// error: redefinition</span></span><br></pre></td></tr></table></figure>
<p>使用 typedef 重定义类型是很方便的，但它也有一些限制，比如，无法重定义一个模板。<br>比如:<br>需要一个以key为string，value为int或string或其他类型的map<br>c98需要这样操作</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Val&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str_map</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> std::map&lt;std::string, Val&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">str_map&lt;<span class="type">int</span>&gt;::type map1;</span><br></pre></td></tr></table></figure>
<p>c++11</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Val&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">str_map_t</span> = std::map&lt;std::string, Val&gt;;</span><br><span class="line"></span><br><span class="line"><span class="type">str_map_t</span>&lt;<span class="type">int</span>&gt; map1;</span><br></pre></td></tr></table></figure>
<p>using 的别名语法覆盖了 typedef 的全部功能。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重定义unsigned int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint_t</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="type">uint_t</span> = <span class="type">unsigned</span> <span class="type">int</span>;</span><br><span class="line"><span class="comment">// 重定义std::map</span></span><br><span class="line"><span class="keyword">typedef</span> std::map&lt;std::string, <span class="type">int</span>&gt; <span class="type">map_int_t</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="type">map_int_t</span> = std::map&lt;std::string, <span class="type">int</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>typedef 的定义方法和变量的声明类似：像声明一个变量一样，声明一个重定义类型，之后在声明之前加上 typedef 即可。这种写法凸显了 C&#x2F;C++ 中的语法一致性，但有时却会增加代码的阅读难度。比如重定义一个函数指针时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="type">func_t</span>)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>与之相比，using 后面总是立即跟随新标识符（Identifier），之后使用类似赋值的语法，把现有的类型（type-id）赋给新类型：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="type">func_t</span> = <span class="built_in">void</span> (*)(<span class="type">int</span>, <span class="type">int</span>);</span><br></pre></td></tr></table></figure>
<p>通过 using 定义模板别名的语法，只是在普通类型别名语法的基础上增加 template 的参数列表。使用 using 可以轻松地创建一个新的模板别名，而不需要像 C++98&#x2F;03 那样使用烦琐的外敷模板。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* C++98/03 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">func_t</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*type)</span><span class="params">(T, T)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用 func_t 模板</span></span><br><span class="line"><span class="type">func_t</span>&lt;<span class="type">int</span>&gt;::type xx_1;</span><br><span class="line"><span class="comment">/* C++11 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">func_t</span> = <span class="built_in">void</span> (*)(T, T);</span><br><span class="line"><span class="comment">// 使用 func_t 模板</span></span><br><span class="line"><span class="type">func_t</span>&lt;<span class="type">int</span>&gt; xx_2;</span><br></pre></td></tr></table></figure>
<p>using 重定义的 func_t是一个模板，但它既不是类模板也不是函数模板（函数模板实例化后是一个函数），而是一种新的模板形式：模板别名（alias template）。<br>通过 using 可以轻松定义任意类型的模板表达方式。比如下面这样：<br>template <typename T><br>using type_t &#x3D; T;<br>type_t<int> i;<br>&#x3D;&#x3D;type_t 实例化后的类型和它的模板参数类型等价。这里，type_t<int> 将等价于 int。&#x3D;&#x3D;</p>
<h3 id="6-支持函数模板的默认模板参数"><a href="#6-支持函数模板的默认模板参数" class="headerlink" title="6. 支持函数模板的默认模板参数"></a>6. 支持函数模板的默认模板参数</h3><h3 id="7-tuple元组"><a href="#7-tuple元组" class="headerlink" title="7. tuple元组"></a>7. tuple元组</h3><p>&#x3D;&#x3D;实例化的对象可以存储任意数量、任意类型的数据。&#x3D;&#x3D;<br>当函数需要返回多个数据时，可以将这些数据存储在 tuple 中，函数只需返回一个 tuple 对象即可。<br>tuple 本质是一个以可变模板参数定义的类模板，它定义在 <tuple> 头文件并位于 std 命名空间中。因此要想使用 tuple 类模板，程序中需要首先引入以下代码：<br>#include <tuple><br>using std::tuple;</p>
<h5 id="实例化tuple模板类对象"><a href="#实例化tuple模板类对象" class="headerlink" title="实例化tuple模板类对象"></a>实例化tuple模板类对象</h5><ol>
<li><p>类的构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) 默认构造函数</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">tuple</span><span class="params">()</span></span>;</span><br><span class="line"><span class="number">2</span>) 拷贝构造函数</span><br><span class="line"><span class="built_in">tuple</span> (<span class="type">const</span> tuple&amp; tpl);</span><br><span class="line"><span class="number">3</span>) 移动构造函数</span><br><span class="line"><span class="built_in">tuple</span> (tuple&amp;&amp; tpl);</span><br><span class="line"><span class="number">4</span>) 隐式类型转换构造函数</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... UTypes&gt;</span><br><span class="line">    <span class="built_in">tuple</span> (<span class="type">const</span> tuple&lt;UTypes...&gt;&amp; tpl); <span class="comment">//左值方式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... UTypes&gt;</span><br><span class="line">    <span class="built_in">tuple</span> (tuple&lt;UTypes...&gt;&amp;&amp; tpl);      <span class="comment">//右值方式</span></span><br><span class="line"><span class="number">5</span>) 支持初始化列表的构造函数</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">tuple</span> <span class="params">(<span class="type">const</span> Types&amp;... elems)</span></span>;  <span class="comment">//左值方式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... UTypes&gt;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">tuple</span> <span class="params">(UTypes&amp;&amp;... elems)</span></span>;  <span class="comment">//右值方式</span></span><br><span class="line"><span class="number">6</span>) 将pair对象转换为tuple对象</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U1</span>, <span class="keyword">class</span> <span class="title class_">U2</span>&gt;</span><br><span class="line">    <span class="built_in">tuple</span> (<span class="type">const</span> pair&lt;U1,U2&gt;&amp; pr);       <span class="comment">//左值方式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U1</span>, <span class="keyword">class</span> <span class="title class_">U2</span>&gt;</span><br><span class="line">    <span class="built_in">tuple</span> (pair&lt;U1,U2&gt;&amp;&amp; pr);            <span class="comment">//右值方式</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span>        </span></span><br><span class="line"><span class="keyword">using</span> std::tuple;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; first;                             <span class="comment">// 1)   first&#123;&#125;</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title">second</span><span class="params">(first)</span></span>;                     <span class="comment">// 2)   second&#123;&#125;</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title">third</span><span class="params">(std::make_tuple(<span class="number">20</span>, <span class="string">&#x27;b&#x27;</span>))</span></span>;   <span class="comment">// 3)   third&#123;20,&#x27;b&#x27;&#125;</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">long</span>, <span class="type">char</span>&gt; <span class="title">fourth</span><span class="params">(third)</span></span>;                    <span class="comment">// 4)的左值方式, fourth&#123;20,&#x27;b&#x27;&#125;</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title">fifth</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;                    <span class="comment">// 5)的右值方式, fifth&#123;10.&#x27;a&#x27;&#125;</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title">sixth</span><span class="params">(std::make_pair(<span class="number">30</span>, <span class="string">&#x27;c&#x27;</span>))</span></span>;    <span class="comment">// 6)的右值方式, sixth&#123;30,&#x27;&#x27;c&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>make_tuple()函数</p>
<figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">auto</span> first = std::make_tuple (<span class="number">10</span>,&#x27;a&#x27;);   // <span class="keyword">tuple</span> &lt; <span class="type">int</span>, <span class="type">char</span> &gt;</span><br><span class="line"><span class="keyword">const</span> <span class="type">int</span> a = <span class="number">0</span>; <span class="type">int</span> b[<span class="number">3</span>];</span><br><span class="line"><span class="type">auto</span> second = std::make_tuple (a,b);     // <span class="keyword">tuple</span> &lt; <span class="type">int</span>, <span class="type">int</span>* &gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<table>
<thead>
<tr>
<th>函数或类模板</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>tup1.swap(tup2); swap(tup1, tup2)</td>
<td>tup1 和 tup2 表示类型相同的两个 tuple 对象，tuple 模板类中定义有一个 swap() 成员函数，<tuple> 头文件还提供了一个同名的 swap() 全局函数。swap() 函数的功能是交换两个 tuple 对象存储的内容。</td>
</tr>
<tr>
<td>get<num>(tup)</td>
<td>tup 表示某个 tuple 对象，num 是一个整数，get() 是 <tuple> 头文件提供的全局函数，功能是返回 tup 对象中第 num+1 个元素。</td>
</tr>
<tr>
<td>tuple_size<type>::value</td>
<td>tuple_size 是定义在 <tuple> 头文件的类模板，它只有一个成员变量 value，功能是获取某个 tuple 对象中元素的个数，type 为该tuple 对象的类型。</td>
</tr>
<tr>
<td>tuple_element&lt;I, type&gt;::type</td>
<td>tuple_element 是定义在 <tuple> 头文件的类模板，它只有一个成员变量 type，功能是获取某个 tuple 对象第 I+1 个元素的类型。</td>
</tr>
<tr>
<td>forward_as_tuple&lt;args…&gt;</td>
<td>args… 表示 tuple 对象存储的多个元素，该函数的功能是创建一个 tuple 对象，内部存储的 args… 元素都是右值引用形式的。</td>
</tr>
<tr>
<td>tie(args…) &#x3D; tup</td>
<td>tup 表示某个 tuple 对象，tie() 是 <tuple> 头文件提供的，功能是将 tup 内存储的元素逐一赋值给 args… 指定的左值变量。</td>
</tr>
<tr>
<td>tuple_cat(args…)</td>
<td>args… 表示多个 tuple 对象，该函数是 <tuple> 头文件提供的，功能是创建一个 tuple 对象，此对象包含 args… 指定的所有 tuple 对象内的元素。</td>
</tr>
</tbody></table>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">//创建一个 tuple 对象存储 10 和 &#x27;x&#x27;</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title">mytuple</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;x&#x27;</span>)</span></span>;</span><br><span class="line">    <span class="comment">//计算 mytuple 存储元素的个数</span></span><br><span class="line">    size = std::tuple_size&lt;<span class="keyword">decltype</span>(mytuple)&gt;::value;</span><br><span class="line">    <span class="comment">//输出 mytuple 中存储的元素</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(mytuple) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(mytuple) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//修改指定的元素</span></span><br><span class="line">    std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(mytuple) = <span class="number">100</span>;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(mytuple) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//使用 makde_tuple() 创建一个 tuple 对象</span></span><br><span class="line">    <span class="keyword">auto</span> bar = std::<span class="built_in">make_tuple</span>(<span class="string">&quot;test&quot;</span>, <span class="number">3.1</span>, <span class="number">14</span>);</span><br><span class="line">    <span class="comment">//拆解 bar 对象，分别赋值给 mystr、mydou、myint</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* mystr = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">double</span> mydou;</span><br><span class="line">    <span class="type">int</span> myint;</span><br><span class="line">    <span class="comment">//使用 tie() 时，如果不想接受某个元素的值，实参可以用 std::ignore 代替</span></span><br><span class="line">    std::<span class="built_in">tie</span>(mystr, mydou, myint) = bar;</span><br><span class="line">    <span class="comment">//std::tie(std::ignore, std::ignore, myint) = bar;  //只接收第 3 个整形值</span></span><br><span class="line">    <span class="comment">//将 mytuple 和 bar 中的元素整合到 1 个 tuple 对象中</span></span><br><span class="line">    <span class="keyword">auto</span> mycat = std::<span class="built_in">tuple_cat</span>(mytuple, bar);</span><br><span class="line">    size = std::tuple_size&lt;<span class="keyword">decltype</span>(mycat)&gt;::value;</span><br><span class="line">    std::cout &lt;&lt; size &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-列表初始化（统一初始化方式）"><a href="#8-列表初始化（统一初始化方式）" class="headerlink" title="8. 列表初始化（统一初始化方式）"></a>8. 列表初始化（统一初始化方式）</h3><p>c++98中对象初始化有很多方式。如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化列表</span></span><br><span class="line"><span class="type">int</span> i_arr[<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;  <span class="comment">//普通数组</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">    &#125; b;</span><br><span class="line">&#125; a = &#123; <span class="number">1</span>, &#123; <span class="number">2</span>, <span class="number">3</span> &#125; &#125;;  <span class="comment">//POD类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝初始化（copy-initialization）</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span>) &#123;&#125;</span><br><span class="line">&#125; foo = <span class="number">123</span>;  <span class="comment">//需要拷贝构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//直接初始化（direct-initialization）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">j</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">Foo <span class="title">bar</span><span class="params">(<span class="number">123</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这些不同的初始化方法，都有各自的适用范围和作用。最关键的是，这些种类繁多的初始化方法，没有一种可以通用所有情况。为了统一初始化方式，并且让初始化行为具有确定的效果，C++11 中提出了列表初始化（List-initialization）的概念。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Foo <span class="title">a1</span><span class="params">(<span class="number">123</span>)</span></span>;</span><br><span class="line">    Foo a2 = <span class="number">123</span>;  <span class="comment">//error: &#x27;Foo::Foo(const Foo &amp;)&#x27; is private</span></span><br><span class="line">    Foo a3 = &#123; <span class="number">123</span> &#125;;  <span class="comment">//列表初始化</span></span><br><span class="line">    Foo a4 &#123; <span class="number">123</span> &#125;;    <span class="comment">//列表初始化</span></span><br><span class="line">    <span class="type">int</span> a5 = &#123; <span class="number">3</span> &#125;;    <span class="comment">//基本数据类型的列表初始化方式</span></span><br><span class="line">    <span class="type">int</span> a6 &#123; <span class="number">3</span> &#125;;      <span class="comment">//基本数据类型的列表初始化方式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> i_arr[<span class="number">3</span>] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;  <span class="comment">//普通数组初始化</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">    &#125; b;</span><br><span class="line">&#125; a &#123; <span class="number">1</span>, &#123; <span class="number">2</span>, <span class="number">3</span> &#125; &#125;;  <span class="comment">//POD类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> 操作符等可以用圆括号进行初始化的地方，也可以使用初始化列表：</span><br><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span> &#123; <span class="number">123</span> &#125;;</span><br><span class="line"><span class="type">double</span> b = <span class="type">double</span> &#123; <span class="number">12.12</span> &#125;;</span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line">列表初始化还可以直接使用在函数的返回值上</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span>, <span class="type">double</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Foo <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="number">123</span>, <span class="number">321.0</span> &#125;;  <span class="comment">//返回了一个 Foo(123, 321.0)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在初始化时，{}前面的等于号是否书写对初始化行为没有影响。</p>
<h3 id="9-lambda表达式"><a href="#9-lambda表达式" class="headerlink" title="9. lambda表达式"></a>9. lambda表达式</h3><p>匿名函数</p>
<h5 id="lambda匿名函数的定义"><a href="#lambda匿名函数的定义" class="headerlink" title="lambda匿名函数的定义"></a>lambda匿名函数的定义</h5><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[外部变量访问方式说明符] <span class="function"><span class="params">(参数)</span> <span class="title">mutable</span> <span class="title">noexcept</span>/<span class="title">throw</span><span class="params">()</span> -&gt;</span> 返回值类型</span><br><span class="line">&#123;</span><br><span class="line">   函数体;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>[外部变量方位方式说明符] [ ] 方括号用于向编译器表明当前是一个 lambda 表达式，其不能被省略。在方括号内部，可以注明当前 lambda 函数的函数体中可以使用哪些“外部变量”。<br>所谓外部变量，指的是和当前 lambda 表达式位于同一作用域内的所有局部变量。</li>
</ol>
<ol start="2">
<li><p>(参数)<br>和普通函数的定义一样，lambda 匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，如果不需要传递参数，可以连同 () 小括号一起省略；</p>
</li>
<li><p>mutable<br>此关键字可以省略，如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解为这部分变量都是 const 常量）。而如果想修改它们，就必须使用 mutable 关键字。</p>
</li>
</ol>
<p>注意，对于以值传递方式引入的外部变量，lambda 表达式修改的是拷贝的那一份，并不会修改真正的外部变量；</p>
<ol start="4">
<li>noexcept&#x2F;throw()<br>可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型。</li>
</ol>
<p>值得一提的是，如果 lambda 函数标有 noexcept 而函数体内抛出了异常，又或者使用 throw() 限定了异常类型而函数体内抛出了非指定类型的异常，这些异常无法使用 try-catch 捕获，会导致程序执行失败（本节后续会给出实例）。</p>
<ol start="5">
<li><p>-&gt; 返回值类型<br>指明 lambda 匿名函数的返回值类型。值得一提的是，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略-&gt; 返回值类型。</p>
</li>
<li><p>函数体<br>和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。该函数体内除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量。</p>
</li>
</ol>
<p>需要注意的是，外部变量会受到以值传递还是以引用传递方式引入的影响，而全局变量则不会。换句话说，在 lambda 表达式内可以使用任意一个全局变量，必要时还可以直接修改它们的值。</p>
<h5 id="lambda匿名函数中的-外部变量"><a href="#lambda匿名函数中的-外部变量" class="headerlink" title="lambda匿名函数中的[外部变量]"></a>lambda匿名函数中的[外部变量]</h5><table>
<thead>
<tr>
<th>外部变量格式</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>[]</td>
<td>空方括号表示当前 lambda 匿名函数中不导入任何外部变量。</td>
</tr>
<tr>
<td>[&#x3D;]</td>
<td>只有一个 &#x3D; 等号，表示以值传递的方式导入所有外部变量；</td>
</tr>
<tr>
<td>[&amp;]</td>
<td>只有一个 &amp; 符号，表示以引用传递的方式导入所有外部变量；</td>
</tr>
<tr>
<td>[val1,val2,…]</td>
<td>表示以值传递的方式导入 val1、val2 等指定的外部变量，同时多个变量之间没有先后次序；</td>
</tr>
<tr>
<td>[&amp;val1,&amp;val2,…]</td>
<td>表示以引用传递的方式导入 val1、val2等指定的外部变量，多个变量之间没有前后次序；</td>
</tr>
<tr>
<td>[val,&amp;val2,…]</td>
<td>以上 2 种方式还可以混合使用，变量之间没有前后次序。</td>
</tr>
<tr>
<td>[&#x3D;,&amp;val1,…]</td>
<td>表示除 val1 以引用传递的方式导入外，其它外部变量都以值传递的方式导入。</td>
</tr>
<tr>
<td>[this]</td>
<td>表示以值传递的方式导入当前的 this 指针。</td>
</tr>
</tbody></table>
<p>示例:<br>lambda 匿名函数的定义和使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num[<span class="number">4</span>] = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">//对 a 数组中的元素进行排序</span></span><br><span class="line">    <span class="built_in">sort</span>(num, num+<span class="number">4</span>, [=](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">bool</span>&#123; <span class="keyword">return</span> x &lt; y; &#125; );</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n : num)&#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//自定义的升序排序规则</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">sort_up</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span>  x &lt; y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num[<span class="number">4</span>] = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">//对 a 数组中的元素进行排序</span></span><br><span class="line">    <span class="built_in">sort</span>(num, num+<span class="number">4</span>, sort_up);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n : num)&#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 auto 关键字为 lambda 匿名函数设定了一个函数名，由此我们即可在作用域内调用该函数。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//display 即为 lambda 匿名函数的函数名</span></span><br><span class="line">    <span class="keyword">auto</span> display = [](<span class="type">int</span> a,<span class="type">int</span> b) -&gt; <span class="type">void</span>&#123;cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b;&#125;;</span><br><span class="line">    <span class="comment">//调用 lambda 函数</span></span><br><span class="line">    <span class="built_in">display</span>(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用值传递和引用传递</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> all_num = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//局部变量</span></span><br><span class="line">    <span class="type">int</span> num_1 = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> num_2 = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> num_3 = <span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lambda1:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> lambda1 = [=]&#123;</span><br><span class="line">        <span class="comment">//全局变量可以访问甚至修改</span></span><br><span class="line">        all_num = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//函数体内只能使用外部变量，而无法对它们进行修改</span></span><br><span class="line">        cout &lt;&lt; num_1 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">             &lt;&lt; num_2 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">             &lt;&lt; num_3 &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">lambda1</span>();</span><br><span class="line">    cout &lt;&lt; all_num &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lambda2:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> lambda2 = [&amp;]&#123;</span><br><span class="line">        all_num = <span class="number">100</span>;</span><br><span class="line">        num_1 = <span class="number">10</span>;</span><br><span class="line">        num_2 = <span class="number">20</span>;</span><br><span class="line">        num_3 = <span class="number">30</span>;</span><br><span class="line">        cout &lt;&lt; num_1 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">             &lt;&lt; num_2 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">             &lt;&lt; num_3 &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">lambda2</span>();</span><br><span class="line">    cout &lt;&lt; all_num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想在 lambda1 匿名函数的基础上修改外部变量的值，可以借助 mutable 关键字</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">auto lambda1 <span class="operator">=</span> [<span class="operator">=</span>]() mutable&#123;</span><br><span class="line">    num_1 <span class="operator">=</span> <span class="number">10</span><span class="comment">;</span></span><br><span class="line">    num_2 <span class="operator">=</span> <span class="number">20</span><span class="comment">;</span></span><br><span class="line">    num_3 <span class="operator">=</span> <span class="number">30</span><span class="comment">;</span></span><br><span class="line">    //函数体内只能使用外部变量，而无法对它们进行修改</span><br><span class="line">    cout &lt;&lt; num_1 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">         &lt;&lt; num_2 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">         &lt;&lt; num_3 &lt;&lt; endl<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>执行抛出异常类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> except = []()<span class="built_in">throw</span>(<span class="type">int</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">10</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">except</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">int</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;捕获到了整形异常&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-constexpr-验证是否为常量表达式"><a href="#10-constexpr-验证是否为常量表达式" class="headerlink" title="10. constexpr 验证是否为常量表达式"></a>10. constexpr 验证是否为常量表达式</h3><p>constexpr 关键字的功能是使指定的常量表达式获得在程序编译阶段计算出结果的能力，而不必等到程序运行阶段。C++ 11 标准中，constexpr 可用于修饰普通变量、函数（包括模板函数）以及类的构造函数。</p>
<p>所谓常量表达式，指的就是由多个（≥1）常量组成的表达式。换句话说，如果表达式中的成员都是常量，那么该表达式就是一个常量表达式。这也意味着，常量表达式一旦确定，其值将无法修改。</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1)</span></span><br><span class="line"><span class="built_in">int</span> <span class="built_in">url</span>[<span class="number">10</span>];<span class="comment">//正确</span></span><br><span class="line"><span class="comment">// 2)</span></span><br><span class="line"><span class="built_in">int</span> <span class="built_in">url</span>[<span class="number">6</span> + <span class="number">4</span>];<span class="comment">//正确</span></span><br><span class="line"><span class="comment">// 3)</span></span><br><span class="line"><span class="built_in">int</span> length = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">int</span> <span class="built_in">url</span>[length];<span class="comment">//错误，length是变量,无法表示数组的长度。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="constexpr修饰普通变量"><a href="#constexpr修饰普通变量" class="headerlink" title="constexpr修饰普通变量"></a>constexpr修饰普通变量</h5><p>变量必须经过初始化且初始值必须是常量表达式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> num = <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> url[num] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    couts&lt;&lt; url[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">编译器就可以在编译时期对 num 这个表达式进行计算，因为 num 可以作为定义数组时的长度。</span><br></pre></td></tr></table></figure>
<h5 id="constexpr修饰函数"><a href="#constexpr修饰函数" class="headerlink" title="constexpr修饰函数"></a>constexpr修饰函数</h5><p>constexpr 还可以用于修饰函数的返回值，这样的函数又称为“常量表达式函数”。<br>一个函数要想成为常量表达式函数，必须满足如下 4 个条件。</p>
<ol>
<li>整个函数的函数体中，除了可以包含 using 指令、typedef 语句以及 static_assert 断言外，只能包含一条 return 返回语句。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个函数是无法通过编译的，因为该函数的返回值用 constexpr 修饰，但函数内部包含多条语句。</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;  </span><br><span class="line">    <span class="type">int</span> ret = <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//display() 函数的返回值是用 constexpr 修饰的 int 类型值，且该函数的函数体中只包含一个 return 语句。</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;   <span class="comment">// √</span></span><br><span class="line">    <span class="comment">//可以添加 using 执行、typedef 语句以及 static_assert 断言</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>该函数必须有返回值，即函数的返回值类型不能是 void。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">不属于常量表达式函数</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>函数在使用之前，必须有对应的定义语句。我们知道，函数的使用分为“声明”和“定义”两部分，普通的函数调用只需要提前写好该函数的声明部分即可（函数的定义部分可以放在调用位置之后甚至其它文件中），但常量表达式函数在使用前，必须要有该函数的定义。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//普通函数的声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">noconst_dis</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"><span class="comment">//常量表达式函数的声明</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"><span class="comment">//常量表达式函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用常量表达式函数</span></span><br><span class="line">    <span class="type">int</span> a[<span class="built_in">display</span>(<span class="number">3</span>)] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    cout &lt;&lt; a[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//调用普通函数</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">noconst_dis</span>(<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通函数的定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">noconst_dis</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="constexpr修饰模板函数"><a href="#constexpr修饰模板函数" class="headerlink" title="constexpr修饰模板函数"></a>constexpr修饰模板函数</h5>C++11 语法中，constexpr 可以修饰模板函数，但由于模板中类型的不确定性，因此模板函数实例化后的函数是否符合常量表达式函数的要求也是不确定的。</li>
</ol>
<p>针对这种情况下，C++11 标准规定，如果 constexpr 修饰的模板函数实例化结果不满足常量表达式函数的要求，则 constexpr 会被自动忽略，即该函数就等同于一个普通函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myType</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T <span class="title">dispaly</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">myType</span> stu&#123;<span class="string">&quot;zhangsan&quot;</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="comment">//普通函数</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">myType</span> ret = <span class="built_in">dispaly</span>(stu);</span><br><span class="line">    cout &lt;&lt; ret.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ret.age &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//常量表达式函数</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> ret1 = <span class="built_in">dispaly</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; ret1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-右值引用"><a href="#11-右值引用" class="headerlink" title="11. 右值引用"></a>11. 右值引用</h3><p>C++左值和右值<br>在 C++ 或者 C 语言中，一个表达式（可以是字面量、变量、对象、函数的返回值等）根据其使用场景不同，分为左值表达式和右值表达式。确切的说 C++ 中左值和右值的概念是从 C 语言继承过来的。<br>值得一提的是，左值的英文简写为“lvalue”，右值的英文简写为“rvalue”。很多人认为它们分别是”left value”、”right value” 的缩写，其实不然。lvalue 是“loactor value”的缩写，可意为存储在内存中、有明确存储地址（可寻址）的数据，而 rvalue 译为 “read value”，指的是那些可以提供数据值的数据（不一定可以寻址，例如存储于寄存器中的数据）。<br>通常情况下，判断某个表达式是左值还是右值，最常用的有以下 2 种方法。</p>
<ol>
<li>可位于赋值号（&#x3D;）左侧的表达式就是左值；反之，只能位于赋值号右侧的表达式就是右值。举个例子：<br>int a &#x3D; 5;<br>5 &#x3D; a; &#x2F;&#x2F;错误，5 不能为左值</li>
</ol>
<p>其中，变量 a 就是一个左值，而字面量 5 就是一个右值。值得一提的是，C++ 中的左值也可以当做右值使用，例如：<br>int b &#x3D; 10; &#x2F;&#x2F; b 是一个左值<br>a &#x3D; b; &#x2F;&#x2F; a、b 都是左值，只不过将 b 可以当做右值使用</p>
<ol start="2">
<li>有名称的、可以获取到存储地址的表达式即为左值；反之则是右值。</li>
</ol>
<p>以上面定义的变量 a、b 为例，a 和 b 是变量名，且通过 &amp;a 和 &amp;b 可以获得他们的存储地址，因此 a 和 b 都是左值；反之，字面量 5、10，它们既没有名称，也无法获取其存储地址（字面量通常存储在寄存器中，或者和代码存储在一起），因此 5、10 都是右值。 </p>
<h4 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h4><p>C++98标准中使用 “&amp;” 表示。只能操作 C++ 中的左值，无法对右值添加引用。举个例子</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="built_in">num</span> = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">int</span> &amp;b = <span class="built_in">num</span>; <span class="comment">//正确</span></span><br><span class="line"><span class="built_in">int</span> &amp;c = <span class="number">10</span>; <span class="comment">//错误</span></span><br><span class="line">编译器允许我们为 <span class="built_in">num</span> 左值建立一个引用，但不可以为 <span class="number">10</span> 这个右值建立引用。因此，C++<span class="number">98</span>/<span class="number">03</span> 标准中的引用又称为左值引用。</span><br></pre></td></tr></table></figure>
<p>虽然 C++98&#x2F;03 标准不支持为右值建立非常量左值引用，但允许使用常量左值引用操作右值。也就是说，常量左值引用既可以操作左值，也可以操作右值，例如</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="built_in">num</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> &amp;b = <span class="built_in">num</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> &amp;c = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>C++11 标准新引入了另一种引用方式，称为右值引用，用 “&amp;&amp;” 表示。<br>和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int num = <span class="number">10</span>;</span><br><span class="line"><span class="regexp">//i</span>nt &amp;&amp; a = num;  <span class="regexp">//</span>右值引用不能初始化为左值</span><br><span class="line">int &amp;&amp; a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>和c98 常量左值引用不同的是，右值引用还可以对右值进行修改</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">int</span> &amp;&amp; a = <span class="number">10</span>;</span><br><span class="line"><span class="attribute">a</span> = <span class="number">100</span>;</span><br><span class="line"><span class="attribute">cout</span> &lt;&lt; a &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>C++ 语法上是支持定义常量右值引用的<br>const int&amp;&amp; a &#x3D; 10;&#x2F;&#x2F;编译器不会报错<br><img src="https://note.youdao.com/yws/res/3471/WEBRESOURCEec66cfb2022348421dc78b2135ee241d" alt="image.png"></p>
<h3 id="move函数-将左值强制转换为右值"><a href="#move函数-将左值强制转换为右值" class="headerlink" title="move函数 将左值强制转换为右值"></a>move函数 将左值强制转换为右值</h3><p>C++11 标准中借助右值引用可以为指定类添加移动构造函数，这样当使用该类的右值对象（可以理解为临时对象）初始化同类对象时，编译器会优先选择移动构造函数。</p>
<p>移动构造函数的调用时机是：用同类的右值对象初始化新对象。那么，用当前类的左值对象（有名称，能获取其存储地址的实例对象）初始化同类对象时，是否就无法调用移动构造函数了呢？当然不是，C++11 标准中已经给出了解决方案，即调用 move() 函数。</p>
<p>move 本意为 “移动”，但该函数并不能移动任何数据，它的功能很简单，就是将某个左值强制转化为右值。<br>基于 move() 函数特殊的功能，其常用于实现移动语义。</p>
<p>move() 函数的用法也很简单，其语法格式如下：<br>move( arg )</p>
<p>move() 函数的基础应用。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">movedemo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">movedemo</span>():<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="built_in">movedemo</span>(<span class="type">const</span> movedemo &amp;d):<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*d.num))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;copy construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动构造函数</span></span><br><span class="line">    <span class="built_in">movedemo</span>(movedemo &amp;&amp;d):<span class="built_in">num</span>(d.num)&#123;</span><br><span class="line">        d.num = <span class="literal">NULL</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;move construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:     <span class="comment">//这里应该是 private，使用 public 是为了更方便说明问题</span></span><br><span class="line">    <span class="type">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    movedemo demo;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;demo2:\n&quot;</span>;</span><br><span class="line">    movedemo demo2 = demo;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; *demo2.num &lt;&lt; endl;   //可以执行</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;demo3:\n&quot;</span>;</span><br><span class="line">    movedemo demo3 = std::<span class="built_in">move</span>(demo);</span><br><span class="line">    <span class="comment">//此时 demo.num = NULL，因此下面代码会报运行时错误</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; *demo.num &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">程序执行结果为：</span><br><span class="line">construct!</span><br><span class="line">demo2:</span><br><span class="line">copy construct!</span><br><span class="line">demo3:</span><br><span class="line">move construct!</span><br></pre></td></tr></table></figure>
<p>通过观察程序的输出结果，以及对比 demo2 和 demo3 初始化操作不难得知，demo 对象作为左值，直接用于初始化 demo2 对象，其底层调用的是拷贝构造函数；而通过调用 move() 函数可以得到 demo 对象的右值形式，用其初始化 demo3 对象，编译器会优先调用移动构造函数。</p>
<p>灵活使用 move() 函数。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">first</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">first</span>() :<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动构造函数</span></span><br><span class="line">    <span class="built_in">first</span>(first &amp;&amp;d) :<span class="built_in">num</span>(d.num) &#123;</span><br><span class="line">        d.num = <span class="literal">NULL</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;first move construct!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:    <span class="comment">//这里应该是 private，使用 public 是为了更方便说明问题</span></span><br><span class="line">    <span class="type">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">second</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">second</span>() :<span class="built_in">fir</span>() &#123;&#125;</span><br><span class="line">    <span class="comment">//用 first 类的移动构造函数初始化 fir</span></span><br><span class="line">    <span class="built_in">second</span>(second &amp;&amp; sec) :<span class="built_in">fir</span>(<span class="built_in">move</span>(sec.fir)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;second move construct&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:    <span class="comment">//这里也应该是 private，使用 public 是为了更方便说明问题</span></span><br><span class="line">    first fir;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    second oth;</span><br><span class="line">    second oth2 = <span class="built_in">move</span>(oth);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; *oth.fir.num &lt;&lt; endl;   //程序报运行时错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">程序执行结果为：</span><br><span class="line">construct!</span><br><span class="line">first move construct!</span><br><span class="line">second move construct</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>程序中分别构建了 first 和 second 这 2 个类，其中 second 类中包含一个 first 类对象。如果读者仔细观察不难发现，程序中使用了 2 此 move() 函数：<br>程序第 31 行：由于 oth 为左值，如果想调用移动构造函数为 oth2 初始化，需先利用 move() 函数生成一个 oth 的右值版本；<br>程序第 22 行：oth 对象内部还包含一个 first 类对象，对于 oth.fir 来说，其也是一个左值，所以在初始化 oth.fir 时，还需要再调用一次 move() 函数。</p>
<h3 id="引用限定符"><a href="#引用限定符" class="headerlink" title="引用限定符"></a>引用限定符</h3><p>左值的类对象称为左值对象，将右值的类对象称为右值对象。</p>
<p>默认情况下，对于类中用 public 修饰的成员函数，既可以被左值对象调用，也可以被右值对象调用。举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">demo</span>(<span class="type">int</span> num):<span class="built_in">num</span>(num)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_num</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">demo <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">get_num</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">move</span>(a).<span class="built_in">get_num</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，demo 类中的 get_num() 成员函数既可以被 a 左值对象调用，也可以被 move(a) 生成的右值 demo 对象调用，运行程序会输出两个 10。</p>
<p>某些场景中，我们可能需要限制调用成员函数的对象的类型（左值还是右值），为此 C++11 新添加了引用限定符。所谓引用限定符，就是在成员函数的后面添加 “&amp;” 或者 “&amp;&amp;”，从而限制调用者的类型（左值还是右值）。</p>
<p>修改上面程序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">demo</span>(<span class="type">int</span> num):<span class="built_in">num</span>(num)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_num</span><span class="params">()</span>&amp;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">demo <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">get_num</span>() &lt;&lt; endl;          <span class="comment">// 正确</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; move(a).get_num() &lt;&lt; endl;  // 错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和之前的程序相比，我们仅在 get_num()成员函数的后面添加了 “&amp;”，它可以限定调用该函数的对象必须是左值对象。因此第 16 行代码中，move(a) 生成的右值对象是不允许调用 get_num() 函数的。</p>
<p>同理，修改程序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">demo</span>(<span class="type">int</span> num):<span class="built_in">num</span>(num)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_num</span><span class="params">()</span>&amp;&amp;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">demo <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; a.get_num() &lt;&lt; endl;      // 错误</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">move</span>(a).<span class="built_in">get_num</span>() &lt;&lt; endl;  <span class="comment">// 正确</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和先前程序不同的是，get_num() 函数后根有 “&amp;&amp;” 限定符，它可以限定调用该函数的对象必须是一个右值对象。<br>注意，引用限定符不适用于静态成员函数和友元函数。</p>
<p>const和引用限定符<br>我们知道，const 也可以用于修饰类的成员函数，我们习惯称为常成员函数，例如：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">demo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">int</span> <span class="title">get_num</span>() <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">这里的 get_num() 就是一个常成员函数。</span><br></pre></td></tr></table></figure>
<p>const 和引用限定符修饰类的成员函数时，都位于函数的末尾。C++11 标准规定，当引用限定符和 const 修饰同一个类的成员函数时，const 必须位于引用限定符前面。</p>
<p>需要注意的一点是，当 const &amp;&amp; 修饰类的成员函数时，调用它的对象只能是右值对象；当 const &amp; 修饰类的成员函数时，调用它的对象既可以是左值对象，也可以是右值对象。无论是 const &amp;&amp; 还是 const &amp; 限定的成员函数，内部都不允许对当前对象做修改操作。</p>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">demo</span>(<span class="type">int</span> num,<span class="type">int</span> num2) :<span class="built_in">num</span>(num),<span class="built_in">num2</span>(num2) &#123;&#125;</span><br><span class="line">    <span class="comment">//左值和右值对象都可以调用</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_num</span><span class="params">()</span> <span class="type">const</span> &amp;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//仅供右值对象调用</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_num2</span><span class="params">()</span> <span class="type">const</span> &amp;&amp; </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num2;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> num2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">demo <span class="title">a</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">get_num</span>() &lt;&lt; endl;        <span class="comment">// 正确</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">move</span>(a).<span class="built_in">get_num</span>() &lt;&lt; endl;  <span class="comment">// 正确</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//cout &lt;&lt; a.get_num2() &lt;&lt; endl;     // 错误 </span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">move</span>(a).<span class="built_in">get_num2</span>() &lt;&lt; endl; <span class="comment">// 正确</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>C++ 开发中，我们经常会遇到诸如程序运行中突然崩溃、程序运行所用内存越来越多最终不得不重启等问题，这些问题往往都是内存资源管理不当造成的。比如：</p>
<ul>
<li>有些内存资源已经被释放，但指向它的指针并没有改变指向（成为了野指针），并且后续还在使用；</li>
<li>有些内存资源已经被释放，后期又试图再释放一次（重复释放同一块内存会导致程序运行崩溃）；</li>
<li>没有及时释放不再使用的内存资源，造成内存泄漏，程序占用的内存资源越来越多。</li>
</ul>
<p>使用智能指针可以很好地避免“忘记释放内存而导致内存泄漏”问题出现。</p>
<h5 id="shared-ptr智能指针原理"><a href="#shared-ptr智能指针原理" class="headerlink" title="shared_ptr智能指针原理"></a>shared_ptr智能指针原理</h5><p>多个 shared_ptr 智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）。</p>
<h5 id="1、shared-ptr智能指针的创建"><a href="#1、shared-ptr智能指针的创建" class="headerlink" title="1、shared_ptr智能指针的创建"></a>1、shared_ptr智能指针的创建</h5><p>shared_ptr<T> 类模板中，提供了多种实用的构造函数，这里给读者列举了几个常用的构造函数（以构建指向 int 类型数据的智能指针为例）。</p>
<ol>
<li>通过如下 2 种方式，可以构造出 shared_ptr<T> 类型的空智能指针：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p1;             <span class="comment">//不传入任何实参</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;    <span class="comment">//传入空指针 nullptr</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="2">
<li>在构建 shared_ptr 智能指针，也可以明确其指向。例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>std::make_shared<T> 模板函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p3 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br></pre></td></tr></table></figure></li>
<li>shared_ptr<T> 模板还提供有相应的拷贝构造函数和移动构造函数<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用拷贝构造函数</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p4</span><span class="params">(p3)</span></span>;<span class="comment">//或者 std::shared_ptr&lt;int&gt; p4 = p3;</span></span><br><span class="line"><span class="comment">//调用移动构造函数</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p5</span><span class="params">(std::move(p4))</span></span>; <span class="comment">//或者 std::shared_ptr&lt;int&gt; p5 = std::move(p4);</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>同一普通指针不能同时为多个 shared_ptr 对象赋值，否则会导致程序发生异常。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(ptr)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(ptr)</span></span>;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p>shared_ptr<T>模板类提供的成员方法<br><img src="https://note.youdao.com/yws/res/3472/WEBRESOURCE8af2d6d5afe86404603b3b0d59e01559" alt="image.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//构建 2 个智能指针</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">    <span class="comment">//输出 p2 指向的数据</span></span><br><span class="line">    cout &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">    p1.<span class="built_in">reset</span>();<span class="comment">//引用计数减 1,p1为空指针</span></span><br><span class="line">    <span class="keyword">if</span> (p1) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p1 不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p1 为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以上操作，并不会影响 p2</span></span><br><span class="line">    cout &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//判断当前和 p2 同指向的智能指针有多少个</span></span><br><span class="line">    cout &lt;&lt; p2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">10</span></span><br><span class="line">p1 为空</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>unique_ptr”唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）</p>
<p>unique_ptr指针本身的生命周期：从unique_ptr指针创建时开始，直到离开作用域。离开作用域时，若其指向对象，则将其所指对象销毁(默认使用delete操作符，用户可指定其他操作)。</p>
<p>unique_ptr指针与其所指对象的关系：在智能指针生命周期内，可以改变智能指针所指对象，如创建智能指针时通过构造函数指定、</p>
<p>通过reset方法重新指定、通过release方法释放所有权、通过移动语义转移所有权。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//动态绑定对象</span></span><br><span class="line">        <span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span> <span class="params">(<span class="keyword">new</span> <span class="type">int</span>(a))</span></span>;</span><br><span class="line">        std::cout&lt;&lt;*p&lt;&lt;std::endl;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//move转移所有权,转移之后指针p就变得无效了</span></span><br><span class="line">        std::unique_ptr&lt;<span class="type">int</span>&gt; q=std::<span class="built_in">move</span>(p);</span><br><span class="line">        std::cout&lt;&lt;*q&lt;&lt;std::endl;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//release释放所有权，释放之后指针q变的无效</span></span><br><span class="line">        q.<span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p3</span> <span class="params">(<span class="keyword">new</span> string (<span class="string">&quot;auto&quot;</span>))</span></span>;   <span class="comment">//#4</span></span><br><span class="line">unique_ptr&lt;string&gt; p4；                       <span class="comment">//#5</span></span><br><span class="line">p4 = p3;<span class="comment">//此时会报错！！</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">pu1</span><span class="params">(<span class="keyword">new</span> string (<span class="string">&quot;hello world&quot;</span>))</span></span>; </span><br><span class="line">unique_ptr&lt;string&gt; pu2; </span><br><span class="line">pu2 = pu1;                                      <span class="comment">// #1 不允许</span></span><br><span class="line">unique_ptr&lt;string&gt; pu3; </span><br><span class="line">pu3 = <span class="built_in">unique_ptr</span>&lt;string&gt;(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">&quot;You&quot;</span>));   <span class="comment">// #2 允许</span></span><br><span class="line">其中#<span class="number">1</span>留下悬挂的<span class="built_in">unique_ptr</span>(pu1)，这可能导致危害。而#<span class="number">2</span>不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。</span><br></pre></td></tr></table></figure>

<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr()"></a>weak_ptr()</h3><p>share_ptr虽然已经很好用了，但是有一点share_ptr智能指针还是有内存泄露的情况，当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。</p>
<p>weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的shared_ptr， weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;	<span class="comment">//声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	shared_ptr&lt;B&gt; pb_;</span><br><span class="line">	~<span class="built_in">A</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;A delete\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	shared_ptr&lt;A&gt; pa_;</span><br><span class="line">	~<span class="built_in">B</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;B delete\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">shared_ptr&lt;B&gt; <span class="title">pb</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line">	<span class="function">shared_ptr&lt;A&gt; <span class="title">pa</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">	cout &lt;&lt; pb.<span class="built_in">use_count</span>() &lt;&lt; endl;	<span class="comment">//1</span></span><br><span class="line">	cout &lt;&lt; pa.<span class="built_in">use_count</span>() &lt;&lt; endl;	<span class="comment">//1</span></span><br><span class="line">	pb-&gt;pa_ = pa;</span><br><span class="line">	pa-&gt;pb_ = pb;</span><br><span class="line">	cout &lt;&lt; pb.<span class="built_in">use_count</span>() &lt;&lt; endl;	<span class="comment">//2</span></span><br><span class="line">	cout &lt;&lt; pa.<span class="built_in">use_count</span>() &lt;&lt; endl;	<span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fun</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减1，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A、B的析构函数没有被调用）运行结果没有输出析构函数的内容，造成内存泄露。如果把其中一个改为weak_ptr就可以了，我们把类A里面的shared_ptr pb_，改为weak_ptr pb_ ，运行结果如下：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">B <span class="keyword">delete</span></span><br><span class="line">A <span class="keyword">delete</span></span><br></pre></td></tr></table></figure>
<p>这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减1，同时pa析构时使A的计数减1，那么A的计数为0，A得到释放。</p>
<p>注意：我们不能通过weak_ptr直接访问对象的方法，比如B对象中有一个方法print()，我们不能这样访问，pa-&gt;pb_-&gt;print()，因为pb_是一个weak_ptr，应该先把它转化为shared_ptr，如：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">shared_ptr</span>&lt;B&gt; p = pa-&gt;</span>pb_.lock();</span><br><span class="line"><span class="function"><span class="title">p</span>-&gt;</span>print();</span><br></pre></td></tr></table></figure>
<p>weak_ptr 没有重载*和-&gt;但可以使用 lock 获得一个可用的 shared_ptr 对象. 注意, weak_ptr 在使用前需要检查合法性.</p>
<p>&#x3D;&#x3D;expired&#x3D;&#x3D;用于检测所管理的对象是否已经释放, 如果已经释放, 返回 true; 否则返回 false.</p>
<p>&#x3D;&#x3D;lock&#x3D;&#x3D; 用于获取所管理的对象的强引用(shared_ptr). 如果 expired 为 true, 返回一个空的 shared_ptr; 否则返回一个 shared_ptr, 其内部对象指向与 weak_ptr 相同.</p>
<p>&#x3D;&#x3D;use_count&#x3D;&#x3D; 返回与 shared_ptr 共享的对象的引用计数.</p>
<p>&#x3D;&#x3D;reset&#x3D;&#x3D; 将 weak_ptr 置空.</p>
<p>weak_ptr 支持拷贝或赋值, 但不会影响对应的 shared_ptr 内部对象的计数.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cachefish.github.io/2022/03/07/14-%E5%A3%B0%E6%98%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2229.jfif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="来世做春风，浪漫且自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cachecatのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/07/14-%E5%A3%B0%E6%98%8E/" class="post-title-link" itemprop="url">c++ 声明</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-07 19:30:00 / 修改时间：10:13:23" itemprop="dateCreated datePublished" datetime="2022-03-07T19:30:00+08:00">2022-03-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-base/" itemprop="url" rel="index"><span itemprop="name">c++ base</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>声明将名字引入（或再引入）到C++程序中。每种实体的声明方式都不同。<br>定义是足以使该名字所标识的实体被使用的声明。</p>
<h2 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h2><p>顶层CV修饰符（Top-Level cv-Qualifiers）<br>◆C  +中的类型可以由一层或多层组成。<br>例如int *p, p的类型是 pointer to int, 是由2层组成，第1层是“pointer to”,第2层是 “int”。</p>
<p>◆ cv修饰符可以出现在任何层次上。<br>例如 int * const p， 申明了p是“constant pointer to int”, const修饰的是第一层。<br>又比如 volatile int * p， p是 “pointer to volatile int”, volatile修饰的是第二层。</p>
<p>● 在C++中修饰第1层的cv修饰符被称为顶层cv修饰符(top-level cv-qualifier)</p>
<p>再比如：<br>const int * volatile p , 顶层cv修饰符是volatile<br>int * const p, 顶层cv修饰符是const<br>int const volatile * p, 没有顶层修饰符</p>
<p>基本类型例如char, int只由一层构成，因此如下的申明<br>const int x &#x3D; 1;<br>顶层cv修饰符是const.</p>
<p>◆ 小知识：<br>C++函数签名包括所有出现在参数列表中的cv修饰符，除了那些出现在参数列表中的顶层cv修饰符。<br>因此如下2个函数拥有相同的函数签名，认为是同一个函数。<br>虽然函数签名的参数列表中忽略了顶层cv修饰符，但是但函数体内，顶层cv修饰符还是起作用的。比如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">pp</span><span class="params">(<span class="type">int</span> *<span class="type">const</span> p)</span></span>&#123;</span><br><span class="line">   p = … <span class="comment">// error不能对常量指针进行赋值。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="转发引用（forwarding-reference"><a href="#转发引用（forwarding-reference" class="headerlink" title="转发引用（forwarding reference)"></a>转发引用（forwarding reference)</h2><p>转发引用是一种能够保留函数参数值类型的一种特殊引用，这使它能够通过std::forward进行转发。转发引用由2中形式</p>
<p>1.它是函数模板的函数参数，该参数是对同一函数模板的无cv修饰符的类型模板参数的右值引用。(Function parameter of a function template declared as rvalue reference to cv-unqualified type template parameter of that same function template。)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(T&amp;&amp; x)</span> </span>&#123;    <span class="comment">// x is a forwarding reference</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">g</span>(std::forward&lt;T&gt;(x)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">(<span class="type">const</span> T&amp;&amp; x)</span></span>; <span class="comment">// x is not a forwarding reference:</span></span><br><span class="line">                              <span class="comment">// const T is not cv-unqualified</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="title">A</span><span class="params">(T&amp;&amp; x, U&amp;&amp; y, <span class="type">int</span>* p)</span></span>; </span><br><span class="line">    <span class="comment">// x is not a forwarding reference: T is not a</span></span><br><span class="line">    <span class="comment">// type template parameter of the constructor,</span></span><br><span class="line">    <span class="comment">// but y is a forwarding reference</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.auto&amp;&amp;</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">auto<span class="meta">&amp;&amp; vec = foo();       </span></span><br><span class="line"><span class="comment">// foo() may be lvalue or rvalue, </span></span><br><span class="line"><span class="comment">// vec is a forwarding reference</span></span><br><span class="line"></span><br><span class="line">for (auto<span class="meta">&amp;&amp; x: f()) &#123; <span class="comment">// x is a forwarding reference; </span></span></span><br><span class="line"><span class="comment">// this is the safest way to use range for loops</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模板类型推导"><a href="#模板类型推导" class="headerlink" title="模板类型推导"></a>模板类型推导</h2><p>现代C++最引人注目的特性之一就是atuo，它是建立在模板类型推导基础之上的。但模板类型推导应用于auto上有时候不如应用于模板那么直观，所以我们有必要真正的理解模板类型推导, 这样才能更好的理解auto推导。</p>
<p>我们把函数模板表示为如下形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>;</span><br></pre></td></tr></table></figure>
<p>对它的调用表示为：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(expr); // <span class="keyword">call</span> f <span class="keyword">with</span> <span class="keyword">some</span> expression</span><br></pre></td></tr></table></figure>
<p>编译期间，编译器使用expr去推导T和ParamType这两个类型。这两个类型通常是不同的，因为ParamType通常会有cv或引用修饰。<br>例如模板申明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp; param)</span></span>; / / ParamType is <span class="type">const</span> T&amp;</span><br></pre></td></tr></table></figure>
<p>调用如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">f(x);   <span class="operator">/</span><span class="operator">/</span> <span class="keyword">call</span> f <span class="keyword">with</span> an <span class="type">int</span></span><br></pre></td></tr></table></figure>
<p>T被推导为int， ParamType被推导为const int&amp;.<br>在这个例子中T和x的类型都是int，然而并不是所有情况都是如此，T的类型不仅取决于expr的类型还取决于ParamType的形式。</p>
<h3 id="推导规则：（并非C-标准定义的规则，而是易于理解记忆的规则）"><a href="#推导规则：（并非C-标准定义的规则，而是易于理解记忆的规则）" class="headerlink" title="推导规则：（并非C++标准定义的规则，而是易于理解记忆的规则）"></a>推导规则：（并非C++标准定义的规则，而是易于理解记忆的规则）</h3><p>★ 忽略expr的引用类型<br>★ 如果ParamType是非引用类型：<br>■ 如果expr是数组会转化为指向数组第一项元素的指针<br>■ 如果expr是函数会转化为函数指针<br>■ expr的顶级cv修饰符会被忽略掉<br>★ expr 未被忽略掉的且在ParamType中没有出现的cv修饰符能在T中能得到保留。<br>★如果ParamType是转发引用且expr为左值，那么T和ParamType都为左值引用。其余场景将T直接替换到ParamType中去就是param的类型。</p>
<p>下面根据ParamType的如下三种常见形式进行举例说明。</p>
<ol>
<li>aramType是普通引用类型（非转发引用）。</li>
<li>aramType是转发引用</li>
<li>aramType 不是引用类型</li>
</ol>
<p>场景1 : ParamType是普通引用类型（非转发引用）</p>
<h4 id="例1：ParamType是左值引用"><a href="#例1：ParamType是左值引用" class="headerlink" title="例1：ParamType是左值引用"></a>例1：ParamType是左值引用</h4><p>template<typename T><br>void f(T&amp; param);<br>expr定义如下，本章所有场景的例子都使用如下定义，不再特别说明。<br>int x &#x3D; 1;<br>in&amp; rx &#x3D;x;<br>const int cx &#x3D; x;<br>const int&amp; rcx &#x3D; x;<br>volatile int vx &#x3D; x;<br>volatile int&amp; rvx &#x3D; x;<br>const volatile int cvx &#x3D; x;<br>const volatile int&amp; rcvx &#x3D; x;<br>int* px &#x3D; &amp;x;<br>int*&amp; rpx &#x3D; px;<br>int *const cpx &#x3D; &amp;x;<br>const int *pcx &#x3D; &amp;x;<br>const int *const cpcx &#x3D; &amp;xl;<br>int ar[] &#x3D; {1,2,3};<br>void ff(int v){}<br>对于各种情况的调用，T和param的类型如下</p>
<p><img src="https://img-blog.csdnimg.cn/298676bd18034ac58a4e1f473aa3e69e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2FjaGVmaXNo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="image"></p>
<p>要点：<br>●expr中的const和volatile都在T中得到了保留<br>●f(rcx), f(rvx)中，T都不是引用类型，因为rcx和rvx的引用类型都在推导过程中被忽略了。<br>●对于const和volatile的处理都是一样的。</p>
<p>例2：ParamType是cv左值引用<br>对前面的例子稍加改动，ParaType从T&amp;变为const T&amp;<br>template<typename T><br>void f(const T&amp; param);<br>对于各种情况的调用，T和param的类型如下<br><img src="https://img-blog.csdnimg.cn/ff2d4e927aa24e0285aa3213b7dbcf7a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2FjaGVmaXNo,size_19,color_FFFFFF,t_70,g_se,x_16" alt="image"></p>
<p>要点：<br>●因为ParaType中有了const，因此const不必包含在T中（对于volatile同理）。（对于实参为指针类型，ParaType中的const修饰的是指针本身而非指针指向的内容。）<br>●f(vx), f(rvx), f(cvx)中因为ParaType中没有volatile，因此volatile仍在T中得到保留。<br>●expr是指针类型和值类型并无处理上的不同。</p>
<h3 id="例3：ParamType是右值引用"><a href="#例3：ParamType是右值引用" class="headerlink" title="例3：ParamType是右值引用"></a>例3：ParamType是右值引用</h3><p>template<typename T><br>void f(const T&amp;&amp; param);<br>注意：若果没有const修饰，就是转发引用了，后面会特别讨论。</p>
<p>此种情况expr只能是右值。</p>
<p>对于各种情况的调用，T和param的类型如下:<br><img src="https://img-blog.csdnimg.cn/8cf76cd0dcdc4c538f120ba6a67a5a7e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2FjaGVmaXNo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="image"></p>
<p>要点：<br>●move 不改变cv<br>●除了函数只接受右值和前面的情况不没有啥不同。</p>
<p>场景2 : ParamType是转发引用类型<br>ParamType是转发引用只有如下一种情况<br>template<typename T><br>void f(T&amp;&amp; param);</p>
<p>推导规则补充说明：<br>1.如果expr是左值，T和ParamType都推导为左值引用。<br>2.如果expr是右值，根据普通引用的规则进行推导。</p>
<p>对于传入右值的调用，T和param的类型如下:<br><img src="https://img-blog.csdnimg.cn/66e2a725edc1412eacf3ed1e1abfd015.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2FjaGVmaXNo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="image"></p>
<p>要点：<br>●para都是右值引用</p>
<p>对于传入左值的调用，T和param的类型如下:<br><img src="https://img-blog.csdnimg.cn/c97e62bb5c494330be1cc834c0cddc8b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2FjaGVmaXNo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="image"></p>
<p>要点：<br>●如果expr是左值T被推导为左值引用，这是模板类型推导唯一会推导出T为引用类型的场景。<br>●expr中的const和volatile都在T中得到了保留</p>
<p>场景3: ParamType不是引用类型（指针或值）<br>推导要点：忽略expr的顶级cv修饰符，数组和函数会退化为指针类型。<br>例1：ParamType是值<br>template<typename T><br>void f(T param);<br>对于各种情况的调用，T和param的类型如下:<br><img src="https://img-blog.csdnimg.cn/26c2e61c8ae94050a9577d69a5557603.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2FjaGVmaXNo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="image"></p>
<p>例2：ParamType是指针<br>template<typename T><br>void f(T* param); </p>
<p>对于各种情况的调用，T和param的类型如下<br><img src="https://img-blog.csdnimg.cn/9d536ce3fff04e7c8377b576cdebea75.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2FjaGVmaXNo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="image"><br>备注：T都不为指针类型，因为ParamType中已经有指针了，指针类型不必包含在T中了。（和cv的处理同理）</p>
<p>auto类型推导<br>auto类型和推导同模板类型推导基本有一样的规则，只有一个例外，后面会讲到。虽然形式上2者看起来不一样但是2者存在直接的映射关系。</p>
<p>前一节中我们把函数模板表示为如下形式：<br>template<typename T><br>void f(ParamType param);<br>对它的调用表示为：<br>f(expr); &#x2F;&#x2F; call f with some expression<br>当调用f, 编译器使用expr推断T和ParamType的类型。<br>当一个变量定义时使用auto，auto的作用相当于T，变量的类型说明符相当于ParamType, 变量名相当于param, 右边的初始化表达式相当于expr, 例如：</p>
<p><img src="https://img-blog.csdnimg.cn/bef2217e10c84e5898c7ebe14cee839b.png" alt="image"></p>
<p>如下例子是一些例子，和模板类型推导没有任何区别：</p>
<figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">auto</span> x = <span class="number">1</span>;                //<span class="keyword">case</span> <span class="number">3</span>, x <span class="keyword">is</span> <span class="type">int</span></span><br><span class="line"><span class="type">auto</span>* px = &amp;x;             //<span class="keyword">case</span> <span class="number">3</span>, px <span class="keyword">is</span> *<span class="type">int</span></span><br><span class="line"><span class="keyword">const</span> <span class="type">auto</span> cx = x;         //<span class="keyword">case</span> <span class="number">3</span>, cx <span class="keyword">is</span> <span class="keyword">const</span> <span class="type">int</span></span><br><span class="line"><span class="keyword">const</span> <span class="type">auto</span>&amp; rx = x;        //<span class="keyword">case</span> <span class="number">1</span>, rx <span class="keyword">is</span> <span class="keyword">const</span> <span class="type">int</span>&amp;</span><br><span class="line"><span class="type">auto</span>&amp;&amp; fr1 = x;            //<span class="keyword">case</span> <span class="number">2</span>, fr1 <span class="keyword">is</span> <span class="type">int</span>&amp;</span><br><span class="line"><span class="type">auto</span>&amp;&amp; fr2 = cx;           //<span class="keyword">case</span> <span class="number">2</span>, fr2 <span class="keyword">is</span> <span class="keyword">const</span> <span class="type">int</span>&amp;</span><br><span class="line"><span class="type">auto</span>&amp;&amp; fr3 = <span class="number">27</span>;           //<span class="keyword">case</span> <span class="number">2</span>, fr3 <span class="keyword">is</span> <span class="type">int</span>&amp;&amp;</span><br></pre></td></tr></table></figure>

<p>和模板类型推导的唯一例外<br>前面看到的都是auto类型推导和模板类型推导的相同之处，这里要介绍他们唯一的不同。<br>C++11之前定义并初始化一个变量可以按照如下方式：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int x1 <span class="operator">=</span> <span class="number">1</span><span class="comment">;</span></span><br><span class="line">int x2(<span class="number">1</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>C++11开始支持统一初始化,支持如下形式：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int x3&#123;<span class="number">1</span>&#125;</span><br><span class="line">int x4 <span class="operator">=</span> &#123;<span class="number">1</span>&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>如果使用auto来从写上面4个定义</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto x1 <span class="operator">=</span> <span class="number">1</span><span class="comment">;</span></span><br><span class="line">auto x2(<span class="number">1</span>)<span class="comment">;</span></span><br><span class="line">auto x3&#123;<span class="number">1</span>&#125;<span class="comment">;</span></span><br><span class="line">auto x4<span class="operator">=</span>&#123;<span class="number">1</span>&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>上面4个auto定义的变量类型并不都是int， x4为std::initializer_list. (C++11中x3也为std::initializer_list，之后的标准中为int).<br>★这就是auto类型推导的特别之处，对于&#x3D;{}形式的初始化特别处理了。<br>★函数模板不支持对{}的推导。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">auto</span> x = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125; // x的类型为std::initializer_list&lt;int&gt;</span><br><span class="line"><span class="attribute">template</span>&lt;typename T&gt;</span><br><span class="line"><span class="attribute">void</span> f(T param);</span><br><span class="line"><span class="attribute">f</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;)         //error! 不能推导T的类型</span><br></pre></td></tr></table></figure>
<p>但是模板类型推导支持 param 是std::initializer_list<T>的形式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::initializer_list&lt;T&gt; init_list)</span></span>;</span><br><span class="line"><span class="built_in">f</span>(&#123; <span class="number">11</span>, <span class="number">23</span>, <span class="number">9</span> &#125;); </span><br><span class="line"><span class="comment">// T为 int,init_list类型为 std::initializer_list&lt;int&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>auto也能推导函数返回值，此时应用的是也模板类型推导规则<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">create_initlist</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;  <span class="comment">// error: can&#x27;t deduce type  for </span></span><br><span class="line">                     <span class="comment">// &#123; 1, 2, 3 &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>auto 应用于lambda也是模板类型推导规则<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">auto</span> reset_v = [&amp;v](<span class="type">const</span> <span class="keyword">auto</span>&amp; new_value) &#123; </span><br><span class="line">v = new_value; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">reset_v</span>(&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;); <span class="comment">// error! can&#x27;t deduce type for</span></span><br><span class="line">                      <span class="comment">//&#123; 1, 2, 3 &#125;</span></span><br></pre></td></tr></table></figure>
decltype(auto)<br>decltype 总是返回实体的准确类型， auto使用模板类型推导的规则(比如会去掉引用等）。</li>
</ul>
<p>decltype示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">0</span>;           <span class="comment">// decltype(i) is const int</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">f</span><span class="params">(<span class="type">const</span> Widget&amp; w)</span></span>;   <span class="comment">// decltype(w) is const Widget&amp;</span></span><br><span class="line">                           <span class="comment">// decltype(f) is bool(const Widget&amp;)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="type">int</span> x, y;                <span class="comment">// decltype(Point::x) is int</span></span><br><span class="line">&#125;;                         <span class="comment">// decltype(Point::y) is int</span></span><br><span class="line">Widget w;                  <span class="comment">// decltype(w) is Widget</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">f</span>(w)) ...              <span class="comment">// decltype(f(w)) is bool</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;       <span class="comment">// simplified version of std::vector</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  T&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> index);</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;             <span class="comment">// decltype(v) is vector&lt;int&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (v[<span class="number">0</span>] == <span class="number">0</span>) ...         <span class="comment">// decltype(v[0]) is int&amp;</span></span><br></pre></td></tr></table></figure>

<p>◆Decltype可以和auto组合使用，使auto应用decltype的规则。<br>单纯使用auto</p>
<figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Widget</span> w;</span><br><span class="line"><span class="keyword">const</span> <span class="type">Widget</span>&amp; cw = w;</span><br><span class="line"><span class="type">auto</span> mw = cw;  // <span class="type">auto</span> <span class="keyword">type</span> deduction, mw&#x27;s <span class="keyword">type</span> <span class="keyword">is</span> <span class="type">Widget</span></span><br></pre></td></tr></table></figure>
<p>使用decltype(auto)</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">decltype(auto) mw = cw; // decltype <span class="keyword">type</span> <span class="type">deduction:</span></span><br><span class="line"><span class="type">                        </span>// mw<span class="symbol">&#x27;s</span> <span class="keyword">type</span> <span class="type">is </span>const Widget&amp;</span><br></pre></td></tr></table></figure>

<h3 id="如何查看推导得出的类型"><a href="#如何查看推导得出的类型" class="headerlink" title="如何查看推导得出的类型"></a>如何查看推导得出的类型</h3><h4 id="通过编译错误信息"><a href="#通过编译错误信息" class="headerlink" title="通过编译错误信息"></a>通过编译错误信息</h4><p>可以让编译器使用推导出的类型时产生编译错误，从而在输出的错误信息中看到推导出的类型。比如我们只申明但不定义一个类模板，然后使用这类模板。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TD</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">f1</span><span class="params">(T&amp; param)</span></span>&#123;</span><br><span class="line">    TD&lt;<span class="keyword">decltype</span>(param)&gt; pt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(deduce, <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">f1</span>(ff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在vc2019下有如下输出：<br>error C2079: “pt”使用未定义的 class“TD&lt;T (__cdecl &amp;)&gt;”<br>message : 查看对正在编译的函数 模板 实例化“void f1&lt;void(int)&gt;(T (__cdecl &amp;))”的引用</p>
<p>在g++ 11下有如下输出：<br>In instantiation of ‘void f1(T&amp;) [with T &#x3D; void(int)]’:<br>error: ‘TD&lt;void (&amp;)(int)&gt; pt’ has incomplete type</p>
<p>从中我们都可以看出T的类型为void(int), param的类型为void(&amp;)(int)</p>
<p>使用Boost.Type‐Index<br>该库是头文件形式的库，不需要编译，下载boost后直接include就可以使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">f1</span><span class="params">(T&amp; param)</span></span>&#123;</span><br><span class="line"><span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;T=&quot;</span> &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;T&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;param=&quot;</span> &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(param)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">f1</span>(ff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>G++11编译输出如下：<br>T&#x3D;void (int)<br>param&#x3D;void (&amp;)(int)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cachefish.github.io/2022/03/07/15-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2229.jfif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="来世做春风，浪漫且自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cachecatのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/07/15-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" class="post-title-link" itemprop="url">c++ 字符编码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-07 19:30:00 / 修改时间：10:13:28" itemprop="dateCreated datePublished" datetime="2022-03-07T19:30:00+08:00">2022-03-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-base/" itemprop="url" rel="index"><span itemprop="name">c++ base</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="字符编码概述"><a href="#字符编码概述" class="headerlink" title="字符编码概述"></a>字符编码概述</h2><p>字符集就是一系列用于显示的字符的集合。<br>编码就是这些字符如何用字节流进行表示。一个字符集可能有多种编码方式.</p>
<h3 id="ANSI编码"><a href="#ANSI编码" class="headerlink" title="ANSI编码"></a>ANSI编码</h3><p>世界各国针对ASCII的扩展方案（如欧洲的ISO&#x2F;IEC 8859，中国的GB系列等），这些ASCII扩展编码方案的特点是：他们都兼容ASCII编码，但他们彼此之间是不兼容的。微软将这些编码方案统称为ANSI编码。</p>
<h3 id="代码页"><a href="#代码页" class="headerlink" title="代码页"></a>代码页</h3><p>在windows操作系统上，默认使用ANSI来保存文件。那么操作系统是如何知道ANSI到底应该表示哪种编码了，是GBK，还是ASCII，或者还是EUC-KR了？ windows通过一个叫”Code Page”（翻译为中文就叫代码页）的东西来判断系统的默认编码。<br>ANSI编码可以理解为非Unicode编码的统称</p>
<p>各种编码的字符串能强制转换为char类型的字符串来操作？<br>UTF16,UTF32编码不行，因为中间bytes存在大量0。<br>UTF8和其它ANSI编码可以，因为本来就是多字节编码没必要在中间添加0来浪费空间。</p>
<h2 id="源字符集，执行字符集"><a href="#源字符集，执行字符集" class="headerlink" title="源字符集，执行字符集"></a>源字符集，执行字符集</h2><p>源字符集(source character set)：<br>源字符集中的字符就是源程序的字符，编译器读取源文件时需要理解的编码方式（注意没有编辑器什么关系）。<br>执行字符集(execution character set)：<br>执行字符集表示可出现在已编译程序中的字符，程序运行时字符的编码方式。 这些字符集由源文件中允许的所有字符以及表示警报、退格符、回车符和 null 字符的控制字符组成。</p>
<h3 id="vc-源字符集"><a href="#vc-源字符集" class="headerlink" title="vc 源字符集"></a>vc 源字符集</h3><p>1.若文件开始处有BOM(EF BB BF)，则判定为UTF-8编码；<br>2.若没有BOM，则试图从文件的前8个字节来判断文件是否像UTF-16编码，如果像，则就判断为UTF-16编码。<br>3.如果既没BOM，也不是UTF-16编码，则使用系统当前的代码页。<br>&#x2F;source-charset or &#x2F;utf-8  </p>
<h3 id="gcc-源字符集"><a href="#gcc-源字符集" class="headerlink" title="gcc 源字符集"></a>gcc 源字符集</h3><p>默认UTF-8<br>-finput-charset</p>
<h3 id="vc-执行字符集"><a href="#vc-执行字符集" class="headerlink" title="vc 执行字符集"></a>vc 执行字符集</h3><p>1.对于宽字符串（即C&#x2F;C++中以L标记的串，如L”abc”, L’中’），执行字符集为UTF-16编码。<br>2.u8，u, U前缀字符串，分别UTF8, UTF16, UTF32编码<br>3.对于未带前缀的字符串，执行字符集为系统当前的代码页。<br>&#x2F;execution-charset or &#x2F;utf-8 </p>
<h3 id="gcc执行字符集"><a href="#gcc执行字符集" class="headerlink" title="gcc执行字符集"></a>gcc执行字符集</h3><p>1.对于宽字符串UTF-32<br>2.u8，u, U前缀字符串，分别UTF8, UTF16, UTF32编码<br>3.对于未带前缀的字符串，默认UTF-8<br>-fexec-charset<br>-fwide-exec-charset</p>
<h3 id="VC"><a href="#VC" class="headerlink" title="VC"></a>VC</h3><p>VC默认情况下，Visual Studio会检测字节顺序标记，以确定源文件是否是编码过的Unicode格式，例如UTF-16或UTF-8。如果没有找到字节顺序标记，它假定源文件是使用当前用户代码页编码的，除非您通过使用&#x2F;source-charset选项或&#x2F;utf-8选项指定了字符集名称或代码页。Visual Studio允许你通过使用几种字符编码来保存你的c++源代码。有关源代码和执行字符集的信息，请参阅语言文档中的字符集。如果您希望将源字符集和执行字符集都设置为UTF-8，您可以使用&#x2F; UTF-8编译器选项作为快捷方式。它相当于在命令行上指定&#x2F;sourcecharset:utf-8 &#x2F; execute -charset:utf-8。默认情况下，这些选项都启用&#x2F;validate-charset选项。</p>
<h3 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h3><ul>
<li>-finput-charset&#x3D;charset<br> 设置输入字符集，用于将输入文件的字符集转换为GCC使用的源字符集。如果区域设置没有指定，或者GCC无法从区域设置获取此信息，则默认为UTF-8。这可以被区域设置或命令行选项覆盖。目前，如果有冲突，命令行选项优先。Charset可以是系统iconv库例程支持的任何编码。</li>
<li>-fexec-charset&#x3D;charset<br>设置执行字符集，用于字符串和字符常量。默认为UTF-8。Charset可以是系统iconv库例程支持的任何编码。</li>
<li>-fwide-exec-charset&#x3D;charset<br>设置宽执行字符集，用于宽字符串和字符常量。默认值是UTF-32或UTF-16，两者都对应于wchar_t的宽度。和’-fex -charset’一样，charset可以是系统iconv库例程支持的任何编码;但是，编码不完全适合wchar_t会有问题。</li>
</ul>
<h2 id="字符文本"><a href="#字符文本" class="headerlink" title="字符文本"></a>字符文本</h2><p>字符字面值由常量字符组成。它由单引号包围的字符表示。字符字面值有五种:</p>
<ol>
<li>char类型的普通字符字面值，例如’a’</li>
<li>char类型的UTF-8字符字面值(c++20中的char8_t)，例如u8’a’．</li>
<li>wchar_t类型的宽字符字面值，例如L’a’</li>
<li>char16_t类型的UTF-16字符字面值，例如u’a’</li>
<li>char32 t类型的UTF-32字符字面值，例如U’a’</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> s3 = <span class="string">u&quot;hello&quot;</span>; <span class="type">const</span> <span class="type">char16_t</span>*</span><br><span class="line"><span class="keyword">auto</span> s4 = <span class="string">U&quot;heelo&quot;</span>; <span class="type">const</span> <span class="type">char32_t</span>*</span><br><span class="line"><span class="type">const</span> <span class="type">wchar_t</span> wide = <span class="string">L&quot;zyxw&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">wchar_t</span> newline=<span class="string">L&quot;hello\ngood&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//c++20 -&gt;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char8_t</span> u8str1 = <span class="string">u8&quot;hello world&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char8_t</span> u8str2 = <span class="string">u8&quot;\U0001F607 is 0:-&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="std-string-文本"><a href="#std-string-文本" class="headerlink" title="std::string 文本"></a>std::string 文本</h2><p>string字面值是用户定义的字面值(见下文)的标准库实现，表示为“xyz”(带有s后缀)。这种字符串字面值产生一个临时对象，类型为std::string、std::wstring、std::u32string或std::u16string，这取决于所指定的前缀。如果没有使用任何前缀，就会产生一个std::string。L”xyz”生成一个std::wstring。u”xyz”s生成一个std:u16string, u”xyz”s生成一个std:u32string。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str&#123;<span class="string">&quot;hello&quot;</span>s&#125;;</span><br><span class="line"><span class="built_in">string</span> str2&#123;u8<span class="string">&quot;&quot;</span>Hello world<span class="string">&quot;&#125;;</span></span><br><span class="line"><span class="string">u8string u8str2&#123;u8&quot;</span>Hello World<span class="string">&quot;&#125;;</span></span><br><span class="line"><span class="string">wstring str3&#123;L&quot;</span>hello<span class="string">&quot;s&#125;;</span></span><br><span class="line"><span class="string">u16string str4&#123;u&quot;</span>hello<span class="string">&quot;s&#125;;</span></span><br><span class="line"><span class="string">u32string str5&#123;U&quot;</span>hello<span class="string">&quot;s&#125;;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<h3 id="字符文本的执行期编码："><a href="#字符文本的执行期编码：" class="headerlink" title="字符文本的执行期编码："></a>字符文本的执行期编码：</h3><p>除了普通字符和宽字符由编译器决定，其余字符文本都给予前缀表示的方式进行编码。可见同一个编译单元中字符的执行期编码可以有多种。</p>
<p>对于程序运行过程的和外界交互（网络收发，文件读写，数据库读写等）涉及到的字符，则要规定好编码方式，然后进行处理。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cachefish.github.io/2022/03/07/16-c-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2229.jfif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="来世做春风，浪漫且自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cachecatのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/07/16-c-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">c++ 基本概念</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-07 19:30:00 / 修改时间：10:13:35" itemprop="dateCreated datePublished" datetime="2022-03-07T19:30:00+08:00">2022-03-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-base/" itemprop="url" rel="index"><span itemprop="name">c++ base</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>1.变量占用存储空间么？<br>2.引用占用存储空间么？<br>3.什么是对象？<br>4.为什么对象需要对齐？</p>
<p>C++程序是如何生成的:</p>
<p>编译单元:一个c++文件以及由#include包含进来的其他文件。<br>预处理:处理预处理指令，将#include把其他.h和.cpp与当前编译的.cpp合并到一起。<br>编译:产生汇编代码<br>汇编:产生机器码<br>链接:解析引用的外部符号，如果引用的静态库的符号，把相关实现拷贝到最终输出的可执行程序或者静态库，不需要执行链接。<br>运行:加载动态库，为静态存储期对象分配空间，初始化非局部静态存储期对象，执行main函数。</p>
<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><h3 id="mian函数签名"><a href="#mian函数签名" class="headerlink" title="mian函数签名"></a>mian函数签名</h3><p>main函数没有声明，因为它是内建在语言中,<br>main的声明语法如下所示:<br>int maain（）;<br>Int main（int arge， char “argv[1）;</p>
<h3 id="标准命令行参数"><a href="#标准命令行参数" class="headerlink" title="标准命令行参数"></a>标准命令行参数</h3><p>main的参数允许对参数进行方便的命令行解析。argc和argv的类型是由语言定义的。argc和argv的名称是传统的，但您可以随意命名它们。<br>参数定义如下:<br>argc是一个整数，表示argv后面的参数的个数。<br>argc总是大于或等于1。argv一个以空字符结束的字符串数组，表示程序用户输入的命令行参数。按照惯例，argv[0]是用来调用程序的命令。Argv[1]是第一个命令行参数。命令行最后一个参数是argv[argc-1)， argv[argc]总是NULL</p>
<h2 id="c-程序终止"><a href="#c-程序终止" class="headerlink" title="c++程序终止"></a>c++程序终止</h2><p>在c++中，你可以通过以下方式退出程序:</p>
<ul>
<li>调用中止函数exit()。</li>
<li>调用abort()函数</li>
<li>从main执行返回语句</li>
</ul>
<h3 id="exit"><a href="#exit" class="headerlink" title="exit()"></a>exit()</h3><p>退出函数在&lt;stdlib.h&gt;中声明的exit函数终止c++程序。作为退出参数提供的值作为程序的返回码或退出码返回给操作系统。按照惯例，返回码为零意味着程序成功完成。可以使用常量EXIT FAILURE和EXIT SUCCESS(也在&lt;stdlib.h&gt;中定义)来指示程序的成功或失败。从main函数发出retun语句相当于用返回值作为参数调用exit函数。</p>
<h3 id="abort"><a href="#abort" class="headerlink" title="abort()"></a>abort()</h3><p>中止函数也在标准的include文件&lt;stdlib.h&gt;中声明，它终止一个c++程序。exit和abort之间的区别在于，exit允许进行c++运行时终止处理(调用全局对象析构函数)，但abort立即终止程序。中止函数绕过已初始化的全局静态对象的正常销毁过程。它还绕过了使用atexit函数指定的任何特殊处理。</p>
<h2 id="atexit"><a href="#atexit" class="headerlink" title="atexit()"></a>atexit()</h2><p>注册函数所指向的函数，在程序正常终止(通过std:exit()或从主函数返回)时调用。这些函数可以与具有静态存储时间的对象的销毁同时调用，也可以相互调用。保证如果A的注册被排序了——在B注册之前，那么B的调用也被排序了——在调用A之前，同样适用于静态对象构造函数和atexit调用之间的排序。</p>
<h2 id="动态库-x2F-静态库"><a href="#动态库-x2F-静态库" class="headerlink" title="动态库&#x2F;静态库"></a>动态库&#x2F;静态库</h2><p>静态库:链接时，静态库会被完整的复制到可执行文件中，被多次使用就有多份冗余拷贝。<br>动态库:链接时不复制，程序运行时由系统动态加载到内存中，供程序调用，系统只加载一次，多个程序共用，节省内存。</p>
<h3 id="选择动态库的理由："><a href="#选择动态库的理由：" class="headerlink" title="选择动态库的理由："></a>选择动态库的理由：</h3><p>1.需要在不重新编译使用者的情况下更新功能。<br>2.需要在进程内的多个动态库中共享状态。<br>3.需要运行时动态加载库，比如实现插件功能。<br>4.库被进程内的许多其它库使用，想降低整个程序包的磁盘空间和运行时占用内存。</p>
<h3 id="选择静态库的理由："><a href="#选择静态库的理由：" class="headerlink" title="选择静态库的理由："></a>选择静态库的理由：</h3><p>1.运行环境限制，不能使用动态库。（ios上的app)<br>2.不想维持接口的兼容，接口经常变化，又不想影响已经使用该库的用户。<br>3.方便程序的部署。</p>
<p>更深入的理解请参考：<br>&lt;&lt;深入理解计算机系统&gt;&gt;，&lt;&lt;程序员的自我修养—链接、装载与库&gt;&gt;</p>
<h2 id="变量占用存储空间么？"><a href="#变量占用存储空间么？" class="headerlink" title="变量占用存储空间么？"></a>变量占用存储空间么？</h2><p>在计算机编程中声明一个变量并不一定占用内存空间。</p>
<p>计算机编程中声明的含义当一个计算机程序需要调用内存空间的时候，对内存发出的“占位”指令，我们称之为“声明”。</p>
<p>&#x3D;&#x3D;声明一个变量只是将变量名标识符的有关信息告诉编译器，使编译器“认识”该标识符，但是声明并不一定引起内存的分配！而定义一个变量意味着给变量分配内存空间，用于存放对应类型的数据，变量名就是对相应的内存单元的命名。&#x3D;&#x3D;</p>
<p>C++程序中，大多数情况下变量声明也就是变量定义，声明变量的同时也就完成了变量的定义，只有声明外部变量时例外。</p>
<p>VB程序，Dim 语句，声明变量并分配存储空间。</p>
<p>当然这些语句实际是在程序运行或调试时才真正起作用，也有一些是在程序运行中还会发生动态数组变量的再定义而改变占用内存空间的。</p>
<p>变量来源于数学，是计算机语言中能储存计算结果或能表示值抽象概念。变量可以通过变量名访问。</p>
<p>在指令式语言中，变量通常是可变的；但在纯函数式语言（如Haskell）中，变量可能是不可变（immutable）的。在一些语言中，变量可能被明确为是能表示可变状态、具有存储空间的抽象（如在Java和Visual Basic中）；但另外一些语言可能使用其它概念（如C的对象）来指称这种抽象，而不严格地定义“变量”的准确外延。</p>
<h3 id="2-引用占用存储空间么？"><a href="#2-引用占用存储空间么？" class="headerlink" title="2.引用占用存储空间么？"></a>2.引用占用存储空间么？</h3><p>引用不是一种独立的数据类型，对引用只有声明没有定义<br>声明一个引用时，必须进行初始化<br>声明一个引用后，不能再使之作为另一个变量的引用<br>不能建立引用数组<br>int a[3];<br>int &amp;b[3]&#x3D;a; &#x2F;&#x2F;错误，不能建立引用数组<br>int &amp;b&#x3D;a[0]; &#x2F;&#x2F;错误，不能作为数组元素的别名<br>不能建立引用的引用，不能建立引用的指针<br>可以取引用的地址</p>
<p>&#x3D;&#x3D;引用同指针一样，占用一个4字节的内存空间（32位）&#x3D;&#x3D;<br>&#x3D;&#x3D;引用不占空间意思就是不占对象空间，不表示不占指针的少量空间。实际上指针是汇编工具实现引用的一种方式而已，而有的优化结果可能没有代表自己的指针&#x3D;&#x3D;</p>
<p>引用本质上是一个指针常量，在内存中为引用开辟了一个指针型的内存单元</p>
<h3 id="3-什么是对象？"><a href="#3-什么是对象？" class="headerlink" title="3.什么是对象？"></a>3.什么是对象？</h3><p>面对对象思想代表了一种看待事物的角度,面对对象思想代表了一种看待事物的角度。对象可以视为一种具有特定可控制生命周期的（构造，删除等），可以绑定函数以及属性的可复用的数据结构。</p>
<h3 id="4-为什么对象需要对齐？"><a href="#4-为什么对象需要对齐？" class="headerlink" title="4.为什么对象需要对齐？"></a>4.为什么对象需要对齐？</h3><p>据内存对齐（非静态成员变量）<br>第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行。</p>
<p>在数据成员完成各自对齐之后，类(结构或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。</p>
<p>很明显#pragma pack(n)作为一个预编译指令用来设置多少个字节对齐的。值得注意的是，n的缺省数值是按照编译器自身设置，一般为8，合法的数值分别是1、2、4、8、16。（即编译器只会按照1、2、4、8、16的方式分割内存。若n为其他值，是无效的。）</p>
<p><img src="https://img-blog.csdnimg.cn/2020052615523975.png#pic_center" alt="image"><br>内存分配过程：（对齐当前数据的内存最大值）</p>
<ol>
<li>char和编译器默认的内存缺省分割大小比较，char比较小，分配一个字节给它。</li>
<li>int和编译器默认的内存缺省分割大小比较，int比较小，占4字节。只能空3个字节，重新分配4个字节。</li>
<li>short和编译器默认的内存缺省分割大小比较，short比较小，占2个字节，分配2个字节给它。</li>
<li>对齐结束类本身也要对齐，所以最后空余的2个字节也被test占用。<br><img src="https://img-blog.csdnimg.cn/20200526155258690.png#pic_center" alt="image"></li>
<li>int和编译器默认的内存缺省分割大小比较，int比较小，占4字节。分配4个字节给int。</li>
<li>char和编译器默认的内存缺省分割大小比较，char比较小，分配一个字节给它。</li>
<li>short和编译器默认的内存缺省分割大小比较，short比较小，此时前面的char分配完毕还余下3个字节，足够short的2个字节存储，所以short紧挨着。分配2个字节给short。</li>
<li>对齐结束类本身也要对齐，所以最后空余的1个字节也被该对象占用。</li>
<li>可以使用#pragma pack(n)来决定字节对齐的标准。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cachefish.github.io/2022/03/07/17-netfiliter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2229.jfif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="来世做春风，浪漫且自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cachecatのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/07/17-netfiliter/" class="post-title-link" itemprop="url">netfiliter</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-07 19:30:00 / 修改时间：10:13:43" itemprop="dateCreated datePublished" datetime="2022-03-07T19:30:00+08:00">2022-03-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/network/" itemprop="url" rel="index"><span itemprop="name">network</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="netfiliter"><a href="#netfiliter" class="headerlink" title="netfiliter"></a>netfiliter</h2><p>netfilter 项目支持数据包过滤、网络地址 [和端口] 转换 (NA[P]T)、数据包日志记录、用户空间数据包队列和其他数据包处理。</p>
<p>netfilter 钩子是 Linux 内核中的一个框架，它允许内核模块在 Linux 网络堆栈的不同位置注册回调函数。然后，为遍历 Linux 网络堆栈中相应挂钩的每个数据包回调已注册的回调函数。</p>
<hr>
<h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><p>无状态数据包过滤（IPv4 和 IPv6）<br>有状态数据包过滤（IPv4 和 IPv6）<br>各种网络地址和端口转换，例如 NAT&#x2F;NAPT（IPv4 和 IPv6）<br>灵活和可扩展的基础设施<br>用于 3rd 方扩展的多层 API</p>
<hr>
<h3 id="我可以用-netfilter-做什么？"><a href="#我可以用-netfilter-做什么？" class="headerlink" title="我可以用 netfilter 做什么？"></a>我可以用 netfilter 做什么？</h3><p>基于无状态和有状态包过滤构建互联网防火墙<br>部署高可用的无状态和有状态防火墙集群<br>如果您没有足够的公共 IP 地址，请使用 NAT 和伪装来共享 Internet 访问<br>使用 NAT 实现透明代理<br>帮助用于构建复杂的 QoS 和策略路由器的 tc 和 iproute2 系统<br>进行进一步的数据包操作（修改），例如更改 IP 标头的 TOS&#x2F;DSCP&#x2F;ECN 位</p>
<h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><h3 id="规则概念"><a href="#规则概念" class="headerlink" title="规则概念"></a>规则概念</h3><p>规则（rules）其实就是网络管理员预定义的条件，规则一般的定义为“如果数据包头符合这样的条件，就这样处理这个数据包”。规则存储在内核空间的信息 包过滤表中，这些规则分别指定了源地址、目的地址、传输协议（如TCP、UDP、ICMP）和服务类型（如HTTP、FTP和SMTP）等。<br>当数据包与规则匹配时，iptables就根据规则所定义的方法来处理这些数据包，如放行(accept),拒绝(reject)和丢弃(drop)等。配置防火墙的主要工作是添加,修改和删除等规则。<br>其中：</p>
<ul>
<li>匹配（match）：符合指定的条件，比如指定的 IP 地址和端口。</li>
<li>丢弃（drop）：当一个包到达时，简单地丢弃，不做其它任何处理。</li>
<li>接受（accept）：和丢弃相反，接受这个包，让这个包通过。</li>
<li>拒绝（reject）：和丢弃相似，但它还会向发送这个包的源主机发送错误消息。这个错误消息可以指定，也可以自动产生。</li>
<li>目标（target）：指定的动作，说明如何处理一个包，比如：丢弃，接受，或拒绝。</li>
<li>跳转（jump）：和目标类似，不过它指定的不是一个具体的动作，而是另一个链，表示要跳转到那个链上。</li>
<li>规则（rule）：一个或多个匹配及其对应的目标</li>
</ul>
<h2 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h2><p>规则存储在内核空间的信息包过滤表中，这些规则分别指定了源地址、目的地址、传输协议（如TCP、UDP、ICMP）和服务类型（如HTTP、FTP和SMTP）等。当数据包与规则匹配时，iptables就根据规则所定义的方法来处理这些数据包，如放行（accept）、拒绝（reject）和丢弃（drop）等。配置防火墙的主要工作就是添加、修改和删除这些规则。</p>
<h4 id="1-iptables的概述"><a href="#1-iptables的概述" class="headerlink" title="1. iptables的概述"></a>1. iptables的概述</h4><p>iptables 实际上就是一种包过滤型防火墙。 就是通过书写一些接受哪些包，拒绝哪些包的规则，实现数据包的过滤。这些规则存储在专用的信息包过滤表中，而这些表集成在Linux 内核中。在信息包过滤表中，规则被分组放在我们所谓的链（chain）中。</p>
<h4 id="2-iptables的组成"><a href="#2-iptables的组成" class="headerlink" title="2. iptables的组成"></a>2. iptables的组成</h4><p>iptables由两部分组成：<br>(1) framework： netfilter hooks function钩子函数，实现网络过滤器的基本框架。<br>(2) rule utils： iptables 规则管理工具</p>
<h4 id="3-iptables的三链五表"><a href="#3-iptables的三链五表" class="headerlink" title="3. iptables的三链五表"></a>3. iptables的三链五表</h4><p>表（tables）：提供特定的功能，iptables内置了4个表，即filter表、nat表、mangle表和raw表，分别用于实现包过滤，网络地址转换、包重构(修改)和数据跟踪处理。<br>链（chains）：是数据包传播的路径，每一条链其实就是众多规则中的一个检查清单，每一条链中可以有一 条或数条规则。当一个数据包到达一个链时，iptables就会从链中第一条规则开始检查，看该数据包是否满足规则所定义的条件。如果满足，系统就会根据 该条规则所定义的方法处理该数据包；否则iptables将继续检查下一条规则，如果该数据包不符合链中任一条规则，iptables就会根据该链预先定 义的默认策略来处理数据包。</p>
<p>Iptables采用“表”和“链”的分层结构，在Linux中现在是四张表五个链。下面罗列一下这四张表和五个链<br>总体说来，iptables就是由“三表五链”组成。</p>
<h5 id="规则表："><a href="#规则表：" class="headerlink" title="规则表："></a>规则表：</h5><pre><code>1）filter表——三个链：INPUT、FORWARD、OUTPUT
作用：过滤数据包 内核模块：iptables_filter.
2）Nat表——三个链：PREROUTING、POSTROUTING、OUTPUT
作用：用于网络地址转换（IP、端口） 内核模块：iptable_nat
3）Mangle表——五个链：PREROUTING、POSTROUTING、INPUT、OUTPUT、FORWARD
作用：修改数据包的服务类型、TTL、并且可以配置路由实现QOS内核模块：iptable_mangle(别看这个表这么麻烦，咱们设置策略时几乎都不会用到它)
4）Raw表——两个链：OUTPUT、PREROUTING
作用：决定数据包是否被状态跟踪机制处理 内核模块：iptable_raw
</code></pre>
<h5 id="规则链："><a href="#规则链：" class="headerlink" title="规则链："></a>规则链：</h5><pre><code>1）INPUT——进来的数据包应用此规则链中的策略
2）OUTPUT——外出的数据包应用此规则链中的策略
3）FORWARD——转发数据包时应用此规则链中的策略
4）PREROUTING——对数据包作路由选择前应用此链中的规则（记住！所有 的数据包进来的时侯都先由这个链处理）
5）POSTROUTING——对数据包作路由选择后应用此链中的规则
</code></pre>
<p><img src="https://images2015.cnblogs.com/blog/907596/201701/907596-20170109105448244-1425780290.png" alt="image"></p>
<h4 id="x3D-x3D-管理和设置iptables规则：-x3D-x3D"><a href="#x3D-x3D-管理和设置iptables规则：-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;管理和设置iptables规则：&#x3D;&#x3D;"></a>&#x3D;&#x3D;管理和设置iptables规则：&#x3D;&#x3D;</h4><p><img src="https://images2015.cnblogs.com/blog/907596/201701/907596-20170109105720728-1179021991.png" alt="image"><br><img src="https://images2015.cnblogs.com/blog/907596/201701/907596-20170109105731713-1860013490.png" alt="image"><br>iptables传输数据包的过程<br><img src="https://images2015.cnblogs.com/blog/907596/201701/907596-20170109110004244-1719477737.png" alt="image"></p>
<p> 1）当一个数据包进入网卡时，它首先进入PREROUTING链，内核根据数据包目的IP判断是否需要转送出去。<br>   2）如果数据包就是进入本机的，它就会沿着图向下移动，到达INPUT链。数据包到了INPUT链后，任何进程都会收到它。本机上运行的程序可以发送数据包，这些数据包会经过OUTPUT链，然后到达POSTROUTING链输出。<br>   3）如果数据包是要转发出去的，且内核允许转发，数据包就会如图所示向右移动，经过FORWARD链，然后到达POSTROUTING链输出。</p>
<p><img src="https://images2015.cnblogs.com/blog/907596/201701/907596-20170109110506869-2063756658.png" alt="image"></p>
<p>从图中可将iptables数据包报文的处理过程分为三种类型：</p>
<h5 id="1）目的为本机的报文"><a href="#1）目的为本机的报文" class="headerlink" title="1）目的为本机的报文"></a>1）目的为本机的报文</h5><p>报文以本机为目的地址时，其经过iptables的过程为：</p>
<ul>
<li>1.数据包从network到网卡</li>
<li>2.网卡接收到数据包后，进入raw表的PREROUTING链。这个链的作用是在连接跟踪之前处理报文，能够设置一条连接不被连接跟踪处理。(注：不要在raw表上添加其他规则)</li>
<li>3.如果设置了连接跟踪，则在这条连接上处理。</li>
<li>4.经过raw处理后，进入mangle表的PREROUTING链。这个链主要是用来修改报文的TOS、TTL以及给报文设置特殊的MARK。(注：通常mangle表以给报文设置MARK为主，在这个表里面，千万不要做过滤&#x2F;NAT&#x2F;伪装这类的事情)</li>
<li>5.进入nat表的PREROUTING链。这个链主要用来处理 DNAT，应该避免在这条链里面做过滤，否则可能造成有些报文会漏掉。(注：它只用来完成源&#x2F;目的地址的转换)</li>
<li>6.进入路由决定数据包的处理。例如决定报文是上本机还是转发或者其他地方。(注：此处假设报文交给本机处理)</li>
<li>7.进入mangle表的 INPUT 链。在把报文实际送给本机前，路由之后，我们可以再次修改报文。</li>
<li>8.进入filter表的 INPUT 链。在这儿我们对所有送往本机的报文进行过滤，要注意所有收到的并且目的地址为本机的报文都会经过这个链，而不管哪个接口进来的或者它往哪儿去。</li>
<li><ol start="9">
<li>进过规则过滤，报文交由本地进程或者应用程序处理，例如服务器或者客户端程序。<h5 id="2）本地主机发出报文"><a href="#2）本地主机发出报文" class="headerlink" title="2）本地主机发出报文"></a>2）本地主机发出报文</h5>数据包由本机发出时，其经过iptables的过程为：</li>
</ol>
</li>
<li>1.本地进程或者应用程序（例如服务器或者客户端程序）发出数据包。</li>
<li>2.路由选择，用哪个源地址以及从哪个接口上出去，当然还有其他一些必要的信息。</li>
<li>3.进入raw表的OUTPUT链。这里是能够在连接跟踪生效前处理报文的点，在这可以标记某个连接不被连接跟踪处理。</li>
<li>4.连接跟踪对本地的数据包进行处理。</li>
<li>5.进入 mangle 表的 OUTPUT 链，在这里我们可以修改数据包，但不要做过滤(以避免副作用)。</li>
<li>6.进入 nat 表的 OUTPUT 链，可以对防火墙自己发出的数据做目的NAT(DNAT) 。</li>
<li>7.进入 filter 表的 OUTPUT 链，可以对本地出去的数据包进行过滤。</li>
<li>8.再次进行路由决定，因为前面的 mangle 和 nat 表可能修改了报文的路由信息。</li>
<li>9.进入 mangle 表的 POSTROUTING 链。这条链可能被两种报文遍历，一种是转发的报文，另外就是本机产生的报文。</li>
<li>10.进入 nat 表的 POSTROUTING 链。在这我们做源 NAT（SNAT），建议你不要在这做报文过滤，因为有副作用。即使你设置了默认策略，一些报文也有可能溜过去。</li>
<li>11.进入出去的网络接口。<h5 id="3）转发报文"><a href="#3）转发报文" class="headerlink" title="3）转发报文"></a>3）转发报文</h5>报文经过iptables进入转发的过程为：</li>
<li>1.数据包从network到网卡</li>
<li>2.网卡接收到数据包后，进入raw表的PREROUTING链。这个链的作用是在连接跟踪之前处理报文，能够设置一条连接不被连接跟踪处理。(注：不要在raw表上添加其他规则)</li>
<li>3.如果设置了连接跟踪，则在这条连接上处理。</li>
<li>4.经过raw处理后，进入mangle表的PREROUTING链。这个链主要是用来修改报文的TOS、TTL以及给报文设置特殊的MARK。(注：通常mangle表以给报文设置MARK为主，在这个表里面，千万不要做过滤&#x2F;NAT&#x2F;伪装这类的事情)</li>
<li>5.进入nat表的PREROUTING链。这个链主要用来处理 DNAT，应该避免在这条链里面做过滤，否则可能造成有些报文会漏掉。(注：它只用来完成源&#x2F;目的地址的转换)</li>
<li>6.进入路由决定数据包的处理。例如决定报文是上本机还是转发或者其他地方。(注：此处假设报文进行转发)</li>
<li>7.进入 mangle 表的 FORWARD 链，这里也比较特殊，这是在第一次路由决定之后，在进行最后的路由决定之前，我们仍然可以对数据包进行某些修改。</li>
<li>8.进入 filter 表的 FORWARD 链，在这里我们可以对所有转发的数据包进行过滤。需要注意的是：经过这里的数据包是转发的，方向是双向的。</li>
<li>9.进入 mangle 表的 POSTROUTING 链，到这里已经做完了所有的路由决定，但数据包仍然在本地主机，我们还可以进行某些修改。</li>
<li>10.进入 nat 表的 POSTROUTING 链，在这里一般都是用来做 SNAT ，不要在这里进行过滤。</li>
<li>11.进入出去的网络接口。</li>
</ul>
<hr>
<p>iptables规则设置用法</p>
<p>1）iptables的基本语法格式<br>iptables [-t 表名] 命令选项 ［链名］ ［条件匹配］ ［-j 目标动作或跳转］<br>说明：<br>表名、链名：用于指定iptables命令所操作的表和链；<br>命令选项：用于指定管理iptables规则的方式（比如：插入、增加、删除、查看等；<br>条件匹配：用于指定对符合什么样 条件的数据包进行处理；<br>目标动作或跳转：用于指定数据包的处理方式（比如允许通过、拒绝、丢弃、跳转（Jump）给其它链处理。</p>
<p>2）iptables命令的管理控制选项<br>-A 在指定链的末尾添加（append）一条新的规则<br>-D 删除（delete）指定链中的某一条规则，可以按规则序号和内容删除<br>-I 在指定链中插入（insert）一条新的规则，默认在第一行添加<br>-R 修改、替换（replace）指定链中的某一条规则，可以按规则序号和内容替换<br>-L 列出（list）指定链中所有的规则进行查看（默认是filter表，如果列出nat表的规则需要添加-t，即iptables -t nat -L）<br>-E 重命名用户定义的链，不改变链本身<br>-F 清空（flush）<br>-N 新建（new-chain）一条用户自己定义的规则链<br>-X 删除指定表中用户自定义的规则链（delete-chain）<br>-P 设置指定链的默认策略（policy）<br>-Z 将所有表的所有链的字节和数据包计数器清零<br>-n 使用数字形式（numeric）显示输出结果<br>-v 查看规则表详细信息（verbose）的信息<br>-V 查看版本(version)<br>-h 获取帮助（help）</p>
<p>3）防火墙处理数据包的四种方式ACCEPT 允许数据包通过<br>DROP 直接丢弃数据包，不给任何回应信息<br>REJECT 拒绝数据包通过，必要时会给数据发送端一个响应的信息。<br>LOG在&#x2F;var&#x2F;log&#x2F;messages文件中记录日志信息，然后将数据包传递给下一条规则</p>
<p>4）iptables防火墙规则的保存与恢复<br>iptables-save把规则保存到文件中，再由目录rc.d下的脚本（&#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;iptables）自动装载<br>使用命令iptables-save来保存规则。<br>一般用：<br>iptables-save &gt; &#x2F;etc&#x2F;sysconfig&#x2F;iptables<br>生成保存规则的文件&#x2F;etc&#x2F;sysconfig&#x2F;iptables，<br>也可以用：<br>service iptables save<br>它能把规则自动保存在&#x2F;etc&#x2F;sysconfig&#x2F;iptables中。<br>当计算机启动时，rc.d下的脚本将用命令iptables-restore调用这个文件，从而就自动恢复了规则。</p>
<p>5）iptables防火墙常用的策略梳理<br>设置默认链策略<br>ptables的filter表中有三种链：INPUT, FORWARD和OUTPUT。<br>默认的链策略是ACCEPT，可以将它们设置成DROP，如下命令就将所有包都拒绝了：<br>iptables -P INPUT DROP<br>iptables -P FORWARD DROP<br>iptables -P OUTPUT DROP</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cachefish.github.io/2022/03/07/19-Type-and-Point/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2229.jfif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="来世做春风，浪漫且自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cachecatのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/07/19-Type-and-Point/" class="post-title-link" itemprop="url">c++ 类型与指针</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-07 19:30:00 / 修改时间：10:13:50" itemprop="dateCreated datePublished" datetime="2022-03-07T19:30:00+08:00">2022-03-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-base/" itemprop="url" rel="index"><span itemprop="name">c++ base</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>对象、引用、函数(包括函数模板专门化)和表达式</p>
<h2 id="类型分类"><a href="#类型分类" class="headerlink" title="类型分类"></a>类型分类</h2><p>c++是一种强类型语言，也是一种静态类型语言;每个对象都有一个类型，这个类型永远不会改变。</p>
<h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>void (std::is_void)类型<br>std::nullptr_t(c++ 11) (std::is_null_pointer)</p>
<h3 id="算术类型-std-is-arithmetic"><a href="#算术类型-std-is-arithmetic" class="headerlink" title="算术类型(std:: is_arithmetic)"></a>算术类型(std:: is_arithmetic)</h3><ul>
<li><p>浮点类型(float, double, long      double以及它们的cv-qualified版本)(std::is_floating_point)</p>
</li>
<li><p>整型类型(包括cv-qualified的版本(std::is_integral)</p>
<ul>
<li>bool</li>
<li>字符类型:<ul>
<li>狭窄的性格类型:*<ul>
<li>普通字符类型(char, signed char, unsigned char)</li>
<li>char8_t类型(c++ 20)</li>
</ul>
</li>
<li>宽字符类型(char16_t(c++ 11)，char32_t（C++11），wchar_t）;有符号整型(short int, int, long int, long long int);无符号整型(Unsigned short int, Unsigned int, Unsigned long int, Unsigned long long int);</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><ul>
<li>引用类型(std:: is_reference):<ul>
<li><p>左值引用类型(std::is_lvalue_reference):</p>
<ul>
<li>左值引用作为对象类型</li>
<li>左值引用作为函数类型</li>
</ul>
</li>
<li><p>右值引用类型(std::is_rvalue_reference):</p>
<ul>
<li>右值引用作为对象类型</li>
<li>右值引用作为函数类型   </li>
<li></li>
</ul>
</li>
<li><p>指针类型(std::is_pointer)：</p>
<ul>
<li>指针作为对象类型</li>
<li>指针作为函数类型</li>
</ul>
</li>
<li><p>成员指针类型(std::is_member_pointer)</p>
<ul>
<li>pointer-to-data-member类型(std::is_member_object_pointer)* pointer-to-member-function类型(std::is_member_function_pointer)</li>
</ul>
</li>
<li><p>数组类型(std::is_array);</p>
</li>
<li><p>函数类型(std::is_function);</p>
</li>
<li><p>枚举类型(std::is_enum);</p>
</li>
<li><p>类类型:</p>
<ul>
<li>非联合体类型(std::is_class)</li>
<li>联合体类型(std::is_union)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Pointer"><a href="#Pointer" class="headerlink" title="Pointer"></a>Pointer</h2><p>Pointers to functions<br>指向函数的指针可以用非成员函数或静态成员函数的地址初始化。<br>由于函数到指针的隐式转换，address-of操作符是可选的:</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;        <span class="comment">// function type</span></span><br><span class="line"><span class="keyword">void</span> (*p1)(<span class="keyword">int</span>) = &amp;f;<span class="comment">//pointer-to-function type</span></span><br><span class="line"><span class="keyword">void</span> (*p2)(<span class="keyword">int</span>) = f; <span class="comment">// same as &amp;f</span></span><br></pre></td></tr></table></figure>

<p>与函数或对函数的引用不同，函数的指针是对象，因此可以存储在数组、复制、赋值等。</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void (a[10])(int); // Error:<span class="built_in"> array </span>of functions</span><br><span class="line">void (&amp;a[10])(int); // Error:<span class="built_in"> array </span>of references</span><br><span class="line">void (*a[10])(int); // OK:<span class="built_in"> array </span>of pointers to functions</span><br></pre></td></tr></table></figure>
<p>涉及到函数指针的声明通常可以用类型别名来简化:</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">using F = void(int);  // named type alias to simplify declarations</span><br><span class="line">F a[10];  // Error:<span class="built_in"> array </span>of functions</span><br><span class="line">F&amp; a[10]; // Error:<span class="built_in"> array </span>of references</span><br><span class="line">F* a[10]; // OK:<span class="built_in"> array </span>of pointers to functions</span><br></pre></td></tr></table></figure>
<p>解引用函数指针将产生标识被指向函数的左值:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">f</span>()</span>;</span><br><span class="line"><span class="built_in">int</span> (*p)() = f;  <span class="comment">// pointer p is pointing to f</span></span><br><span class="line"><span class="built_in">int</span> (&amp;r)() = *p; <span class="comment">// the lvalue that identifies f is bound to a reference</span></span><br><span class="line">r();           <span class="comment">// function f invoked through lvalue reference</span></span><br><span class="line">(*p)();        <span class="comment">// function f invoked through the function lvalue</span></span><br><span class="line">p();           <span class="comment">// function f invoked directly through the pointer</span></span><br></pre></td></tr></table></figure>

<h3 id="Pointers-to-data-members"><a href="#Pointers-to-data-members" class="headerlink" title="Pointers to data members"></a>Pointers to data members</h3><p>指向C类成员的非静态成员对象m的指针可以用表达式&amp;C::m进行精确初始化。像&amp;(C::m)或&amp;m这样的表达式在C的成员函数中不能形成指向成员的指针。</p>
<p>这样的指针可以用作指向成员的指针访问操作符的右操作数。<br>operator.* and operator-&gt;*: </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> &#123; <span class="type">int</span> m; &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> C::* p = &amp;C::m;      <span class="comment">// pointer to data member m of class C</span></span><br><span class="line">        C c = &#123;<span class="number">7</span>&#125;;</span><br><span class="line">        std::cout &lt;&lt; c.*p &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;  <span class="comment">// prints 7</span></span><br><span class="line">        C* cp = &amp;c;</span><br><span class="line">        cp-&gt;m = <span class="number">10</span>;</span><br><span class="line">        std::cout &lt;&lt; cp-&gt;*p &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// prints 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Pointers-to-member-functions"><a href="#Pointers-to-member-functions" class="headerlink" title="Pointers to member functions"></a>Pointers to member functions</h3><p>指向C类成员的非静态成员函数f的指针可以用表达式&amp;C::f精确地初始化。像&amp;(C::f)或&amp;f这样的表达式在C的成员函数中不能形成指向成员函数的指针</p>
<p>这样的指针可以用作指向成员的指针访问操作符的右操作数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span>&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; std::cout &lt;&lt; n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">// pointer to member function f of class C</span></span><br><span class="line">   <span class="built_in">void</span> (C::* p)(<span class="type">int</span>) = &amp;C::f;</span><br><span class="line">   C c;</span><br><span class="line">   (c.*p)(<span class="number">1</span>);                  <span class="comment">// prints 1</span></span><br><span class="line">   C* cp = &amp;c;</span><br><span class="line">   (cp-&gt;*p)(<span class="number">2</span>);                <span class="comment">// prints 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="静态与动态类型"><a href="#静态与动态类型" class="headerlink" title="静态与动态类型"></a>静态与动态类型</h2><p>静态类型<br>由程序编译时分析产生的表达式的类型称为表达式的静态类型。静态类型在程序执行时不会改变。</p>
<p>动态类型<br>如果某些glvalue表达式引用了一个多态对象，那么它最派生的对象的类型被称为动态类型</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> given</span><br><span class="line">struct B &#123; virtual ~B() &#123;&#125; &#125;; <span class="regexp">//</span> polymorphic type</span><br><span class="line">struct D: B &#123;&#125;; <span class="regexp">//</span> polymorphic type</span><br><span class="line">D d; <span class="regexp">//</span> most-derived object</span><br><span class="line">B* ptr = &amp;d;</span><br><span class="line"><span class="regexp">//</span> the static type of (*ptr) is B</span><br><span class="line"><span class="regexp">//</span> the dynamic type of (*ptr) is D</span><br></pre></td></tr></table></figure>

<h2 id="Typeid"><a href="#Typeid" class="headerlink" title="Typeid"></a>Typeid</h2><p>如果type是引用类型，则结果指向表示被引用类型的std::type_info对象。</p>
<h2 id="Type-traits"><a href="#Type-traits" class="headerlink" title="Type traits"></a>Type traits</h2><p>类型特征定义了一个基于编译时模板的接口，用于查询或修改类型的属性。</p>
<h4 id="算术类型-整型或浮点型"><a href="#算术类型-整型或浮点型" class="headerlink" title="算术类型:整型或浮点型"></a>算术类型:整型或浮点型</h4><h4 id="标量类型-算术、指针、成员指针、枚举或std-nullptr-t类型"><a href="#标量类型-算术、指针、成员指针、枚举或std-nullptr-t类型" class="headerlink" title="标量类型:算术、指针、成员指针、枚举或std::nullptr_t类型"></a>标量类型:算术、指针、成员指针、枚举或std::nullptr_t类型</h4><h4 id="不完整类型"><a href="#不完整类型" class="headerlink" title="不完整类型"></a>不完整类型</h4><ul>
<li>the type void(可能是cv限定的);</li>
<li>incompletely-defined对象类型<ul>
<li>已被指定(例如通过前向声明)但未定义的类类型;</li>
<li>未知界数组;</li>
<li>不完全类型的元素数组;</li>
<li>枚举类型，从声明点到确定其基础类型为止。<br>所有其他类型都是完整的。</li>
</ul>
</li>
</ul>
<h5 id="定义不完全的对象类型可以被补全"><a href="#定义不完全的对象类型可以被补全" class="headerlink" title="定义不完全的对象类型可以被补全:"></a>定义不完全的对象类型可以被补全:</h5><ul>
<li>一个类类型(例如类X)可能在一个翻译单元的某个点上是不完整的，然后在稍后完成;类型类X在这两点上是相同的类型:</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> X;             <span class="comment">// X is an incomplete type</span></span><br><span class="line"><span class="keyword">extern</span> X* xp;         <span class="comment">// xp is a pointer to an incomplete type</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span>()</span> &#123;</span><br><span class="line">  xp++;              <span class="comment">// ill-formed: X is incomplete</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> X &#123; <span class="built_in">int</span> i; &#125;;  <span class="comment">// now X is a complete type</span></span><br><span class="line">X x;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span>()</span> &#123;</span><br><span class="line">  xp = &amp;x;            <span class="comment">// OK: type is “pointer to X”</span></span><br><span class="line">  xp++;               <span class="comment">// OK: X is complete</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>每个实现对基本类型大小的选择统称为数据模型。<br>四种数据模型被广泛接受:</p>
<p>32位系统:</p>
<ul>
<li>LP32或2&#x2F;4&#x2F;4 (int是16位，long和pointer是32位</li>
<li>)Win16 API</li>
<li>ILP32或4&#x2F;4&#x2F;4 (int、long和pointer是32位的);</li>
<li>Win32API</li>
<li>接口Unix和类Unix系统(Linux, macOS)</li>
</ul>
<p>64位系统:</p>
<ul>
<li>LLP64或4&#x2F;4&#x2F;8 (int和long是32位的，指针是64位的)</li>
<li>Win64 </li>
<li>APILP64或4&#x2F;8&#x2F;8 (int是32位，long和指针是64位)</li>
<li>Unix和类Unix系统(Linux, macOS)</li>
</ul>
<p>其他模式非常罕见。例如，ILP64 (8&#x2F;8&#x2F;8: int、long和pointer都是64位的)只出现在一些早期的64位Unix系统中(例如:UNICOS on Cray)。</p>
<p>long 在不同平台大小不一样<br>建议使用cstdint头文件中的类型定义。</p>
<h2 id="void类型"><a href="#void类型" class="headerlink" title="void类型"></a>void类型</h2><p>Void类型具有一组空值的类型。它是一个不完整类型(因此，不允许使用void类型的对象)。这里没有void数组，也没有对void的引用。但是，允许指向void的指针和返回类型void的函数(其他语言中的过程)。</p>
<h3 id="Nullptr"><a href="#Nullptr" class="headerlink" title="Nullptr"></a>Nullptr</h3><p>Defined in header <cstddef><br>typedef decltype(nullptr) nullptr_t;        (since C++11) </p>
<p>Std::nullptr_t是空指针字面量nullptr的类型。它是一种独特的类型，本身不是指针类型或指向成员类型的指针。它的值是空指针常量，可以隐式转换为任何指针和指向成员类型的指针</p>
<p>sizeof(std::nullptr_t) is equal to sizeof(void *). </p>
<p>为什么要使用nullptr而不是NULL或0：<br>1.avoids overload resolution surprises</p>
<p>2.improve code clarity, especially when auto variables are involved。<br>3.template type deduction deduce</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cachefish.github.io/2022/03/07/12-%E4%BC%A0%E8%BE%93%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2229.jfif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="来世做春风，浪漫且自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cachecatのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/07/12-%E4%BC%A0%E8%BE%93%E5%B1%82/" class="post-title-link" itemprop="url">传输层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-07 19:30:00 / 修改时间：10:15:52" itemprop="dateCreated datePublished" datetime="2022-03-07T19:30:00+08:00">2022-03-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/base-network/" itemprop="url" rel="index"><span itemprop="name">base network</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>为上层提供了端到端的可靠的信息传递，传输层就是建立在应用间的端到端的连接，并且为数据传输提供可靠或不可靠的连接服务，</p>
<ol>
<li>连接管理:定义了两个用户像直接连接一样开始交谈的规则，通常把连接的定义和建立的过程成为握手，传输层要建立、维持和终止一个会话。传输层与其对等系统建立面向连接的会话。</li>
<li>流量控制:以网络普遍接受的速度发送数据，从而防止网络拥塞造成数据报的丢失，传输层定义了端到端用户之间的流量控制，数据链路层定义的是两个中心的相邻结点的数据控制。</li>
<li>差错控制: 数据链路层的差错检测功能提供了可靠的链路传输，但无法保证源点和目的之间的传输完全无错(比如网络中的路由器收到了完整无缺的IP分组，但在将含有分组的帧重新格式化的过程中出现了影响分组内容的错误)。传输层的差错检测机制会检测到这种类型的错误。</li>
<li>对用户请求响应:包括对发送和接收数据请求的响应，以及特定请求的响应，和用户可能要求高吞吐量、低延迟的可靠的服务。</li>
<li>建立无连接或面向连接的通信:TCP&#x2F;IP协议的TCP提供面向连接的传输层服务，UDP提供无连接的传输层服务。</li>
<li>传输层提供了应用进程之间的端到端连接，其作用是为网络应用程序提供接口。为端到端连接提供流量控制、差错控制、服务质量等管理服务。提供多路复用、多路分解机制。</li>
</ol>
<hr>
<p>传输层为相互通信的应用进程提供了逻辑通信（如下图），分段及封装应用层递来的数据。其主要目的：一是提供可靠（传输层要向会话层提供通信服务的可靠性，避免报文的出错、丢失、延迟时间紊乱、重复、乱序等差错）的端到端（即源主机端口到目的主机端口）通信；二是向应用层提供独立于网络的传输服务，换言之，传输层利用网络层提供的服务，并通过传输层地址提供给高层用户传输数据的通信端口，使系统间高层资源的共享不必考虑数据通信方面（数据链路层）和不可靠的数据传输方面（传输层）的问题。</p>
<p><img src="https://pics5.baidu.com/feed/a6efce1b9d16fdfa41b6496e47b2785295ee7b19.jpeg?token=dfc47de2316b9011838c9ee89247dd90" alt="image"></p>
<h2 id="面向连接和无连接"><a href="#面向连接和无连接" class="headerlink" title="面向连接和无连接"></a>面向连接和无连接</h2><h3 id="面向连接"><a href="#面向连接" class="headerlink" title="面向连接"></a>面向连接</h3><p>面向连接就是通信双方在通信时，要事先建立一条通信线路，然后进行通信。其过程分为三个阶段。第一阶段是建立连接。第二阶段是连接成功建立之后，进行数据传输。第三阶段是在数据传输完毕后，释放连接。</p>
<h3 id="无连接"><a href="#无连接" class="headerlink" title="无连接"></a>无连接</h3><p>无连接是指通信双方不需要事先建立通信线路，而是把每个带有目的地址的包（报文分组）发送到线路上，由系统选定路线进行传输，不需要目标方进行回复。</p>
<h3 id="端口和套接字"><a href="#端口和套接字" class="headerlink" title="端口和套接字"></a>端口和套接字</h3><p>为了区分同一个主机上不同应用程序的数据包，传输层提供了端口和套接字概念。下面介绍端口和套接字的作用。</p>
<h4 id="端口的作用"><a href="#端口的作用" class="headerlink" title="端口的作用"></a>端口的作用</h4><p>在数据链路层中，通过 MAC 地址来寻找局域网中的主机；在网际层中，通过 IP 地址来寻找网络中互连的主机或路由器。在传输层中，需要通过端口进行寻址，来识别同一计算机中同时通信的不同应用程序。</p>
<p>端口号用来识别应用程序。</p>
<h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>应用层通过传输层进行数据通信时，TCP 和 UDP 会遇到需要同时为多个应用程序进程提供并发服务的问题。</p>
<p>多个 TCP 连接或多个应用程序进程可能需要通过同一个 TCP 协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与 TCP／IP 协议交互提供了称为套接字（Socket）的接口，区分不同应用程序进程间的网络通信和连接。</p>
<p>套接字是由主机的 IP 地址加上主机上的端口号组成的地址。例如，套接字地址 101.102.103.104：21，表示指向 IP 地址为 101.102.103.104 的计算机的 21 端口。</p>
<h3 id="多路复用和多路分解"><a href="#多路复用和多路分解" class="headerlink" title="多路复用和多路分解"></a>多路复用和多路分解</h3><p>在网络上主机与主机之间的通信实质上是主机上运行的应用进程之间的通信。在进行通信时，往往同时运行多个应用程序。</p>
<p>为了能够让一个计算机同时支持多个网络程序，并且同时保持与多台计算机进行连接，就需要使用多路复用和多路分解，其含义如下：<br>多路复用：从源主机的不同套接字中收集数据块，并为每个数据块封装首部信息，从而生成报文段，然后将报文段传递到网络层中。<br>多路分解：将传输层报文段中的数据交付到正确的套接字。</p>
<h2 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h2><p>UDP 是一种无连接的，不可靠的传输层协议。在传送数据之前不需要建立连接，对方的传输层在收到 UDP 报文后，也不需要给出任何确认。<br>它只提供了传输层需要实现的最低限度的功能，除了复用&#x2F;分解功能和少量的差错检测外，它几乎没有对 IP 增加其他的东西。<br>UDP 协议适用于对 实时性要求高 的应用场景，因为它无连接，不需要反馈，所以简单，快捷</p>
<hr>
<h3 id="特点-UDP-："><a href="#特点-UDP-：" class="headerlink" title="特点(UDP)："></a>特点(UDP)：</h3><ol>
<li>无连接<br>使用 UDP 时，在发送报文段之前，通信双方没有握手的过程，因此 UDP 被称为是无连接的传输层协议。因为没有握手过程，相对于 TCP 来说，没有建立连接的时间消耗。</li>
<li>不可靠<br>UDP 提供尽力而为的交付服务，也就是说 UDP 协议不保证数据的可靠交付。</li>
<li>发送速率无限制<br>UDP 没有拥塞控制和流量控制的机制，所以 UDP 报文段的发送速率没有限制。</li>
<li>通信方式多样<br>因为一个 UDP 套接字只使用目的地址和目的端口来标识，所以 UDP 可以支持一对一、一对多、多对一和多对多的交互通信（收发不能同时，收了才能发，发了才能收）。</li>
<li>小<br>UDP 头部小，只有 8 个字节。</li>
</ol>
<h4 id="UDP-报文段结构"><a href="#UDP-报文段结构" class="headerlink" title="UDP 报文段结构"></a>UDP 报文段结构</h4><p>UDP 报文段由头部和应用数据组成。报文段头部包含四个字段，分别是源端口号、目的端口号、长度和检验和，每个字段的长度为两个字节（头部共 8 字节）。<br>长度字段指的是整个报文段的长度，包含了首部和应用数据的大小。<br>校验和是 UDP 提供的一种差错校验机制。<br>虽然提供了差错校验的机制，但是 UDP 对于差错的恢复无能为力。<br><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-16.png" alt="image"></p>
<h2 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h2><p>TCP 协议是面向连接的，提供可靠数据传输服务的传输层协议。</p>
<h3 id="特点-TCP-："><a href="#特点-TCP-：" class="headerlink" title="特点(TCP)："></a>特点(TCP)：</h3><ol>
<li>面向连接<br>TCP 协议是面向连接的，在通信双方进行通信前，需要通过三次握手建立连接。它需要在端系统中维护双方连接的状态信息。</li>
<li>可靠<br>TCP 协议通过序列号、确认号、定时重传、检验和等机制，来提供可靠的数据传输服务。</li>
<li>一对一<br>TCP 协议提供的是点对点的服务，即它是在单个发送方和单个接收方之间的连接。</li>
<li>全双工服务<br>TCP 协议提供的是全双工的服务，也就是说连接的双方的能够向对方发送和接收数据。</li>
<li>拥塞控制机制<br>TCP 提供了拥塞控制机制，在网络拥塞的时候会控制发送数据的速率，有助于减少数据包的丢失和减轻网络中的拥塞程度。</li>
<li>流量控制机制<br>TCP 提供了流量控制机制，保证了通信双方的发送和接收速率相同。如果接收方可接收的缓存很小时，发送方会降低发送速率，避免因为缓存填满而造成的数据包的丢失。</li>
</ol>
<h4 id="TCP-报文段结构"><a href="#TCP-报文段结构" class="headerlink" title="TCP 报文段结构"></a>TCP 报文段结构</h4><p>TCP 报文段由头部和数据组成，它的头部一般为 20 个字节。<br>源端口和目的端口号用于报文段的多路复用和分解。<br>32 比特的序列号和 32 比特的确认号，用于实现数据的可靠传输服务。<br>16 比特的接收窗口字段用于实现流量控制，该字段表示接收方愿意接收的字节的数量。<br>4 比特的头部长度字段，该字段指示了以 32 比特的字为单位的 TCP 头部的长度。<br>6 比特的标志字段，ACK 字段用于指示确认序列号的值是有效的。<br>RST、SYN 和 FIN 比特用于连接建立和拆除。<br>设置 PSH 字段指示接收方应该立即将数据交给上层。<br>URG 字段用来指示报文段里存在紧急的数据。<br>校验和提供了对数据的差错检测。<br><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-17.png" alt="image"></p>
<h3 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h3><hr>
<p>序列号 seq：占 4 个字节，用来标记数据段的顺序。<br>确认号 ack：占 4 个字节，期待收到对方下一个报文段的第一个数据字节的序号。<br>确认 ACK：占 1 位，仅当 ACK&#x3D;1 时，确认号字段才有效。ACK&#x3D;0 时，确认号无效<br>同步 SYN：连接建立时用于同步序号。当 SYN&#x3D;1，ACK&#x3D;0 时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得 SYN&#x3D;1，ACK&#x3D;1。因此，SYN&#x3D;1 表示这是一个连接请求，或连接接受报文。SYN 这个标志位只有在 TCP 建产连接时才会被置 1，握手完成后 SYN 标志位被置 0。<br>终止 FIN：用来释放一个连接。FIN&#x3D;1 表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接</p>
<hr>
<p>第一次握手：</p>
<p>客户端向服务端发送一个 SYN(seq&#x3D;x) 连接请求报文，并进入 SYN_SENT 状态 ，等待服务器确认。<br>SYN&#x3D;1，序列号 seq字段最开始是一个任选的随机数 x，它代表客户端数据的初始序列号。<br>第一次握手后，服务端知道了 自己可以与客户端连接成功，但此时客户端还不知道</p>
<p>第二次握手：</p>
<p>服务端收到 SYN 包，首先会为该连接分配 TCP 缓存和变量，然后返回 ACK(ack&#x3D;x+1)确认报文，同时自己也发送一个 SY(syn&#x3D;y)，即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态。</p>
<p>SYN&#x3D;1,ACK&#x3D;1，序列号字段是服务端产生的一个任选的随机数 y，它代表服务端数据的初始序列号。确认号字段为客户端发送的序列号+1。<br>第二次握手后，客户端收到了服务端的反馈，确定了自己可以于服务端连接成功</p>
<p>第三次握手</p>
<p>客户端收到服务器的 SYN+ACK 包，也会为这次 TCP 连接分配缓存和变量，然后向服务器发送确认包ACK(ack&#x3D;y+1)(seq&#x3D;x+1)，此包发送完毕，客户端和服务器进入ESTABLISHED（TCP 连接成功）状态，完成三次握手。</p>
<p>ACK&#x3D;1，序列号字段为客户端 x+1，确认号字段为服务端发送的序列号 y+1<br>第三次握手，防止失效的请求报文段被服务端接收</p>
<p>TCP 三次握手的建立连接的过程就是相互确认初始序列号的过程，告诉对方，什么样序列号的报文段能够被正确接收。<br>第三次握手的作用是客户端对服务端的初始序列号的确认。如果只使用两次握手，那么服务端就没有办法知道自己的序列号是否已被确认。同时这样也是为了防止失效的请求报文段被服务端接收，而出现错误的情况。<br>比如：</p>
<p>客户端发出去的第一个连接请求由于某些原因在网络节点中滞留了导致延迟，<br>直到连接释放的某个时间点才到达服务端，这是一个早已失效的报文，<br>但此时服务端仍然认为这是客户端的 第一次握手，于是服务端回应了客户端，第二次握手。</p>
<hr>
<h3 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h3><hr>
<p>因为 TCP 连接是全双工的，也就是说通信的双方都可以向对方发送和接收消息，所以断开连接需要双方的确认。</p>
<p>第一次挥手</p>
<p>客户端认为没有数据要再发送给服务端，它就向服务端发送一个 FIN 报文段，申请断开客户端到服务端的连接。<br>发送后客户端进入 FIN_WAIT_1 状态。<br>第二次挥手</p>
<p>服务端收到后，向客户端发送一个确认报文段ACK，表示已经接收到了客户端释放连接的请求，以后不再接收客户端发送过来的数据。但是因为连接是全双工的，所以此时，服务端还可以向客户端发送数据。<br>服务端进入 CLOSE_WAIT 状态。<br>客户端收到确认后，进入 FIN_WAIT_2 状态。<br>第三次挥手</p>
<p>服务端发送完所有数据后，向客户端发送 FIN ACK 报文段，申请断开服务端到客户端的连接。<br>发送后进入 LAST_ACK 状态。<br>第四次挥手</p>
<p>客户端接收到 FIN 请求后，向服务端发送一个确认报文段 ACK ，并进入 TIME_WAIT 阶段 。<br>服务端收到客户端的确认报文段后就立即进入 CLOSED 状态。<br>客户端 TIME_WAIT 阶段 会持续一段时间，这个时间为报文段在网络中的最大生存时间，如果该时间内服务端没有重发请求的话，客户端就进入 CLOSED 状态。如果收到服务端的重发请求就重新发送确认报文。<br>这样全双工的连接就被释放了。</p>
<p>TCP 使用四次挥手的原因是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代表不能再向对方发送数据，连接处于的是半释放的状态。</p>
<p>最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务端的确认报文段丢失或者出错，从而导致服务端不能正常关闭。</p>
<h2 id="ARP-协议"><a href="#ARP-协议" class="headerlink" title="ARP 协议"></a>ARP 协议</h2><p>ARQ 协议指的是自动重传请求，它通过超时和重传来保证数据的可靠交付，它是 TCP 协议实现可靠数据传输的一个很重要的机制。</p>
<p>它分为停止等待 ARQ 协议和连续 ARQ 协议。</p>
<h3 id="一、停止等待-ARQ-协议"><a href="#一、停止等待-ARQ-协议" class="headerlink" title="一、停止等待 ARQ 协议"></a>一、停止等待 ARQ 协议</h3><p>停止等待 ARQ 协议的基本原理是，对于发送方来说发送方每发送一个分组，就为这个分组设置一个定时器。当确认回答返回了，则清除定时器，发送下一个分组。如果在规定的时间内没有收到确认回答，则重新发送上一个分组。</p>
<p>对于接受方来说，每次接受到一个分组，就返回对这个分组的肯定应答，当收到重复的分组时，就直接丢弃，并重新返回 确认报文。当收到分组损坏的情况的时候，直接丢弃。</p>
<p>使用停止等待 ARQ 协议的缺点是每次发送分组必须等到分组确认后才能发送下一个分组，这样会造成信道的利用率过低。</p>
<hr>
<p>举例（发送方问题）</p>
<p>如果 A 发送的过程中出现差错，B 在接收 M1 时检测出了差错，就丢弃 M1，其他什么都不做（也不会通知 A 收到有差错的分组）。又或者 A 传送的过程中分组丢失了，以上这两种情况下，B 不会发送任何信息。<br>如果发生以上的情况，A 只要超过了一段时间仍然没有收到确认，就认为刚才发送的分组丢失了，所以它会重传刚刚的发送过的分组，也就是所谓的超时重传。<br>超时重传的原理：发送方发送完一个分组后，就会设置一个超时计时器，如果超时计时器到期之前没有收到接收方发来的确认信息，则会重发刚发送过的分组；如果收到确认信息，则撤销该超时计时器。</p>
<p>举例（接收方问题）</p>
<p>如果 A 发送了 M1 分组，到达 B，B 发送了 M1 确认信息，但由于网络原因，该确认信息丢失。那么这个时候，A 在超时重传时间内，没有收到 B 的确认信息，而且它并不知道是自己的分组有差错、丢失，还是 B 发生的确认丢失了。因此，A 会在超时重传过后，重传 M1 分组。<br>接收方 B 会采取这两个行动：<br>① B 会丢弃 M1 分组，不向上层交付。（B 之前已经收到过 M1 分组了）<br>② 向 A 发送确认（因为 A 重发了，肯定重传时间内没有收到确认信息）</p>
<hr>
<h3 id="二、连续-ARQ-协议"><a href="#二、连续-ARQ-协议" class="headerlink" title="二、连续 ARQ 协议"></a>二、连续 ARQ 协议</h3><p>连续 ARQ 协议是为了解决停止等待 ARQ 协议对于信道的利用率过低的问题。它通过连续发送一组分组，然后再等待对分组的确认回答，对于如何处理分组中可能出现的差错恢复情况，一般可以使用滑动窗口协议和选择重传协议来实现。</p>
<h4 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h4><p>在在发送方和接收方之间各自维持一个滑动窗口，发送发是发送窗口，接收方是接收窗口，而且这个窗口是随着时间变化可以向前滑动的。它允许发送方发送多个分组而不需等待确认。TCP 的滑动窗口是以字节为单位的。<br>连续 ARQ 协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。当发送方收到第一个分组的确认，就把发送窗口向前移动一个分组的位置。如果收到的是第 5 个分组的确认，那么移动到第六 6 个分组。</p>
<p>接收方一般都是采用累积确认的方式。也就是说接收方不必对收到的分组逐个发送确认。而是在收到几个分组后，对按序到达的最后一个分组发送确认。如果收到了这个分组确认信息，则表示到这个分组为止的所有分组都已经正确接收到了。</p>
<h4 id="累积确认"><a href="#累积确认" class="headerlink" title="累积确认"></a>累积确认</h4><p>优点是容易实现，即使确认丢失也不必重传。<br>缺点是，不能正确的向发送方反映出接收方已经正确收到的所以分组的信息。<br>比如发送方发送了前 5 个分组，而中间的第 3 个分组丢失了，这时候接收方只能对前 2 个发出确认。而不知道后面 3 个分组的下落，因此只能把后面的 3 个分组都重传一次，这种机制叫 Go-back-N（回退 N），表示需要再退回来重传已发送过的 N 个分组。</p>
<h3 id="选择重传协议"><a href="#选择重传协议" class="headerlink" title="选择重传协议"></a>选择重传协议</h3><p>接收端总会缓存所有收到的帧，当某个帧出现错误时，只会要求重传这一个帧，只有当某个序号后的所有帧都正确收到后，才会一起提交给高层应用。重传协议的缺点在于接受端需要更多的缓存。<br>TCP 的可靠运输机制<br>TCP 的可靠运输机制是基于连续 ARQ 协议和滑动窗口协议的。</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">已经发送并确认 |<span class="string">============= 发送窗口 ===========</span>|<span class="string"> 缓存中还不允许发送的 </span>|</span><br><span class="line">============= |<span class="string">已经发送但未确认 </span>|<span class="string"> 允许发送但还未发送</span>|<span class="string"> ===================</span>|</span><br></pre></td></tr></table></figure>
<p>TCP 协议在发送方维持了一个发送窗口，发送窗口以前的报文段是已经发送并确认了的报文段，发送窗口中包含了已经发送但未确认的报文段和允许发送但还未发送的报文段，发送窗口以后的报文段是缓存中还不允许发送的报文段。当发送方向接收方发送报文时，会依次发送窗口内的所有报文段，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的报文段。</p>
<p>&#x3D;&#x3D;TCP 协议的可靠传输机制更像是窗口滑动协议和选择重传协议的一个混合体。&#x3D;&#x3D;</p>
<h3 id="TCP-的流量控制机制"><a href="#TCP-的流量控制机制" class="headerlink" title="TCP 的流量控制机制"></a>TCP 的流量控制机制</h3><p>TCP 提供了流量控制的服务，这个服务的主要目的是控制发送方的发送速率，保证接收方来得及接收。因为一旦发送的速率大于接收方所能接收的速率，就会造成报文段的丢失。接收方主要是通过接收窗口来告诉发送方自己所能接收的大小，发送方根据接收方的接收窗口的大小来调整发送窗口的大小，以此来达到控制发送速率的目的。</p>
<h3 id="TCP-的拥塞控制机制"><a href="#TCP-的拥塞控制机制" class="headerlink" title="TCP 的拥塞控制机制"></a>TCP 的拥塞控制机制</h3><p>TCP 的拥塞控制主要是根据网络中的拥塞情况来控制发送方数据的发送速率，如果网络处于拥塞的状态，发送方就减小发送的速率，这样一方面是为了避免继续增加网络中的拥塞程度，另一方面也是为了避免网络拥塞可能造成的报文段丢失。</p>
<p>TCP 的拥塞控制主要使用了四个机制，分别是&#x3D;&#x3D;慢启动、拥塞避免、快速重传和快速恢复。&#x3D;&#x3D;</p>
<p>慢启动的基本思想是，因为在发送方刚开始发送数据的时候，并不知道网络中的拥塞程度，所以先以较低的速率发送，进行试探，每次收到一个确认报文，就将发送窗口的长度加一，这样每个 RTT 时间后，发送窗口的长度就会加倍。当发送窗口的大小达到一个阈值的时候就进入拥塞避免算法。</p>
<p>拥塞避免算法是为了避免可能发生的拥塞，将发送窗口的大小由每过一个 RTT 增长一倍，变为每过一个 RTT ，长度只加一。这样将窗口的增长速率由指数增长，变为加法线性增长。</p>
<p>快速重传指的是，当发送方收到三个冗余的确认应答时，因为 TCP 使用的是累计确认的机制，所以很有可能是发生了报文段的丢失，因此采用立即重传的机制，在定时器结束前发送所有已发送但还未接收到确认应答的报文段。</p>
<p>快速恢复是对快速重传的后续处理，因为网络中可能已经出现了拥塞情况，所以会将慢启动的阀值减小为原来的一半，然后将拥塞窗口的值置为减半后的阀值，然后开始执行拥塞避免算法，使得拥塞窗口缓慢地加性增大。简单来理解就是，乘性减，加性增。</p>
<p>TCP 认为&#x3D;&#x3D;网络拥塞的主要依据是报文段的重传次数，它会根据网络中的拥塞程度，通过调整慢启动的阀值，然后交替使用上面四种机制来达到拥塞控制的目的。&#x3D;&#x3D;</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cachefish.github.io/2022/03/07/13-%E5%A0%86%E7%A0%B4%E5%9D%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2229.jfif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="来世做春风，浪漫且自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cachecatのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/07/13-%E5%A0%86%E7%A0%B4%E5%9D%8F/" class="post-title-link" itemprop="url">c++ 堆破坏</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-07 19:30:00 / 修改时间：10:13:19" itemprop="dateCreated datePublished" datetime="2022-03-07T19:30:00+08:00">2022-03-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-base/" itemprop="url" rel="index"><span itemprop="name">c++ base</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="堆破坏原因"><a href="#堆破坏原因" class="headerlink" title="堆破坏原因"></a>堆破坏原因</h2><ol>
<li>缓冲区溢出(写入超出分配的内存)</li>
<li>Double free(将指针释放两次)</li>
<li>旧指针重用(在释放后重用指针)。</li>
</ol>
<p>对堆损坏进行故障排除的困难在于，例如，当线程损坏堆时，进程不会终止或抛出错误！只要不使用损坏的堆，进程就不会崩溃，但一旦线程尝试使用堆中损坏的内存块，进程就会崩溃！进程崩溃时我们所看到的导致崩溃的“罪魁祸首”线程实际上只是一个受害者线程！比如如果你new一个大小正常的内存失败，除非系统内存用完，否则一定是出现了堆破坏。<br>备注：<br>同一个进程的所有内存都是在同一个虚拟地址空间的，理论上任何存储期的变量的越界写都会对其它地址上的数据造成破坏，这些被破坏的数据可能是任何存储期的变量或程序内部数据结构（管理堆的元数据，调用栈的返回地址等）。</p>
<hr>
<h3 id="堆的结构"><a href="#堆的结构" class="headerlink" title="堆的结构"></a>堆的结构</h3><p>参考<a target="_blank" rel="noopener" href="https://os.51cto.com/art/202107/675085.htm%E3%80%82">https://os.51cto.com/art/202107/675085.htm。</a><br>以windows下的heap为例，linux下也是类似。<br>Windows Heap概述</p>
<ul>
<li>进程默认堆。每个进程启动的时候系统会创建一个默认堆。比如LocalAlloc或者GlobalAlloc也是从进程默认堆上分配内存。你也可以使用GetProcessHeap获取进程默认堆的句柄，然后根据用这个句柄去调用HeapAlloc达到在系统默认堆上分配内存的效果。</li>
<li>自建堆。这个泛指程序通过HeapCreate去创建的堆，然后利用HeapAlloc等API去操作堆。</li>
<li>C++编程中常用的是malloc和new去申请内存，这些由CRT库提供方法。而根据查看在VS2010之前(包含)，CRT库会使用HeapCreate去创建一个堆，供CRT库自己使用。在VS2015以后CRT库的实现，并不会再去创建一个单独的堆，而使用进程默认堆。<br>堆管理器是通过调用虚拟管理器的一些方法进行堆管理的实现，比如VirtualAlloc之类的函数。同样应用程序也可以直接使用VirtualAlloc之类的函数对内存进行使用。</li>
</ul>
<p>一个堆主要由若干个Segment(段)组成，每个Segment都是一段连续的空间，然后用双向链表串起来。而一般情况下，一开始只有一个Segment，然后在这个Segment上申请空间，叫做Heap Entry(堆块)。</p>
<p>应用程序申请的内存在Segment上叫做Entry(块)，他们是连续的，可以看到一个块一般具有：<br>·前置的元数据: 这里主要存储有当前块的大小，前一个块的大小，当前块的状态等。<br>·用户数据区: 这段内存才是用户申请并且使用的内存。当然这块数据可能比你申请的内存要大一些，因为32位下面最小的分配粒度是8字节。这也是为什么有时候程序有时候溢出了几个字符，好像也没有导致程序异常或者崩溃的原因。<br>·后置的元数据: 这个一般用于调试所用。一般发布的时候不会占用这块空间。</p>
<p>如果程序写的数据越界了，修改了元数据区域，会导致后续的分配或则释放内存出现崩溃；如果错误修改了用户数据，则访问这些数据的代码就会出错。由于崩溃在于受害者一方，所以我们需要借助工具在第一现场抓住破坏者。</p>
<h3 id="AddressSanitizer"><a href="#AddressSanitizer" class="headerlink" title="AddressSanitizer"></a>AddressSanitizer</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><strong>shadow bytes</strong><br>用1字节的shadow byte来描述 8字节的内存的可访问情况：<br>(1)0 表示所有8字节可以访问。<br>(2)1-7表示1-7字节可以访问<br>(3)负数是asan运行时用于汇报诊断信息的上下文，并且也表示所有字节都不能访问。</p>
<figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Shadow byte legend (one shadow byte represents 8 application bytes)</span><span class="punctuation">:</span></span><br><span class="line"> <span class="attribute">Addressable</span><span class="punctuation">:</span> <span class="string">00</span></span><br><span class="line"> <span class="attribute">Partially addressable</span><span class="punctuation">:</span> <span class="string">01 02 03 04 05 06 07 </span></span><br><span class="line"> <span class="attribute">Heap left redzone</span><span class="punctuation">:</span> <span class="string">     fa</span></span><br><span class="line"> <span class="attribute">Freed heap region</span><span class="punctuation">:</span> <span class="string">     fd</span></span><br><span class="line"> <span class="attribute">Stack left redzone</span><span class="punctuation">:</span> <span class="string">     f1</span></span><br><span class="line"> <span class="attribute">Stack mid redzone</span><span class="punctuation">:</span> <span class="string">     f2</span></span><br><span class="line"> <span class="attribute">Stack right redzone</span><span class="punctuation">:</span> <span class="string">    f3</span></span><br><span class="line"> <span class="attribute">Stack after return</span><span class="punctuation">:</span> <span class="string">      f5</span></span><br><span class="line"> <span class="attribute">Stack use after scope</span><span class="punctuation">:</span> <span class="string">   f8</span></span><br><span class="line"> <span class="attribute">Global redzone</span><span class="punctuation">:</span> <span class="string">        f9</span></span><br><span class="line"> <span class="attribute">Global init order</span><span class="punctuation">:</span> <span class="string">       f6</span></span><br><span class="line"> <span class="attribute">Poisoned by user</span><span class="punctuation">:</span> <span class="string">      f7</span></span><br><span class="line"> <span class="attribute">Container overflow</span><span class="punctuation">:</span> <span class="string">    fc</span></span><br><span class="line"> <span class="attribute">Array cookie</span><span class="punctuation">:</span> <span class="string">          ac</span></span><br><span class="line"> <span class="attribute">Intra object redzone</span><span class="punctuation">:</span> <span class="string">   bb</span></span><br><span class="line"> <span class="attribute">ASan internal</span><span class="punctuation">:</span> <span class="string">          fe</span></span><br><span class="line"> <span class="attribute">Left alloca redzone</span><span class="punctuation">:</span> <span class="string">    ca</span></span><br><span class="line"> <span class="attribute">Right alloca redzone</span><span class="punctuation">:</span> <span class="string">   cb</span></span><br><span class="line"> <span class="attribute">Shadow gap</span><span class="punctuation">:</span> <span class="string">           cc</span></span><br></pre></td></tr></table></figure>
<h4 id="用户地址和对应的shadow-bytes的映射关系"><a href="#用户地址和对应的shadow-bytes的映射关系" class="headerlink" title="用户地址和对应的shadow bytes的映射关系"></a>用户地址和对应的shadow bytes的映射关系</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">On</span> x86:</span><br><span class="line"><span class="type">char</span> shadow_byte_value = *((Your_Address &gt;&gt; <span class="number">3</span>) + <span class="number">0x30000000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">On</span> x64:</span><br><span class="line"><span class="type">char</span> shadow_byte_value = *((Your_Address &gt;&gt; <span class="number">3</span>) + _asan_runtime_assigned_offset)</span><br></pre></td></tr></table></figure>
<h4 id="红色区域-red-zone"><a href="#红色区域-red-zone" class="headerlink" title="红色区域(red zone)"></a>红色区域(red zone)</h4><p>红色区域表示不可以访问的内存，对应的shadow bytes为负数，用于检测非法访问。<br>●动态存储期变量：运行时库替换malloc和free函数，用替换后的malloc分配的内存会在返回给用户的内存前后都添加红色区域(red zones)。替换后的free释放内存时，并没有直接释放内存，而是将这些内存的shadows bytes都设置为负数，并且将这些内存放入隔离区延迟释放，这样就能检测访问销毁内存的代码了。<br>●自动存储期&#x2F;全局存储期&#x2F;线程存储变量：编译器会在这些变量的前后也安插上红色区域。</p>
<h4 id="检测代码"><a href="#检测代码" class="headerlink" title="检测代码"></a>检测代码</h4><p>使用asan编译的代码，当去读写一个内存时，编译器都产生了一些额外代码来做检测。<br>当访问8个字节时，伪代码如下：<br>ShadowAddr &#x3D; (Addr &gt;&gt; 3) + Offset;<br>if (*ShadowAddr !&#x3D; 0) {<br>ReportAndCrash(Addr);<br>}<br>当访问的字节数少于8时，伪代码如下（This is guaranteed by the fact that malloc returns 8-byte aligned chunks of memory）：<br>ShadowAddr &#x3D; (Addr &gt;&gt; 3) + Offset;<br>k &#x3D; *ShadowAddr;<br>if (k !&#x3D; 0 &amp;&amp; ((Addr &amp; 7) + AccessSize &gt; k)) {<br>    ReportAndCrash(Addr);<br>}</p>
<h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>sudo dnf install libasan</p>
<h4 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h4><p>使用&#x2F;fsanitize&#x3D;address编译选项编译可执行程序，动态库或静态库。正常运行程序，运行时检测到错误就会报告。错误信息可以在调试器或者控制台下展示，也可以存储到dump中用于事后分析。&#x2F;fsanitize&#x3D;address和所有优化级别兼容(例如，&#x2F;Od, &#x2F;O1, &#x2F;O2, &#x2F;O2 &#x2F;GL, and PGO)。</p>
<p>设置环境变量ASAN_SAVE_DUMPS&#x3D;as.dmp 再运行程序就会生成dump.<br>打开dump后也会看到和直接运行相同的诊断信息。</p>
<hr>
<h3 id="Linux-1"><a href="#Linux-1" class="headerlink" title="Linux"></a>Linux</h3><p>需要检测的模块(动态库,静态库,可执行程序）编译时加上编译选项-fsanitize&#x3D;address，<br>如果运行程序出现了如下提示” ASan runtime does not come first in initial library list; you should either link runtime to your application or manually preload it with LD_PRELOAD”，表明该可执行程序没有首先链接asan运行时,或没有通过LD_PRELOAD手动加载asan运行时。 </p>
<ul>
<li>首先链接asan运行时是指需要将libasan.so放在可执行程序需要链接的库的列表的第一项。（也就是放在最左边）。<br>比如链接选项如下需要将-lasan放在最左边</li>
</ul>
<p>-lasan -ltbb -lgtest -lconcurrencpp -lpthread -ldl</p>
<ul>
<li>通过LD_PRELOAD手动加载asan运行时是指按如下方式运行程序<br>LD_PRELOAD&#x3D;&#x2F;usr&#x2F;lib64&#x2F;libasan.so.6  your_exe</li>
</ul>
<p><strong>执行rpm -ql libasan 可显示libasan安装的位置</strong><br>[leo@x x86_64r]$ rpm -ql libasan<br>&#x2F;usr&#x2F;lib&#x2F;.build-id<br>&#x2F;usr&#x2F;lib&#x2F;.build-id&#x2F;6d&#x2F;582957f402989d215d83f393d10e2e06ab4eff<br>&#x2F;usr&#x2F;lib64&#x2F;libasan.so.6<br>&#x2F;usr&#x2F;lib64&#x2F;libasan.so.6.0.0</p>
<p><strong>产生dump</strong><br>在系统中开启core： ulimit -c unlimited<br>cat &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;core_pattern 查看core生成的位置<br>设置环境变量<br>export ASAN_OPTIONS&#x3D;abort_on_error&#x3D;1:disable_coredump&#x3D;0:unmap_shadow_on_exit&#x3D;1<br>然后运行程序</p>
<h4 id="可执行程序是否必须设置-fsanitize-x3D-address？"><a href="#可执行程序是否必须设置-fsanitize-x3D-address？" class="headerlink" title="可执行程序是否必须设置-fsanitize&#x3D;address？"></a>可执行程序是否必须设置-fsanitize&#x3D;address？</h4><p>下面罗列了待测试的静态库或动态库都设置了-fsanitize&#x3D;address，可执行程序不设置的情况下是否可以检测出内存问题：<br>●vs2019<br>◇运行时加载dll：可以。<br>◇编译时链接dll：可以。<br>◇静态库: 不可以。如果可执行程序如果设置了-fsanitize&#x3D;address，也是可以检测的。<br>●g++ 11<br>◇运行时加载dll：可执行程序可以不指定-fsanitize&#x3D;address，但必须满足”ASan runtime must come first in initial library list; you should either link runtime to your application or manually preload it with LD_PRELOAD”。<br>◇编译时链接dll：同上。<br>◇静态库：可执行程序可以不指定-fsanitize&#x3D;address，但必须首先链接libasan,否则链接错误。<br>在有条件的情况下，建议所有模块都设置-fsanitize&#x3D;address，包括可执行程序。</p>
<p>检测的错误示例<br>加了-fsanitize&#x3D;address编译选项，vs2019,g++11默认都是可以检测内存泄露问题的</p>
<p><strong>heap-buffer-overflow</strong></p>
<ul>
<li>数组下标越界<ul>
<li>往前越界</li>
</ul>
</li>
<li>strncat越界<ul>
<li>错误原因：strncat一定会在目标结尾加0</li>
</ul>
</li>
<li>strncpy越界<ul>
<li>错误原因：dest未以0结尾，strncpy读取越界。</li>
</ul>
</li>
</ul>
<p><strong>heap-use-after-free</strong><br><strong>double-free</strong><br><strong>alloc-dealloc-mismatch</strong><br>alloc&#x2F;dealloc mismatch 检测在windows下默认关闭的，linux下默认开启的。windows下需要设置环境变量ASAN_OPTIONS&#x3D;alloc_dealloc_mismatch&#x3D;1来开启。<br>在控制台执行set ASAN_OPTIONS&#x3D;alloc_dealloc_mismatch&#x3D;1 </p>
<p><strong>new-delete-type-mismatch</strong><br>当释放的指针为基类类型，但基类没有虚析构，就会提示这个错误。<br>这种情况不会调用子类的析构，从而也不会调用子类数据成员的析构，造成内存泄露。如果子类自己和其数据成员都不需要通过析构函数执行内存回收，是不会造成内存泄露的。</p>
<p><strong>stack-buffer-overflow</strong><br>和堆溢出的例子类似，只是变量是在栈上分配的。<br><strong>stack-buffer-underflow</strong><br>访问了栈变量之前的错误内存地址。</p>
<p><strong>stack-use-after-return</strong><br>vs2019:<br>默认关闭，需要设置编译选项&#x2F;fsanitize-address-use-after-return打开, 运行时需要设置环境变量 ASAN_OPTIONS&#x3D;detect_stack_use_after_return&#x3D;1.（ msdn上说只要编译时打开了，即使运行时没有设置环境变量，产生的代码都会变慢。）<br>gcc11<br>编译时默认打开，运行时需要设置环境变量 ASAN_OPTIONS&#x3D;detect_stack_use_after_return&#x3D;1。</p>
<p><strong>stack-use-after-scope</strong></p>
<p><strong>global-buffer-overflow</strong></p>
<p><strong>memcpy-param-overlap</strong><br>Memcpy不支持重叠内存。memcpy的另一个支持重叠内存的替代方案:memmove</p>
<p><strong>strncat-param-overlap</strong><br>strcat， strncat也不支持源和目标重叠。</p>
<h3 id="协程的栈变量"><a href="#协程的栈变量" class="headerlink" title="协程的栈变量"></a>协程的栈变量</h3><p>栈变量越界访问在g++11和 vc2019下无法检测，不过堆越界可以检测。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">co::result&lt;<span class="type">void</span>&gt; <span class="title">co_fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> v[<span class="number">3</span>];</span><br><span class="line">     v[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">     co::result_promise&lt;<span class="type">int</span>&gt; promise;</span><br><span class="line">     <span class="keyword">auto</span> result = promise.<span class="built_in">get_result</span>();</span><br><span class="line">     std::cout &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">     <span class="function">thread <span class="title">t</span><span class="params">([p = move(promise)]()<span class="keyword">mutable</span>&#123;p.set_result(<span class="number">1</span>);&#125;)</span></span>;</span><br><span class="line">     <span class="keyword">co_await</span> result;</span><br><span class="line">     std::cout &lt;&lt; endl &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">     <span class="type">int</span> v2[<span class="number">3</span>];</span><br><span class="line">     v2[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">     <span class="built_in">fun_s_1</span>(<span class="string">&quot;co_fun&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="避免内存错误的防御式编程"><a href="#避免内存错误的防御式编程" class="headerlink" title="避免内存错误的防御式编程"></a>避免内存错误的防御式编程</h3><p><strong>典型错误原因：</strong></p>
<ol>
<li>数组越界</li>
<li>字符串0结尾问题(1.字符串未以0结尾，2.把非字符串当作字符串进行操作）</li>
<li>内存忘记释放</li>
<li>内存多次释放</li>
<li>memcpy, strcat, strcpy等函数的误用</li>
<li>基类未写虚析构，导致内存泄露 （基类都写上虚析构）</li>
<li>返回了销毁栈变量的地址或引用(相信理解了栈变量的生命期就不会这样写了)</li>
</ol>
<p><strong>数组越界问题</strong></p>
<ol>
<li>使用下标访问数组前一定检测下标范围是否越界。</li>
<li>循环时注意边界<br> const int num &#x3D; 3;<br> int a[num]{};<br> for (size_t i &#x3D; 0; i &lt;&#x3D; num; i++){ &#x2F;&#x2F; 应当 i &lt; num<br>  a[i] &#x3D; i + 2;<br> }</li>
<li>使用std::array和std::vector<br>std::array 替代编译期已知大小数组<br>std::vector替代运行时指定大小的数组<br>&#x3D;&#x3D;■std::array&#x3D;&#x3D;<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::array&lt;<span class="type">char</span>, 6&gt; data = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">    data.<span class="built_in">at</span>(<span class="number">1</span>) = <span class="number">88</span>;<span class="comment">// Set element 1</span></span><br><span class="line">    <span class="comment">// Read element 2</span></span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;index 2 has value &quot;</span> &lt;&lt; data.<span class="built_in">at</span>(<span class="number">2</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;data size = &quot;</span> &lt;&lt; data.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Set element 6</span></span><br><span class="line">        data.<span class="built_in">at</span>(<span class="number">6</span>) = <span class="number">666</span>;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::out_of_range <span class="type">const</span>&amp; exc) &#123;</span><br><span class="line">        std::cout &lt;&lt; exc.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Print final values</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;data:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> elem : data) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; elem;</span><br><span class="line">    &#125;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> data2[<span class="number">6</span>];</span><br><span class="line"><span class="type">int</span> len = std::<span class="built_in">min</span>(data.<span class="built_in">size</span>(), <span class="built_in">sizeof</span>(data2));</span><br><span class="line"><span class="built_in">memcpy</span>(data2, data.<span class="built_in">data</span>(), len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这个容器是一个聚合类型，它的语义与一个结构体相同，该结构体将c风格数组T[N]作为其唯一的非静态数据成员。与c风格的数组不同，它不会自动衰减为T*。作为一个聚合类型，它可以通过给定的最多N个初始化式进行初始化，这些初始化式可以转换为T: std::array&lt;<span class="type">int</span>, 3&gt; a =&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;。</span><br><span class="line">该结构结合了c风格数组的性能和可访问性，以及标准容器的优点，例如知道自己的大小、支持赋值、随机访问迭代器等。</span><br></pre></td></tr></table></figure>
■&#x3D;&#x3D;vector&#x3D;&#x3D;<br>用vector<T> 来达到 new T[n]的效果, 需要使用如下构造函数。<br>constexpr explicit vector( size_type count, const Allocator&amp; alloc &#x3D; Allocator() );</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">d1</span><span class="params">(num)</span></span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : d1)&#123;</span><br><span class="line">        e = i++ + <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// Set element 6</span></span><br><span class="line">        d1.<span class="built_in">at</span>(num) = <span class="number">666</span>;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::out_of_range <span class="type">const</span>&amp; exc)&#123;</span><br><span class="line">        std::cout &lt;&lt; exc.<span class="built_in">what</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> e : d1)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; e;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">d2</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> len = std::<span class="built_in">min</span>(d2.<span class="built_in">size</span>(), d1.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">memcpy</span>(d2.<span class="built_in">data</span>(), d1.<span class="built_in">data</span>(), len));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不使用C风格字符串及相关C函数，使用std::string -&gt; 避免问题2<br>如果使用std::string就不用考虑这些问题<br>std::string msg1(“hello string”);<br>std::string msg2 &#x3D; msg1;<br>std::string msg3 &#x3D; msg2;<br>备注：如果非要使用c字符串，请始终确保都以0结尾。<br>不使用裸指针，使用智能指针-&gt;避免问题3,4</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> data1 = make_shared&lt;array&lt;<span class="type">char</span>, <span class="number">100</span>&gt;&gt;(); <span class="comment">//需要传递到其它地方</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> e : *data1)&#123;</span><br><span class="line">        std::cout &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">auto</span> data2 = make_unique&lt;vector&lt;<span class="type">char</span>&gt;&gt;(<span class="number">100</span>);<span class="comment">//自己使用</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> e : *data2)&#123;</span><br><span class="line">        std::cout &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#x3D;&#x3D;memcpy, strcat, strcpy等函数的误用&#x3D;&#x3D;<br>● void *memcpy(void *dest, const void *src, size_t n)<br>1.注意源和目标不能重叠，如果为同一个请用memmove.<br>2.注意源和目标长度都要大于等于n. </p>
<p>● char * strcat(char *dest, const char *src) (不建议使用）<br>1.注意源和目标不能重叠。<br>2.源必须要以0结尾，否则会访问越界<br>3.总会给目标加上结尾的0,所以要确保目标不小于strlen(dest)+strlen(src)+1</p>
<p>● char * strncat(char *dest, const char *src, size_t n);<br>1.注意源和目标不能为同一个buffer<br>2.如果源长度大于等于n,可以不以0结尾，否则必须以0结尾不然会访问越界。<br>4.总会给目标加上结尾的0,所以要确保目标不小于strlen(dest)+n+1</p>
<p>● char *strcpy(char *dest, const char *src);(不建议使用）<br>1.注意源和目标不能重叠<br>2.源必须以0结尾，否则会访问越界<br>3.目标长度必须大于等于strlen(src)+1</p>
<p>● char *strncpy(char *dest, const char *src, size_t n);<br>1.注意源和目标不能重叠<br>2.如果源的长度大于等于n，那么最终的dest将不会以0结尾。<br> char src[] &#x3D; “hello”;<br> char dest[3];<br> strncpy(dest, src, 3); &#x2F;&#x2F;dest[2]为l，非0<br>3.如果源的长度小于n，源必须以0结尾，否则源会访问越界，并且目标会被写入额外的多个0补足到n个字节。<br>char src[] &#x3D; “hello”;<br> char dest[10];<br> strncpy(dest, src, 10); &#x2F;&#x2F;dest[5] 到 dest[9]都为0<br>4.目标长度不能小于n。<br>所以为了保证dest一定以0结尾，通常按照如下方式编码：<br>strncpy(dest, str, dest_len - 1);<br>dest[dest_len - 1] &#x3D; 0;</p>
<p>● int snprintf(char *str, size_t size, const char *format, …);<br>The functions snprintf() write at most size bytes (including the terminating null byte (‘\0’)) to str.<br>snprintf总会给目标buffer加上结尾的0的，如下代码b[2]为0.</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">char</span> b[<span class="number">3</span>];</span><br><span class="line"><span class="attribute">snprintf</span>(b, <span class="number">3</span>, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>&#x3D;&#x3D;总结，字符串c函数一定要明确对结尾0的处理方式，每个函数都不一样， 使用前应当详细阅读函数的使用说明。&#x3D;&#x3D;<br>检测工具对比<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/jinzhuojun/article/details/46659155">https://blog.csdn.net/jinzhuojun/article/details/46659155</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt=""
      src="/images/2229.jfif">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description">来世做春风，浪漫且自由</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/cachefish" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cachefish" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/cachefish@163g.com" title="E-Mail → cachefish@163g.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cachecat</span>
</div>
<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"left","width":240,"height":360},"mobile":{"show":false},"react":{"opacityDefault":1,"opacityOnHover":1},"log":false,"tagMode":false});</script></body>
</html>
