<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cachefish.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="来世做春风，浪漫且自由">
<meta property="og:type" content="website">
<meta property="og:title" content="cachecatのBlog">
<meta property="og:url" content="https://cachefish.github.io/index.html">
<meta property="og:site_name" content="cachecatのBlog">
<meta property="og:description" content="来世做春风，浪漫且自由">
<meta property="og:locale" content="zh_CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://cachefish.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>cachecatのBlog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">cachecatのBlog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">localhost</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cachefish.github.io/2022/03/07/16-c-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="来世做春风，浪漫且自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cachecatのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/07/16-c-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">c++ 基本概念</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-07 19:30:00 / 修改时间：10:13:35" itemprop="dateCreated datePublished" datetime="2022-03-07T19:30:00+08:00">2022-03-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-base/" itemprop="url" rel="index"><span itemprop="name">c++ base</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>1.变量占用存储空间么？<br>2.引用占用存储空间么？<br>3.什么是对象？<br>4.为什么对象需要对齐？</p>
<p>C++程序是如何生成的:</p>
<p>编译单元:一个c++文件以及由#include包含进来的其他文件。<br>预处理:处理预处理指令，将#include把其他.h和.cpp与当前编译的.cpp合并到一起。<br>编译:产生汇编代码<br>汇编:产生机器码<br>链接:解析引用的外部符号，如果引用的静态库的符号，把相关实现拷贝到最终输出的可执行程序或者静态库，不需要执行链接。<br>运行:加载动态库，为静态存储期对象分配空间，初始化非局部静态存储期对象，执行main函数。</p>
<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><h3 id="mian函数签名"><a href="#mian函数签名" class="headerlink" title="mian函数签名"></a>mian函数签名</h3><p>main函数没有声明，因为它是内建在语言中,<br>main的声明语法如下所示:<br>int maain（）;<br>Int main（int arge， char “argv[1）;</p>
<h3 id="标准命令行参数"><a href="#标准命令行参数" class="headerlink" title="标准命令行参数"></a>标准命令行参数</h3><p>main的参数允许对参数进行方便的命令行解析。argc和argv的类型是由语言定义的。argc和argv的名称是传统的，但您可以随意命名它们。<br>参数定义如下:<br>argc是一个整数，表示argv后面的参数的个数。<br>argc总是大于或等于1。argv一个以空字符结束的字符串数组，表示程序用户输入的命令行参数。按照惯例，argv[0]是用来调用程序的命令。Argv[1]是第一个命令行参数。命令行最后一个参数是argv[argc-1)， argv[argc]总是NULL</p>
<h2 id="c-程序终止"><a href="#c-程序终止" class="headerlink" title="c++程序终止"></a>c++程序终止</h2><p>在c++中，你可以通过以下方式退出程序:</p>
<ul>
<li>调用中止函数exit()。</li>
<li>调用abort()函数</li>
<li>从main执行返回语句</li>
</ul>
<h3 id="exit"><a href="#exit" class="headerlink" title="exit()"></a>exit()</h3><p>退出函数在&lt;stdlib.h&gt;中声明的exit函数终止c++程序。作为退出参数提供的值作为程序的返回码或退出码返回给操作系统。按照惯例，返回码为零意味着程序成功完成。可以使用常量EXIT FAILURE和EXIT SUCCESS(也在&lt;stdlib.h&gt;中定义)来指示程序的成功或失败。从main函数发出retun语句相当于用返回值作为参数调用exit函数。</p>
<h3 id="abort"><a href="#abort" class="headerlink" title="abort()"></a>abort()</h3><p>中止函数也在标准的include文件&lt;stdlib.h&gt;中声明，它终止一个c++程序。exit和abort之间的区别在于，exit允许进行c++运行时终止处理(调用全局对象析构函数)，但abort立即终止程序。中止函数绕过已初始化的全局静态对象的正常销毁过程。它还绕过了使用atexit函数指定的任何特殊处理。</p>
<h2 id="atexit"><a href="#atexit" class="headerlink" title="atexit()"></a>atexit()</h2><p>注册函数所指向的函数，在程序正常终止(通过std:exit()或从主函数返回)时调用。这些函数可以与具有静态存储时间的对象的销毁同时调用，也可以相互调用。保证如果A的注册被排序了——在B注册之前，那么B的调用也被排序了——在调用A之前，同样适用于静态对象构造函数和atexit调用之间的排序。</p>
<h2 id="动态库-x2F-静态库"><a href="#动态库-x2F-静态库" class="headerlink" title="动态库&#x2F;静态库"></a>动态库&#x2F;静态库</h2><p>静态库:链接时，静态库会被完整的复制到可执行文件中，被多次使用就有多份冗余拷贝。<br>动态库:链接时不复制，程序运行时由系统动态加载到内存中，供程序调用，系统只加载一次，多个程序共用，节省内存。</p>
<h3 id="选择动态库的理由："><a href="#选择动态库的理由：" class="headerlink" title="选择动态库的理由："></a>选择动态库的理由：</h3><p>1.需要在不重新编译使用者的情况下更新功能。<br>2.需要在进程内的多个动态库中共享状态。<br>3.需要运行时动态加载库，比如实现插件功能。<br>4.库被进程内的许多其它库使用，想降低整个程序包的磁盘空间和运行时占用内存。</p>
<h3 id="选择静态库的理由："><a href="#选择静态库的理由：" class="headerlink" title="选择静态库的理由："></a>选择静态库的理由：</h3><p>1.运行环境限制，不能使用动态库。（ios上的app)<br>2.不想维持接口的兼容，接口经常变化，又不想影响已经使用该库的用户。<br>3.方便程序的部署。</p>
<p>更深入的理解请参考：<br>&lt;&lt;深入理解计算机系统&gt;&gt;，&lt;&lt;程序员的自我修养—链接、装载与库&gt;&gt;</p>
<h2 id="变量占用存储空间么？"><a href="#变量占用存储空间么？" class="headerlink" title="变量占用存储空间么？"></a>变量占用存储空间么？</h2><p>在计算机编程中声明一个变量并不一定占用内存空间。</p>
<p>计算机编程中声明的含义当一个计算机程序需要调用内存空间的时候，对内存发出的“占位”指令，我们称之为“声明”。</p>
<p>&#x3D;&#x3D;声明一个变量只是将变量名标识符的有关信息告诉编译器，使编译器“认识”该标识符，但是声明并不一定引起内存的分配！而定义一个变量意味着给变量分配内存空间，用于存放对应类型的数据，变量名就是对相应的内存单元的命名。&#x3D;&#x3D;</p>
<p>C++程序中，大多数情况下变量声明也就是变量定义，声明变量的同时也就完成了变量的定义，只有声明外部变量时例外。</p>
<p>VB程序，Dim 语句，声明变量并分配存储空间。</p>
<p>当然这些语句实际是在程序运行或调试时才真正起作用，也有一些是在程序运行中还会发生动态数组变量的再定义而改变占用内存空间的。</p>
<p>变量来源于数学，是计算机语言中能储存计算结果或能表示值抽象概念。变量可以通过变量名访问。</p>
<p>在指令式语言中，变量通常是可变的；但在纯函数式语言（如Haskell）中，变量可能是不可变（immutable）的。在一些语言中，变量可能被明确为是能表示可变状态、具有存储空间的抽象（如在Java和Visual Basic中）；但另外一些语言可能使用其它概念（如C的对象）来指称这种抽象，而不严格地定义“变量”的准确外延。</p>
<h3 id="2-引用占用存储空间么？"><a href="#2-引用占用存储空间么？" class="headerlink" title="2.引用占用存储空间么？"></a>2.引用占用存储空间么？</h3><p>引用不是一种独立的数据类型，对引用只有声明没有定义<br>声明一个引用时，必须进行初始化<br>声明一个引用后，不能再使之作为另一个变量的引用<br>不能建立引用数组<br>int a[3];<br>int &amp;b[3]&#x3D;a; &#x2F;&#x2F;错误，不能建立引用数组<br>int &amp;b&#x3D;a[0]; &#x2F;&#x2F;错误，不能作为数组元素的别名<br>不能建立引用的引用，不能建立引用的指针<br>可以取引用的地址</p>
<p>&#x3D;&#x3D;引用同指针一样，占用一个4字节的内存空间（32位）&#x3D;&#x3D;<br>&#x3D;&#x3D;引用不占空间意思就是不占对象空间，不表示不占指针的少量空间。实际上指针是汇编工具实现引用的一种方式而已，而有的优化结果可能没有代表自己的指针&#x3D;&#x3D;</p>
<p>引用本质上是一个指针常量，在内存中为引用开辟了一个指针型的内存单元</p>
<h3 id="3-什么是对象？"><a href="#3-什么是对象？" class="headerlink" title="3.什么是对象？"></a>3.什么是对象？</h3><p>面对对象思想代表了一种看待事物的角度,面对对象思想代表了一种看待事物的角度。对象可以视为一种具有特定可控制生命周期的（构造，删除等），可以绑定函数以及属性的可复用的数据结构。</p>
<h3 id="4-为什么对象需要对齐？"><a href="#4-为什么对象需要对齐？" class="headerlink" title="4.为什么对象需要对齐？"></a>4.为什么对象需要对齐？</h3><p>据内存对齐（非静态成员变量）<br>第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行。</p>
<p>在数据成员完成各自对齐之后，类(结构或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。</p>
<p>很明显#pragma pack(n)作为一个预编译指令用来设置多少个字节对齐的。值得注意的是，n的缺省数值是按照编译器自身设置，一般为8，合法的数值分别是1、2、4、8、16。（即编译器只会按照1、2、4、8、16的方式分割内存。若n为其他值，是无效的。）</p>
<p><img src="https://img-blog.csdnimg.cn/2020052615523975.png#pic_center" alt="image"><br>内存分配过程：（对齐当前数据的内存最大值）</p>
<ol>
<li>char和编译器默认的内存缺省分割大小比较，char比较小，分配一个字节给它。</li>
<li>int和编译器默认的内存缺省分割大小比较，int比较小，占4字节。只能空3个字节，重新分配4个字节。</li>
<li>short和编译器默认的内存缺省分割大小比较，short比较小，占2个字节，分配2个字节给它。</li>
<li>对齐结束类本身也要对齐，所以最后空余的2个字节也被test占用。<br><img src="https://img-blog.csdnimg.cn/20200526155258690.png#pic_center" alt="image"></li>
<li>int和编译器默认的内存缺省分割大小比较，int比较小，占4字节。分配4个字节给int。</li>
<li>char和编译器默认的内存缺省分割大小比较，char比较小，分配一个字节给它。</li>
<li>short和编译器默认的内存缺省分割大小比较，short比较小，此时前面的char分配完毕还余下3个字节，足够short的2个字节存储，所以short紧挨着。分配2个字节给short。</li>
<li>对齐结束类本身也要对齐，所以最后空余的1个字节也被该对象占用。</li>
<li>可以使用#pragma pack(n)来决定字节对齐的标准。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cachefish.github.io/2022/03/07/14-%E5%A3%B0%E6%98%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="来世做春风，浪漫且自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cachecatのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/07/14-%E5%A3%B0%E6%98%8E/" class="post-title-link" itemprop="url">c++ 声明</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-07 19:30:00 / 修改时间：10:13:23" itemprop="dateCreated datePublished" datetime="2022-03-07T19:30:00+08:00">2022-03-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-base/" itemprop="url" rel="index"><span itemprop="name">c++ base</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>声明将名字引入（或再引入）到C++程序中。每种实体的声明方式都不同。<br>定义是足以使该名字所标识的实体被使用的声明。</p>
<h2 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h2><p>顶层CV修饰符（Top-Level cv-Qualifiers）<br>◆C  +中的类型可以由一层或多层组成。<br>例如int *p, p的类型是 pointer to int, 是由2层组成，第1层是“pointer to”,第2层是 “int”。</p>
<p>◆ cv修饰符可以出现在任何层次上。<br>例如 int * const p， 申明了p是“constant pointer to int”, const修饰的是第一层。<br>又比如 volatile int * p， p是 “pointer to volatile int”, volatile修饰的是第二层。</p>
<p>● 在C++中修饰第1层的cv修饰符被称为顶层cv修饰符(top-level cv-qualifier)</p>
<p>再比如：<br>const int * volatile p , 顶层cv修饰符是volatile<br>int * const p, 顶层cv修饰符是const<br>int const volatile * p, 没有顶层修饰符</p>
<p>基本类型例如char, int只由一层构成，因此如下的申明<br>const int x &#x3D; 1;<br>顶层cv修饰符是const.</p>
<p>◆ 小知识：<br>C++函数签名包括所有出现在参数列表中的cv修饰符，除了那些出现在参数列表中的顶层cv修饰符。<br>因此如下2个函数拥有相同的函数签名，认为是同一个函数。<br>虽然函数签名的参数列表中忽略了顶层cv修饰符，但是但函数体内，顶层cv修饰符还是起作用的。比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int* pp(int *const p)&#123;</span><br><span class="line">   p = … // error不能对常量指针进行赋值。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="转发引用（forwarding-reference"><a href="#转发引用（forwarding-reference" class="headerlink" title="转发引用（forwarding reference)"></a>转发引用（forwarding reference)</h2><p>转发引用是一种能够保留函数参数值类型的一种特殊引用，这使它能够通过std::forward进行转发。转发引用由2中形式</p>
<p>1.它是函数模板的函数参数，该参数是对同一函数模板的无cv修饰符的类型模板参数的右值引用。(Function parameter of a function template declared as rvalue reference to cv-unqualified type template parameter of that same function template。)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">int f(T&amp;&amp; x) &#123;    // x is a forwarding reference</span><br><span class="line">    return g(std::forward&lt;T&gt;(x)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">int g(const T&amp;&amp; x); // x is not a forwarding reference:</span><br><span class="line">                              // const T is not cv-unqualified</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt; struct A &#123;</span><br><span class="line">    template&lt;class U&gt;</span><br><span class="line">    A(T&amp;&amp; x, U&amp;&amp; y, int* p); </span><br><span class="line">    // x is not a forwarding reference: T is not a</span><br><span class="line">    // type template parameter of the constructor,</span><br><span class="line">    // but y is a forwarding reference</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.auto&amp;&amp;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">auto&amp;&amp; vec = foo();       </span><br><span class="line">// foo() may be lvalue or rvalue, </span><br><span class="line">// vec is a forwarding reference</span><br><span class="line"></span><br><span class="line">for (auto&amp;&amp; x: f()) &#123; // x is a forwarding reference; </span><br><span class="line">// this is the safest way to use range for loops</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模板类型推导"><a href="#模板类型推导" class="headerlink" title="模板类型推导"></a>模板类型推导</h2><p>现代C++最引人注目的特性之一就是atuo，它是建立在模板类型推导基础之上的。但模板类型推导应用于auto上有时候不如应用于模板那么直观，所以我们有必要真正的理解模板类型推导, 这样才能更好的理解auto推导。</p>
<p>我们把函数模板表示为如下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void f(ParamType param);</span><br></pre></td></tr></table></figure>
<p>对它的调用表示为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(expr); // call f with some expression</span><br></pre></td></tr></table></figure>
<p>编译期间，编译器使用expr去推导T和ParamType这两个类型。这两个类型通常是不同的，因为ParamType通常会有cv或引用修饰。<br>例如模板申明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void f(const T&amp; param); / / ParamType is const T&amp;</span><br></pre></td></tr></table></figure>
<p>调用如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int x = 0;</span><br><span class="line">f(x);   // call f with an int</span><br></pre></td></tr></table></figure>
<p>T被推导为int， ParamType被推导为const int&amp;.<br>在这个例子中T和x的类型都是int，然而并不是所有情况都是如此，T的类型不仅取决于expr的类型还取决于ParamType的形式。</p>
<h3 id="推导规则：（并非C-标准定义的规则，而是易于理解记忆的规则）"><a href="#推导规则：（并非C-标准定义的规则，而是易于理解记忆的规则）" class="headerlink" title="推导规则：（并非C++标准定义的规则，而是易于理解记忆的规则）"></a>推导规则：（并非C++标准定义的规则，而是易于理解记忆的规则）</h3><p>★ 忽略expr的引用类型<br>★ 如果ParamType是非引用类型：<br>■ 如果expr是数组会转化为指向数组第一项元素的指针<br>■ 如果expr是函数会转化为函数指针<br>■ expr的顶级cv修饰符会被忽略掉<br>★ expr 未被忽略掉的且在ParamType中没有出现的cv修饰符能在T中能得到保留。<br>★如果ParamType是转发引用且expr为左值，那么T和ParamType都为左值引用。其余场景将T直接替换到ParamType中去就是param的类型。</p>
<p>下面根据ParamType的如下三种常见形式进行举例说明。</p>
<ol>
<li>aramType是普通引用类型（非转发引用）。</li>
<li>aramType是转发引用</li>
<li>aramType 不是引用类型</li>
</ol>
<p>场景1 : ParamType是普通引用类型（非转发引用）</p>
<h4 id="例1：ParamType是左值引用"><a href="#例1：ParamType是左值引用" class="headerlink" title="例1：ParamType是左值引用"></a>例1：ParamType是左值引用</h4><p>template<typename T><br>void f(T&amp; param);<br>expr定义如下，本章所有场景的例子都使用如下定义，不再特别说明。<br>int x &#x3D; 1;<br>in&amp; rx &#x3D;x;<br>const int cx &#x3D; x;<br>const int&amp; rcx &#x3D; x;<br>volatile int vx &#x3D; x;<br>volatile int&amp; rvx &#x3D; x;<br>const volatile int cvx &#x3D; x;<br>const volatile int&amp; rcvx &#x3D; x;<br>int* px &#x3D; &amp;x;<br>int*&amp; rpx &#x3D; px;<br>int *const cpx &#x3D; &amp;x;<br>const int *pcx &#x3D; &amp;x;<br>const int *const cpcx &#x3D; &amp;xl;<br>int ar[] &#x3D; {1,2,3};<br>void ff(int v){}<br>对于各种情况的调用，T和param的类型如下</p>
<p><img src="https://img-blog.csdnimg.cn/298676bd18034ac58a4e1f473aa3e69e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2FjaGVmaXNo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="image"></p>
<p>要点：<br>●expr中的const和volatile都在T中得到了保留<br>●f(rcx), f(rvx)中，T都不是引用类型，因为rcx和rvx的引用类型都在推导过程中被忽略了。<br>●对于const和volatile的处理都是一样的。</p>
<p>例2：ParamType是cv左值引用<br>对前面的例子稍加改动，ParaType从T&amp;变为const T&amp;<br>template<typename T><br>void f(const T&amp; param);<br>对于各种情况的调用，T和param的类型如下<br><img src="https://img-blog.csdnimg.cn/ff2d4e927aa24e0285aa3213b7dbcf7a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2FjaGVmaXNo,size_19,color_FFFFFF,t_70,g_se,x_16" alt="image"></p>
<p>要点：<br>●因为ParaType中有了const，因此const不必包含在T中（对于volatile同理）。（对于实参为指针类型，ParaType中的const修饰的是指针本身而非指针指向的内容。）<br>●f(vx), f(rvx), f(cvx)中因为ParaType中没有volatile，因此volatile仍在T中得到保留。<br>●expr是指针类型和值类型并无处理上的不同。</p>
<h3 id="例3：ParamType是右值引用"><a href="#例3：ParamType是右值引用" class="headerlink" title="例3：ParamType是右值引用"></a>例3：ParamType是右值引用</h3><p>template<typename T><br>void f(const T&amp;&amp; param);<br>注意：若果没有const修饰，就是转发引用了，后面会特别讨论。</p>
<p>此种情况expr只能是右值。</p>
<p>对于各种情况的调用，T和param的类型如下:<br><img src="https://img-blog.csdnimg.cn/8cf76cd0dcdc4c538f120ba6a67a5a7e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2FjaGVmaXNo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="image"></p>
<p>要点：<br>●move 不改变cv<br>●除了函数只接受右值和前面的情况不没有啥不同。</p>
<p>场景2 : ParamType是转发引用类型<br>ParamType是转发引用只有如下一种情况<br>template<typename T><br>void f(T&amp;&amp; param);</p>
<p>推导规则补充说明：<br>1.如果expr是左值，T和ParamType都推导为左值引用。<br>2.如果expr是右值，根据普通引用的规则进行推导。</p>
<p>对于传入右值的调用，T和param的类型如下:<br><img src="https://img-blog.csdnimg.cn/66e2a725edc1412eacf3ed1e1abfd015.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2FjaGVmaXNo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="image"></p>
<p>要点：<br>●para都是右值引用</p>
<p>对于传入左值的调用，T和param的类型如下:<br><img src="https://img-blog.csdnimg.cn/c97e62bb5c494330be1cc834c0cddc8b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2FjaGVmaXNo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="image"></p>
<p>要点：<br>●如果expr是左值T被推导为左值引用，这是模板类型推导唯一会推导出T为引用类型的场景。<br>●expr中的const和volatile都在T中得到了保留</p>
<p>场景3: ParamType不是引用类型（指针或值）<br>推导要点：忽略expr的顶级cv修饰符，数组和函数会退化为指针类型。<br>例1：ParamType是值<br>template<typename T><br>void f(T param);<br>对于各种情况的调用，T和param的类型如下:<br><img src="https://img-blog.csdnimg.cn/26c2e61c8ae94050a9577d69a5557603.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2FjaGVmaXNo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="image"></p>
<p>例2：ParamType是指针<br>template<typename T><br>void f(T* param); </p>
<p>对于各种情况的调用，T和param的类型如下<br><img src="https://img-blog.csdnimg.cn/9d536ce3fff04e7c8377b576cdebea75.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2FjaGVmaXNo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="image"><br>备注：T都不为指针类型，因为ParamType中已经有指针了，指针类型不必包含在T中了。（和cv的处理同理）</p>
<p>auto类型推导<br>auto类型和推导同模板类型推导基本有一样的规则，只有一个例外，后面会讲到。虽然形式上2者看起来不一样但是2者存在直接的映射关系。</p>
<p>前一节中我们把函数模板表示为如下形式：<br>template<typename T><br>void f(ParamType param);<br>对它的调用表示为：<br>f(expr); &#x2F;&#x2F; call f with some expression<br>当调用f, 编译器使用expr推断T和ParamType的类型。<br>当一个变量定义时使用auto，auto的作用相当于T，变量的类型说明符相当于ParamType, 变量名相当于param, 右边的初始化表达式相当于expr, 例如：</p>
<p><img src="https://img-blog.csdnimg.cn/bef2217e10c84e5898c7ebe14cee839b.png" alt="image"></p>
<p>如下例子是一些例子，和模板类型推导没有任何区别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">auto x = 1;                //case 3, x is int</span><br><span class="line">auto* px = &amp;x;             //case 3, px is *int</span><br><span class="line">const auto cx = x;         //case 3, cx is const int</span><br><span class="line">const auto&amp; rx = x;        //case 1, rx is const int&amp;</span><br><span class="line">auto&amp;&amp; fr1 = x;            //case 2, fr1 is int&amp;</span><br><span class="line">auto&amp;&amp; fr2 = cx;           //case 2, fr2 is const int&amp;</span><br><span class="line">auto&amp;&amp; fr3 = 27;           //case 2, fr3 is int&amp;&amp;</span><br></pre></td></tr></table></figure>

<p>和模板类型推导的唯一例外<br>前面看到的都是auto类型推导和模板类型推导的相同之处，这里要介绍他们唯一的不同。<br>C++11之前定义并初始化一个变量可以按照如下方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int x1 = 1;</span><br><span class="line">int x2(1);</span><br></pre></td></tr></table></figure>
<p>C++11开始支持统一初始化,支持如下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int x3&#123;1&#125;</span><br><span class="line">int x4 = &#123;1&#125;;</span><br></pre></td></tr></table></figure>
<p>如果使用auto来从写上面4个定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto x1 = 1;</span><br><span class="line">auto x2(1);</span><br><span class="line">auto x3&#123;1&#125;;</span><br><span class="line">auto x4=&#123;1&#125;;</span><br></pre></td></tr></table></figure>
<p>上面4个auto定义的变量类型并不都是int， x4为std::initializer_list. (C++11中x3也为std::initializer_list，之后的标准中为int).<br>★这就是auto类型推导的特别之处，对于&#x3D;{}形式的初始化特别处理了。<br>★函数模板不支持对{}的推导。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto x = &#123;1,2,3,4&#125; // x的类型为std::initializer_list&lt;int&gt;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void f(T param);</span><br><span class="line">f(&#123;1,2,3,4&#125;)         //error! 不能推导T的类型</span><br></pre></td></tr></table></figure>
<p>但是模板类型推导支持 param 是std::initializer_list<T>的形式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void f(std::initializer_list&lt;T&gt; init_list);</span><br><span class="line">f(&#123; 11, 23, 9 &#125;); </span><br><span class="line">// T为 int,init_list类型为 std::initializer_list&lt;int&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>auto也能推导函数返回值，此时应用的是也模板类型推导规则<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto create_initlist()&#123;</span><br><span class="line">return &#123; 1, 2, 3 &#125;;  // error: can&#x27;t deduce type  for </span><br><span class="line">                     // &#123; 1, 2, 3 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>auto 应用于lambda也是模板类型推导规则<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt; v;</span><br><span class="line">auto reset_v = [&amp;v](const auto&amp; new_value) &#123; </span><br><span class="line">v = new_value; </span><br><span class="line">&#125;;</span><br><span class="line">reset_v(&#123; 1, 2, 3 &#125;); // error! can&#x27;t deduce type for</span><br><span class="line">                      //&#123; 1, 2, 3 &#125;</span><br></pre></td></tr></table></figure>
decltype(auto)<br>decltype 总是返回实体的准确类型， auto使用模板类型推导的规则(比如会去掉引用等）。</li>
</ul>
<p>decltype示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const int i = 0;           // decltype(i) is const int</span><br><span class="line">bool f(const Widget&amp; w);   // decltype(w) is const Widget&amp;</span><br><span class="line">                           // decltype(f) is bool(const Widget&amp;)</span><br><span class="line">struct Point &#123;</span><br><span class="line">  int x, y;                // decltype(Point::x) is int</span><br><span class="line">&#125;;                         // decltype(Point::y) is int</span><br><span class="line">Widget w;                  // decltype(w) is Widget</span><br><span class="line">if (f(w)) ...              // decltype(f(w)) is bool</span><br><span class="line">template&lt;typename T&gt;       // simplified version of std::vector</span><br><span class="line">class vector &#123;</span><br><span class="line">public:</span><br><span class="line">  ...</span><br><span class="line">  T&amp; operator[](std::size_t index);</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;int&gt; v;             // decltype(v) is vector&lt;int&gt;</span><br><span class="line">...</span><br><span class="line">if (v[0] == 0) ...         // decltype(v[0]) is int&amp;</span><br></pre></td></tr></table></figure>

<p>◆Decltype可以和auto组合使用，使auto应用decltype的规则。<br>单纯使用auto</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Widget w;</span><br><span class="line">const Widget&amp; cw = w;</span><br><span class="line">auto mw = cw;  // auto type deduction, mw&#x27;s type is Widget</span><br></pre></td></tr></table></figure>
<p>使用decltype(auto)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">decltype(auto) mw = cw; // decltype type deduction:</span><br><span class="line">                        // mw&#x27;s type is const Widget&amp;</span><br></pre></td></tr></table></figure>

<h3 id="如何查看推导得出的类型"><a href="#如何查看推导得出的类型" class="headerlink" title="如何查看推导得出的类型"></a>如何查看推导得出的类型</h3><h4 id="通过编译错误信息"><a href="#通过编译错误信息" class="headerlink" title="通过编译错误信息"></a>通过编译错误信息</h4><p>可以让编译器使用推导出的类型时产生编译错误，从而在输出的错误信息中看到推导出的类型。比如我们只申明但不定义一个类模板，然后使用这类模板。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class TD;</span><br><span class="line"></span><br><span class="line">void ff(int v)&#123;&#125;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">static void f1(T&amp; param)&#123;</span><br><span class="line">    TD&lt;decltype(param)&gt; pt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TEST(deduce, 1)&#123;</span><br><span class="line">    f1(ff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在vc2019下有如下输出：<br>error C2079: “pt”使用未定义的 class“TD&lt;T (__cdecl &amp;)&gt;”<br>message : 查看对正在编译的函数 模板 实例化“void f1&lt;void(int)&gt;(T (__cdecl &amp;))”的引用</p>
<p>在g++ 11下有如下输出：<br>In instantiation of ‘void f1(T&amp;) [with T &#x3D; void(int)]’:<br>error: ‘TD&lt;void (&amp;)(int)&gt; pt’ has incomplete type</p>
<p>从中我们都可以看出T的类型为void(int), param的类型为void(&amp;)(int)</p>
<p>使用Boost.Type‐Index<br>该库是头文件形式的库，不需要编译，下载boost后直接include就可以使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;boost/type_index.hpp&gt;</span><br><span class="line">void ff(int v)&#123;&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">static void f1(T&amp; param)&#123;</span><br><span class="line">using boost::typeindex::type_id_with_cvr;</span><br><span class="line">cout &lt;&lt; &quot;T=&quot; &lt;&lt; type_id_with_cvr&lt;T&gt;().pretty_name() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;param=&quot; &lt;&lt; type_id_with_cvr&lt;decltype(param)&gt;().pretty_name() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">f1(ff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>G++11编译输出如下：<br>T&#x3D;void (int)<br>param&#x3D;void (&amp;)(int)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cachefish.github.io/2022/03/07/15-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="来世做春风，浪漫且自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cachecatのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/07/15-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" class="post-title-link" itemprop="url">c++ 字符编码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-07 19:30:00 / 修改时间：10:13:28" itemprop="dateCreated datePublished" datetime="2022-03-07T19:30:00+08:00">2022-03-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-base/" itemprop="url" rel="index"><span itemprop="name">c++ base</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="字符编码概述"><a href="#字符编码概述" class="headerlink" title="字符编码概述"></a>字符编码概述</h2><p>字符集就是一系列用于显示的字符的集合。<br>编码就是这些字符如何用字节流进行表示。一个字符集可能有多种编码方式.</p>
<h3 id="ANSI编码"><a href="#ANSI编码" class="headerlink" title="ANSI编码"></a>ANSI编码</h3><p>世界各国针对ASCII的扩展方案（如欧洲的ISO&#x2F;IEC 8859，中国的GB系列等），这些ASCII扩展编码方案的特点是：他们都兼容ASCII编码，但他们彼此之间是不兼容的。微软将这些编码方案统称为ANSI编码。</p>
<h3 id="代码页"><a href="#代码页" class="headerlink" title="代码页"></a>代码页</h3><p>在windows操作系统上，默认使用ANSI来保存文件。那么操作系统是如何知道ANSI到底应该表示哪种编码了，是GBK，还是ASCII，或者还是EUC-KR了？ windows通过一个叫”Code Page”（翻译为中文就叫代码页）的东西来判断系统的默认编码。<br>ANSI编码可以理解为非Unicode编码的统称</p>
<p>各种编码的字符串能强制转换为char类型的字符串来操作？<br>UTF16,UTF32编码不行，因为中间bytes存在大量0。<br>UTF8和其它ANSI编码可以，因为本来就是多字节编码没必要在中间添加0来浪费空间。</p>
<h2 id="源字符集，执行字符集"><a href="#源字符集，执行字符集" class="headerlink" title="源字符集，执行字符集"></a>源字符集，执行字符集</h2><p>源字符集(source character set)：<br>源字符集中的字符就是源程序的字符，编译器读取源文件时需要理解的编码方式（注意没有编辑器什么关系）。<br>执行字符集(execution character set)：<br>执行字符集表示可出现在已编译程序中的字符，程序运行时字符的编码方式。 这些字符集由源文件中允许的所有字符以及表示警报、退格符、回车符和 null 字符的控制字符组成。</p>
<h3 id="vc-源字符集"><a href="#vc-源字符集" class="headerlink" title="vc 源字符集"></a>vc 源字符集</h3><p>1.若文件开始处有BOM(EF BB BF)，则判定为UTF-8编码；<br>2.若没有BOM，则试图从文件的前8个字节来判断文件是否像UTF-16编码，如果像，则就判断为UTF-16编码。<br>3.如果既没BOM，也不是UTF-16编码，则使用系统当前的代码页。<br>&#x2F;source-charset or &#x2F;utf-8  </p>
<h3 id="gcc-源字符集"><a href="#gcc-源字符集" class="headerlink" title="gcc 源字符集"></a>gcc 源字符集</h3><p>默认UTF-8<br>-finput-charset</p>
<h3 id="vc-执行字符集"><a href="#vc-执行字符集" class="headerlink" title="vc 执行字符集"></a>vc 执行字符集</h3><p>1.对于宽字符串（即C&#x2F;C++中以L标记的串，如L”abc”, L’中’），执行字符集为UTF-16编码。<br>2.u8，u, U前缀字符串，分别UTF8, UTF16, UTF32编码<br>3.对于未带前缀的字符串，执行字符集为系统当前的代码页。<br>&#x2F;execution-charset or &#x2F;utf-8 </p>
<h3 id="gcc执行字符集"><a href="#gcc执行字符集" class="headerlink" title="gcc执行字符集"></a>gcc执行字符集</h3><p>1.对于宽字符串UTF-32<br>2.u8，u, U前缀字符串，分别UTF8, UTF16, UTF32编码<br>3.对于未带前缀的字符串，默认UTF-8<br>-fexec-charset<br>-fwide-exec-charset</p>
<h3 id="VC"><a href="#VC" class="headerlink" title="VC"></a>VC</h3><p>VC默认情况下，Visual Studio会检测字节顺序标记，以确定源文件是否是编码过的Unicode格式，例如UTF-16或UTF-8。如果没有找到字节顺序标记，它假定源文件是使用当前用户代码页编码的，除非您通过使用&#x2F;source-charset选项或&#x2F;utf-8选项指定了字符集名称或代码页。Visual Studio允许你通过使用几种字符编码来保存你的c++源代码。有关源代码和执行字符集的信息，请参阅语言文档中的字符集。如果您希望将源字符集和执行字符集都设置为UTF-8，您可以使用&#x2F; UTF-8编译器选项作为快捷方式。它相当于在命令行上指定&#x2F;sourcecharset:utf-8 &#x2F; execute -charset:utf-8。默认情况下，这些选项都启用&#x2F;validate-charset选项。</p>
<h3 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h3><ul>
<li>-finput-charset&#x3D;charset<br> 设置输入字符集，用于将输入文件的字符集转换为GCC使用的源字符集。如果区域设置没有指定，或者GCC无法从区域设置获取此信息，则默认为UTF-8。这可以被区域设置或命令行选项覆盖。目前，如果有冲突，命令行选项优先。Charset可以是系统iconv库例程支持的任何编码。</li>
<li>-fexec-charset&#x3D;charset<br>设置执行字符集，用于字符串和字符常量。默认为UTF-8。Charset可以是系统iconv库例程支持的任何编码。</li>
<li>-fwide-exec-charset&#x3D;charset<br>设置宽执行字符集，用于宽字符串和字符常量。默认值是UTF-32或UTF-16，两者都对应于wchar_t的宽度。和’-fex -charset’一样，charset可以是系统iconv库例程支持的任何编码;但是，编码不完全适合wchar_t会有问题。</li>
</ul>
<h2 id="字符文本"><a href="#字符文本" class="headerlink" title="字符文本"></a>字符文本</h2><p>字符字面值由常量字符组成。它由单引号包围的字符表示。字符字面值有五种:</p>
<ol>
<li>char类型的普通字符字面值，例如’a’</li>
<li>char类型的UTF-8字符字面值(c++20中的char8_t)，例如u8’a’．</li>
<li>wchar_t类型的宽字符字面值，例如L’a’</li>
<li>char16_t类型的UTF-16字符字面值，例如u’a’</li>
<li>char32 t类型的UTF-32字符字面值，例如U’a’</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">auto s3 = u&quot;hello&quot;; const char16_t*</span><br><span class="line">auto s4 = U&quot;heelo&quot;; const char32_t*</span><br><span class="line">const wchar_t wide = L&quot;zyxw&quot;;</span><br><span class="line">const wchar_t newline=L&quot;hello\ngood&quot;;</span><br><span class="line"></span><br><span class="line">//c++20 -&gt;</span><br><span class="line">const char8_t u8str1 = u8&quot;hello world&quot;;</span><br><span class="line">const char8_t u8str2 = u8&quot;\U0001F607 is 0:-&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="std-string-文本"><a href="#std-string-文本" class="headerlink" title="std::string 文本"></a>std::string 文本</h2><p>string字面值是用户定义的字面值(见下文)的标准库实现，表示为“xyz”(带有s后缀)。这种字符串字面值产生一个临时对象，类型为std::string、std::wstring、std::u32string或std::u16string，这取决于所指定的前缀。如果没有使用任何前缀，就会产生一个std::string。L”xyz”生成一个std::wstring。u”xyz”s生成一个std:u16string, u”xyz”s生成一个std:u32string。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string str&#123;&quot;hello&quot;s&#125;;</span><br><span class="line">string str2&#123;u8&quot;&quot;Hello world&quot;&#125;;</span><br><span class="line">u8string u8str2&#123;u8&quot;Hello World&quot;&#125;;</span><br><span class="line">wstring str3&#123;L&quot;hello&quot;s&#125;;</span><br><span class="line">u16string str4&#123;u&quot;hello&quot;s&#125;;</span><br><span class="line">u32string str5&#123;U&quot;hello&quot;s&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="字符文本的执行期编码："><a href="#字符文本的执行期编码：" class="headerlink" title="字符文本的执行期编码："></a>字符文本的执行期编码：</h3><p>除了普通字符和宽字符由编译器决定，其余字符文本都给予前缀表示的方式进行编码。可见同一个编译单元中字符的执行期编码可以有多种。</p>
<p>对于程序运行过程的和外界交互（网络收发，文件读写，数据库读写等）涉及到的字符，则要规定好编码方式，然后进行处理。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cachefish.github.io/2022/03/07/17-netfiliter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="来世做春风，浪漫且自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cachecatのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/07/17-netfiliter/" class="post-title-link" itemprop="url">netfiliter</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-07 19:30:00 / 修改时间：10:13:43" itemprop="dateCreated datePublished" datetime="2022-03-07T19:30:00+08:00">2022-03-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/network/" itemprop="url" rel="index"><span itemprop="name">network</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="netfiliter"><a href="#netfiliter" class="headerlink" title="netfiliter"></a>netfiliter</h2><p>netfilter 项目支持数据包过滤、网络地址 [和端口] 转换 (NA[P]T)、数据包日志记录、用户空间数据包队列和其他数据包处理。</p>
<p>netfilter 钩子是 Linux 内核中的一个框架，它允许内核模块在 Linux 网络堆栈的不同位置注册回调函数。然后，为遍历 Linux 网络堆栈中相应挂钩的每个数据包回调已注册的回调函数。</p>
<hr>
<h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><p>无状态数据包过滤（IPv4 和 IPv6）<br>有状态数据包过滤（IPv4 和 IPv6）<br>各种网络地址和端口转换，例如 NAT&#x2F;NAPT（IPv4 和 IPv6）<br>灵活和可扩展的基础设施<br>用于 3rd 方扩展的多层 API</p>
<hr>
<h3 id="我可以用-netfilter-做什么？"><a href="#我可以用-netfilter-做什么？" class="headerlink" title="我可以用 netfilter 做什么？"></a>我可以用 netfilter 做什么？</h3><p>基于无状态和有状态包过滤构建互联网防火墙<br>部署高可用的无状态和有状态防火墙集群<br>如果您没有足够的公共 IP 地址，请使用 NAT 和伪装来共享 Internet 访问<br>使用 NAT 实现透明代理<br>帮助用于构建复杂的 QoS 和策略路由器的 tc 和 iproute2 系统<br>进行进一步的数据包操作（修改），例如更改 IP 标头的 TOS&#x2F;DSCP&#x2F;ECN 位</p>
<h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><h3 id="规则概念"><a href="#规则概念" class="headerlink" title="规则概念"></a>规则概念</h3><p>规则（rules）其实就是网络管理员预定义的条件，规则一般的定义为“如果数据包头符合这样的条件，就这样处理这个数据包”。规则存储在内核空间的信息 包过滤表中，这些规则分别指定了源地址、目的地址、传输协议（如TCP、UDP、ICMP）和服务类型（如HTTP、FTP和SMTP）等。<br>当数据包与规则匹配时，iptables就根据规则所定义的方法来处理这些数据包，如放行(accept),拒绝(reject)和丢弃(drop)等。配置防火墙的主要工作是添加,修改和删除等规则。<br>其中：</p>
<ul>
<li>匹配（match）：符合指定的条件，比如指定的 IP 地址和端口。</li>
<li>丢弃（drop）：当一个包到达时，简单地丢弃，不做其它任何处理。</li>
<li>接受（accept）：和丢弃相反，接受这个包，让这个包通过。</li>
<li>拒绝（reject）：和丢弃相似，但它还会向发送这个包的源主机发送错误消息。这个错误消息可以指定，也可以自动产生。</li>
<li>目标（target）：指定的动作，说明如何处理一个包，比如：丢弃，接受，或拒绝。</li>
<li>跳转（jump）：和目标类似，不过它指定的不是一个具体的动作，而是另一个链，表示要跳转到那个链上。</li>
<li>规则（rule）：一个或多个匹配及其对应的目标</li>
</ul>
<h2 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h2><p>规则存储在内核空间的信息包过滤表中，这些规则分别指定了源地址、目的地址、传输协议（如TCP、UDP、ICMP）和服务类型（如HTTP、FTP和SMTP）等。当数据包与规则匹配时，iptables就根据规则所定义的方法来处理这些数据包，如放行（accept）、拒绝（reject）和丢弃（drop）等。配置防火墙的主要工作就是添加、修改和删除这些规则。</p>
<h4 id="1-iptables的概述"><a href="#1-iptables的概述" class="headerlink" title="1. iptables的概述"></a>1. iptables的概述</h4><p>iptables 实际上就是一种包过滤型防火墙。 就是通过书写一些接受哪些包，拒绝哪些包的规则，实现数据包的过滤。这些规则存储在专用的信息包过滤表中，而这些表集成在Linux 内核中。在信息包过滤表中，规则被分组放在我们所谓的链（chain）中。</p>
<h4 id="2-iptables的组成"><a href="#2-iptables的组成" class="headerlink" title="2. iptables的组成"></a>2. iptables的组成</h4><p>iptables由两部分组成：<br>(1) framework： netfilter hooks function钩子函数，实现网络过滤器的基本框架。<br>(2) rule utils： iptables 规则管理工具</p>
<h4 id="3-iptables的三链五表"><a href="#3-iptables的三链五表" class="headerlink" title="3. iptables的三链五表"></a>3. iptables的三链五表</h4><p>表（tables）：提供特定的功能，iptables内置了4个表，即filter表、nat表、mangle表和raw表，分别用于实现包过滤，网络地址转换、包重构(修改)和数据跟踪处理。<br>链（chains）：是数据包传播的路径，每一条链其实就是众多规则中的一个检查清单，每一条链中可以有一 条或数条规则。当一个数据包到达一个链时，iptables就会从链中第一条规则开始检查，看该数据包是否满足规则所定义的条件。如果满足，系统就会根据 该条规则所定义的方法处理该数据包；否则iptables将继续检查下一条规则，如果该数据包不符合链中任一条规则，iptables就会根据该链预先定 义的默认策略来处理数据包。</p>
<p>Iptables采用“表”和“链”的分层结构，在Linux中现在是四张表五个链。下面罗列一下这四张表和五个链<br>总体说来，iptables就是由“三表五链”组成。</p>
<h5 id="规则表："><a href="#规则表：" class="headerlink" title="规则表："></a>规则表：</h5><pre><code>1）filter表——三个链：INPUT、FORWARD、OUTPUT
作用：过滤数据包 内核模块：iptables_filter.
2）Nat表——三个链：PREROUTING、POSTROUTING、OUTPUT
作用：用于网络地址转换（IP、端口） 内核模块：iptable_nat
3）Mangle表——五个链：PREROUTING、POSTROUTING、INPUT、OUTPUT、FORWARD
作用：修改数据包的服务类型、TTL、并且可以配置路由实现QOS内核模块：iptable_mangle(别看这个表这么麻烦，咱们设置策略时几乎都不会用到它)
4）Raw表——两个链：OUTPUT、PREROUTING
作用：决定数据包是否被状态跟踪机制处理 内核模块：iptable_raw
</code></pre>
<h5 id="规则链："><a href="#规则链：" class="headerlink" title="规则链："></a>规则链：</h5><pre><code>1）INPUT——进来的数据包应用此规则链中的策略
2）OUTPUT——外出的数据包应用此规则链中的策略
3）FORWARD——转发数据包时应用此规则链中的策略
4）PREROUTING——对数据包作路由选择前应用此链中的规则（记住！所有 的数据包进来的时侯都先由这个链处理）
5）POSTROUTING——对数据包作路由选择后应用此链中的规则
</code></pre>
<p><img src="https://images2015.cnblogs.com/blog/907596/201701/907596-20170109105448244-1425780290.png" alt="image"></p>
<h4 id="x3D-x3D-管理和设置iptables规则：-x3D-x3D"><a href="#x3D-x3D-管理和设置iptables规则：-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;管理和设置iptables规则：&#x3D;&#x3D;"></a>&#x3D;&#x3D;管理和设置iptables规则：&#x3D;&#x3D;</h4><p><img src="https://images2015.cnblogs.com/blog/907596/201701/907596-20170109105720728-1179021991.png" alt="image"><br><img src="https://images2015.cnblogs.com/blog/907596/201701/907596-20170109105731713-1860013490.png" alt="image"><br>iptables传输数据包的过程<br><img src="https://images2015.cnblogs.com/blog/907596/201701/907596-20170109110004244-1719477737.png" alt="image"></p>
<p> 1）当一个数据包进入网卡时，它首先进入PREROUTING链，内核根据数据包目的IP判断是否需要转送出去。<br>   2）如果数据包就是进入本机的，它就会沿着图向下移动，到达INPUT链。数据包到了INPUT链后，任何进程都会收到它。本机上运行的程序可以发送数据包，这些数据包会经过OUTPUT链，然后到达POSTROUTING链输出。<br>   3）如果数据包是要转发出去的，且内核允许转发，数据包就会如图所示向右移动，经过FORWARD链，然后到达POSTROUTING链输出。</p>
<p><img src="https://images2015.cnblogs.com/blog/907596/201701/907596-20170109110506869-2063756658.png" alt="image"></p>
<p>从图中可将iptables数据包报文的处理过程分为三种类型：</p>
<h5 id="1）目的为本机的报文"><a href="#1）目的为本机的报文" class="headerlink" title="1）目的为本机的报文"></a>1）目的为本机的报文</h5><p>报文以本机为目的地址时，其经过iptables的过程为：</p>
<ul>
<li>1.数据包从network到网卡</li>
<li>2.网卡接收到数据包后，进入raw表的PREROUTING链。这个链的作用是在连接跟踪之前处理报文，能够设置一条连接不被连接跟踪处理。(注：不要在raw表上添加其他规则)</li>
<li>3.如果设置了连接跟踪，则在这条连接上处理。</li>
<li>4.经过raw处理后，进入mangle表的PREROUTING链。这个链主要是用来修改报文的TOS、TTL以及给报文设置特殊的MARK。(注：通常mangle表以给报文设置MARK为主，在这个表里面，千万不要做过滤&#x2F;NAT&#x2F;伪装这类的事情)</li>
<li>5.进入nat表的PREROUTING链。这个链主要用来处理 DNAT，应该避免在这条链里面做过滤，否则可能造成有些报文会漏掉。(注：它只用来完成源&#x2F;目的地址的转换)</li>
<li>6.进入路由决定数据包的处理。例如决定报文是上本机还是转发或者其他地方。(注：此处假设报文交给本机处理)</li>
<li>7.进入mangle表的 INPUT 链。在把报文实际送给本机前，路由之后，我们可以再次修改报文。</li>
<li>8.进入filter表的 INPUT 链。在这儿我们对所有送往本机的报文进行过滤，要注意所有收到的并且目的地址为本机的报文都会经过这个链，而不管哪个接口进来的或者它往哪儿去。</li>
<li><ol start="9">
<li>进过规则过滤，报文交由本地进程或者应用程序处理，例如服务器或者客户端程序。<h5 id="2）本地主机发出报文"><a href="#2）本地主机发出报文" class="headerlink" title="2）本地主机发出报文"></a>2）本地主机发出报文</h5>数据包由本机发出时，其经过iptables的过程为：</li>
</ol>
</li>
<li>1.本地进程或者应用程序（例如服务器或者客户端程序）发出数据包。</li>
<li>2.路由选择，用哪个源地址以及从哪个接口上出去，当然还有其他一些必要的信息。</li>
<li>3.进入raw表的OUTPUT链。这里是能够在连接跟踪生效前处理报文的点，在这可以标记某个连接不被连接跟踪处理。</li>
<li>4.连接跟踪对本地的数据包进行处理。</li>
<li>5.进入 mangle 表的 OUTPUT 链，在这里我们可以修改数据包，但不要做过滤(以避免副作用)。</li>
<li>6.进入 nat 表的 OUTPUT 链，可以对防火墙自己发出的数据做目的NAT(DNAT) 。</li>
<li>7.进入 filter 表的 OUTPUT 链，可以对本地出去的数据包进行过滤。</li>
<li>8.再次进行路由决定，因为前面的 mangle 和 nat 表可能修改了报文的路由信息。</li>
<li>9.进入 mangle 表的 POSTROUTING 链。这条链可能被两种报文遍历，一种是转发的报文，另外就是本机产生的报文。</li>
<li>10.进入 nat 表的 POSTROUTING 链。在这我们做源 NAT（SNAT），建议你不要在这做报文过滤，因为有副作用。即使你设置了默认策略，一些报文也有可能溜过去。</li>
<li>11.进入出去的网络接口。<h5 id="3）转发报文"><a href="#3）转发报文" class="headerlink" title="3）转发报文"></a>3）转发报文</h5>报文经过iptables进入转发的过程为：</li>
<li>1.数据包从network到网卡</li>
<li>2.网卡接收到数据包后，进入raw表的PREROUTING链。这个链的作用是在连接跟踪之前处理报文，能够设置一条连接不被连接跟踪处理。(注：不要在raw表上添加其他规则)</li>
<li>3.如果设置了连接跟踪，则在这条连接上处理。</li>
<li>4.经过raw处理后，进入mangle表的PREROUTING链。这个链主要是用来修改报文的TOS、TTL以及给报文设置特殊的MARK。(注：通常mangle表以给报文设置MARK为主，在这个表里面，千万不要做过滤&#x2F;NAT&#x2F;伪装这类的事情)</li>
<li>5.进入nat表的PREROUTING链。这个链主要用来处理 DNAT，应该避免在这条链里面做过滤，否则可能造成有些报文会漏掉。(注：它只用来完成源&#x2F;目的地址的转换)</li>
<li>6.进入路由决定数据包的处理。例如决定报文是上本机还是转发或者其他地方。(注：此处假设报文进行转发)</li>
<li>7.进入 mangle 表的 FORWARD 链，这里也比较特殊，这是在第一次路由决定之后，在进行最后的路由决定之前，我们仍然可以对数据包进行某些修改。</li>
<li>8.进入 filter 表的 FORWARD 链，在这里我们可以对所有转发的数据包进行过滤。需要注意的是：经过这里的数据包是转发的，方向是双向的。</li>
<li>9.进入 mangle 表的 POSTROUTING 链，到这里已经做完了所有的路由决定，但数据包仍然在本地主机，我们还可以进行某些修改。</li>
<li>10.进入 nat 表的 POSTROUTING 链，在这里一般都是用来做 SNAT ，不要在这里进行过滤。</li>
<li>11.进入出去的网络接口。</li>
</ul>
<hr>
<p>iptables规则设置用法</p>
<p>1）iptables的基本语法格式<br>iptables [-t 表名] 命令选项 ［链名］ ［条件匹配］ ［-j 目标动作或跳转］<br>说明：<br>表名、链名：用于指定iptables命令所操作的表和链；<br>命令选项：用于指定管理iptables规则的方式（比如：插入、增加、删除、查看等；<br>条件匹配：用于指定对符合什么样 条件的数据包进行处理；<br>目标动作或跳转：用于指定数据包的处理方式（比如允许通过、拒绝、丢弃、跳转（Jump）给其它链处理。</p>
<p>2）iptables命令的管理控制选项<br>-A 在指定链的末尾添加（append）一条新的规则<br>-D 删除（delete）指定链中的某一条规则，可以按规则序号和内容删除<br>-I 在指定链中插入（insert）一条新的规则，默认在第一行添加<br>-R 修改、替换（replace）指定链中的某一条规则，可以按规则序号和内容替换<br>-L 列出（list）指定链中所有的规则进行查看（默认是filter表，如果列出nat表的规则需要添加-t，即iptables -t nat -L）<br>-E 重命名用户定义的链，不改变链本身<br>-F 清空（flush）<br>-N 新建（new-chain）一条用户自己定义的规则链<br>-X 删除指定表中用户自定义的规则链（delete-chain）<br>-P 设置指定链的默认策略（policy）<br>-Z 将所有表的所有链的字节和数据包计数器清零<br>-n 使用数字形式（numeric）显示输出结果<br>-v 查看规则表详细信息（verbose）的信息<br>-V 查看版本(version)<br>-h 获取帮助（help）</p>
<p>3）防火墙处理数据包的四种方式ACCEPT 允许数据包通过<br>DROP 直接丢弃数据包，不给任何回应信息<br>REJECT 拒绝数据包通过，必要时会给数据发送端一个响应的信息。<br>LOG在&#x2F;var&#x2F;log&#x2F;messages文件中记录日志信息，然后将数据包传递给下一条规则</p>
<p>4）iptables防火墙规则的保存与恢复<br>iptables-save把规则保存到文件中，再由目录rc.d下的脚本（&#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;iptables）自动装载<br>使用命令iptables-save来保存规则。<br>一般用：<br>iptables-save &gt; &#x2F;etc&#x2F;sysconfig&#x2F;iptables<br>生成保存规则的文件&#x2F;etc&#x2F;sysconfig&#x2F;iptables，<br>也可以用：<br>service iptables save<br>它能把规则自动保存在&#x2F;etc&#x2F;sysconfig&#x2F;iptables中。<br>当计算机启动时，rc.d下的脚本将用命令iptables-restore调用这个文件，从而就自动恢复了规则。</p>
<p>5）iptables防火墙常用的策略梳理<br>设置默认链策略<br>ptables的filter表中有三种链：INPUT, FORWARD和OUTPUT。<br>默认的链策略是ACCEPT，可以将它们设置成DROP，如下命令就将所有包都拒绝了：<br>iptables -P INPUT DROP<br>iptables -P FORWARD DROP<br>iptables -P OUTPUT DROP</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cachefish.github.io/2022/03/07/19-Type-and-Point/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="来世做春风，浪漫且自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cachecatのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/07/19-Type-and-Point/" class="post-title-link" itemprop="url">c++ 类型与指针</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-07 19:30:00 / 修改时间：10:13:50" itemprop="dateCreated datePublished" datetime="2022-03-07T19:30:00+08:00">2022-03-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-base/" itemprop="url" rel="index"><span itemprop="name">c++ base</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>对象、引用、函数(包括函数模板专门化)和表达式</p>
<h2 id="类型分类"><a href="#类型分类" class="headerlink" title="类型分类"></a>类型分类</h2><p>c++是一种强类型语言，也是一种静态类型语言;每个对象都有一个类型，这个类型永远不会改变。</p>
<h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>void (std::is_void)类型<br>std::nullptr_t(c++ 11) (std::is_null_pointer)</p>
<h3 id="算术类型-std-is-arithmetic"><a href="#算术类型-std-is-arithmetic" class="headerlink" title="算术类型(std:: is_arithmetic)"></a>算术类型(std:: is_arithmetic)</h3><ul>
<li><p>浮点类型(float, double, long      double以及它们的cv-qualified版本)(std::is_floating_point)</p>
</li>
<li><p>整型类型(包括cv-qualified的版本(std::is_integral)</p>
<ul>
<li>bool</li>
<li>字符类型:<ul>
<li>狭窄的性格类型:*<ul>
<li>普通字符类型(char, signed char, unsigned char)</li>
<li>char8_t类型(c++ 20)</li>
</ul>
</li>
<li>宽字符类型(char16_t(c++ 11)，char32_t（C++11），wchar_t）;有符号整型(short int, int, long int, long long int);无符号整型(Unsigned short int, Unsigned int, Unsigned long int, Unsigned long long int);</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><ul>
<li>引用类型(std:: is_reference):<ul>
<li><p>左值引用类型(std::is_lvalue_reference):</p>
<ul>
<li>左值引用作为对象类型</li>
<li>左值引用作为函数类型</li>
</ul>
</li>
<li><p>右值引用类型(std::is_rvalue_reference):</p>
<ul>
<li>右值引用作为对象类型</li>
<li>右值引用作为函数类型   </li>
<li></li>
</ul>
</li>
<li><p>指针类型(std::is_pointer)：</p>
<ul>
<li>指针作为对象类型</li>
<li>指针作为函数类型</li>
</ul>
</li>
<li><p>成员指针类型(std::is_member_pointer)</p>
<ul>
<li>pointer-to-data-member类型(std::is_member_object_pointer)* pointer-to-member-function类型(std::is_member_function_pointer)</li>
</ul>
</li>
<li><p>数组类型(std::is_array);</p>
</li>
<li><p>函数类型(std::is_function);</p>
</li>
<li><p>枚举类型(std::is_enum);</p>
</li>
<li><p>类类型:</p>
<ul>
<li>非联合体类型(std::is_class)</li>
<li>联合体类型(std::is_union)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Pointer"><a href="#Pointer" class="headerlink" title="Pointer"></a>Pointer</h2><p>Pointers to functions<br>指向函数的指针可以用非成员函数或静态成员函数的地址初始化。<br>由于函数到指针的隐式转换，address-of操作符是可选的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void f(int);        // function type</span><br><span class="line">void (*p1)(int) = &amp;f;//pointer-to-function type</span><br><span class="line">void (*p2)(int) = f; // same as &amp;f</span><br></pre></td></tr></table></figure>

<p>与函数或对函数的引用不同，函数的指针是对象，因此可以存储在数组、复制、赋值等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void (a[10])(int); // Error: array of functions</span><br><span class="line">void (&amp;a[10])(int); // Error: array of references</span><br><span class="line">void (*a[10])(int); // OK: array of pointers to functions</span><br></pre></td></tr></table></figure>
<p>涉及到函数指针的声明通常可以用类型别名来简化:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">using F = void(int);  // named type alias to simplify declarations</span><br><span class="line">F a[10];  // Error: array of functions</span><br><span class="line">F&amp; a[10]; // Error: array of references</span><br><span class="line">F* a[10]; // OK: array of pointers to functions</span><br></pre></td></tr></table></figure>
<p>解引用函数指针将产生标识被指向函数的左值:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int f();</span><br><span class="line">int (*p)() = f;  // pointer p is pointing to f</span><br><span class="line">int (&amp;r)() = *p; // the lvalue that identifies f is bound to a reference</span><br><span class="line">r();           // function f invoked through lvalue reference</span><br><span class="line">(*p)();        // function f invoked through the function lvalue</span><br><span class="line">p();           // function f invoked directly through the pointer</span><br></pre></td></tr></table></figure>

<h3 id="Pointers-to-data-members"><a href="#Pointers-to-data-members" class="headerlink" title="Pointers to data members"></a>Pointers to data members</h3><p>指向C类成员的非静态成员对象m的指针可以用表达式&amp;C::m进行精确初始化。像&amp;(C::m)或&amp;m这样的表达式在C的成员函数中不能形成指向成员的指针。</p>
<p>这样的指针可以用作指向成员的指针访问操作符的右操作数。<br>operator.* and operator-&gt;*: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct C &#123; int m; &#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">int C::* p = &amp;C::m;      // pointer to data member m of class C</span><br><span class="line">        C c = &#123;7&#125;;</span><br><span class="line">        std::cout &lt;&lt; c.*p &lt;&lt; &#x27;\n&#x27;;  // prints 7</span><br><span class="line">        C* cp = &amp;c;</span><br><span class="line">        cp-&gt;m = 10;</span><br><span class="line">        std::cout &lt;&lt; cp-&gt;*p &lt;&lt; &#x27;\n&#x27;; // prints 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Pointers-to-member-functions"><a href="#Pointers-to-member-functions" class="headerlink" title="Pointers to member functions"></a>Pointers to member functions</h3><p>指向C类成员的非静态成员函数f的指针可以用表达式&amp;C::f精确地初始化。像&amp;(C::f)或&amp;f这样的表达式在C的成员函数中不能形成指向成员函数的指针</p>
<p>这样的指针可以用作指向成员的指针访问操作符的右操作数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct C&#123;</span><br><span class="line">void f(int n) &#123; std::cout &lt;&lt; n &lt;&lt; &#x27;\n&#x27;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">   // pointer to member function f of class C</span><br><span class="line">   void (C::* p)(int) = &amp;C::f;</span><br><span class="line">   C c;</span><br><span class="line">   (c.*p)(1);                  // prints 1</span><br><span class="line">   C* cp = &amp;c;</span><br><span class="line">   (cp-&gt;*p)(2);                // prints 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="静态与动态类型"><a href="#静态与动态类型" class="headerlink" title="静态与动态类型"></a>静态与动态类型</h2><p>静态类型<br>由程序编译时分析产生的表达式的类型称为表达式的静态类型。静态类型在程序执行时不会改变。</p>
<p>动态类型<br>如果某些glvalue表达式引用了一个多态对象，那么它最派生的对象的类型被称为动态类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// given</span><br><span class="line">struct B &#123; virtual ~B() &#123;&#125; &#125;; // polymorphic type</span><br><span class="line">struct D: B &#123;&#125;; // polymorphic type</span><br><span class="line">D d; // most-derived object</span><br><span class="line">B* ptr = &amp;d;</span><br><span class="line">// the static type of (*ptr) is B</span><br><span class="line">// the dynamic type of (*ptr) is D</span><br></pre></td></tr></table></figure>

<h2 id="Typeid"><a href="#Typeid" class="headerlink" title="Typeid"></a>Typeid</h2><p>如果type是引用类型，则结果指向表示被引用类型的std::type_info对象。</p>
<h2 id="Type-traits"><a href="#Type-traits" class="headerlink" title="Type traits"></a>Type traits</h2><p>类型特征定义了一个基于编译时模板的接口，用于查询或修改类型的属性。</p>
<h4 id="算术类型-整型或浮点型"><a href="#算术类型-整型或浮点型" class="headerlink" title="算术类型:整型或浮点型"></a>算术类型:整型或浮点型</h4><h4 id="标量类型-算术、指针、成员指针、枚举或std-nullptr-t类型"><a href="#标量类型-算术、指针、成员指针、枚举或std-nullptr-t类型" class="headerlink" title="标量类型:算术、指针、成员指针、枚举或std::nullptr_t类型"></a>标量类型:算术、指针、成员指针、枚举或std::nullptr_t类型</h4><h4 id="不完整类型"><a href="#不完整类型" class="headerlink" title="不完整类型"></a>不完整类型</h4><ul>
<li>the type void(可能是cv限定的);</li>
<li>incompletely-defined对象类型<ul>
<li>已被指定(例如通过前向声明)但未定义的类类型;</li>
<li>未知界数组;</li>
<li>不完全类型的元素数组;</li>
<li>枚举类型，从声明点到确定其基础类型为止。<br>所有其他类型都是完整的。</li>
</ul>
</li>
</ul>
<h5 id="定义不完全的对象类型可以被补全"><a href="#定义不完全的对象类型可以被补全" class="headerlink" title="定义不完全的对象类型可以被补全:"></a>定义不完全的对象类型可以被补全:</h5><ul>
<li>一个类类型(例如类X)可能在一个翻译单元的某个点上是不完整的，然后在稍后完成;类型类X在这两点上是相同的类型:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct X;             // X is an incomplete type</span><br><span class="line">extern X* xp;         // xp is a pointer to an incomplete type</span><br><span class="line">void foo() &#123;</span><br><span class="line">  xp++;              // ill-formed: X is incomplete</span><br><span class="line">&#125;</span><br><span class="line">struct X &#123; int i; &#125;;  // now X is a complete type</span><br><span class="line">X x;</span><br><span class="line">void bar() &#123;</span><br><span class="line">  xp = &amp;x;            // OK: type is “pointer to X”</span><br><span class="line">  xp++;               // OK: X is complete</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>每个实现对基本类型大小的选择统称为数据模型。<br>四种数据模型被广泛接受:</p>
<p>32位系统:</p>
<ul>
<li>LP32或2&#x2F;4&#x2F;4 (int是16位，long和pointer是32位</li>
<li>)Win16 API</li>
<li>ILP32或4&#x2F;4&#x2F;4 (int、long和pointer是32位的);</li>
<li>Win32API</li>
<li>接口Unix和类Unix系统(Linux, macOS)</li>
</ul>
<p>64位系统:</p>
<ul>
<li>LLP64或4&#x2F;4&#x2F;8 (int和long是32位的，指针是64位的)</li>
<li>Win64 </li>
<li>APILP64或4&#x2F;8&#x2F;8 (int是32位，long和指针是64位)</li>
<li>Unix和类Unix系统(Linux, macOS)</li>
</ul>
<p>其他模式非常罕见。例如，ILP64 (8&#x2F;8&#x2F;8: int、long和pointer都是64位的)只出现在一些早期的64位Unix系统中(例如:UNICOS on Cray)。</p>
<p>long 在不同平台大小不一样<br>建议使用cstdint头文件中的类型定义。</p>
<h2 id="void类型"><a href="#void类型" class="headerlink" title="void类型"></a>void类型</h2><p>Void类型具有一组空值的类型。它是一个不完整类型(因此，不允许使用void类型的对象)。这里没有void数组，也没有对void的引用。但是，允许指向void的指针和返回类型void的函数(其他语言中的过程)。</p>
<h3 id="Nullptr"><a href="#Nullptr" class="headerlink" title="Nullptr"></a>Nullptr</h3><p>Defined in header <cstddef><br>typedef decltype(nullptr) nullptr_t;        (since C++11) </p>
<p>Std::nullptr_t是空指针字面量nullptr的类型。它是一种独特的类型，本身不是指针类型或指向成员类型的指针。它的值是空指针常量，可以隐式转换为任何指针和指向成员类型的指针</p>
<p>sizeof(std::nullptr_t) is equal to sizeof(void *). </p>
<p>为什么要使用nullptr而不是NULL或0：<br>1.avoids overload resolution surprises</p>
<p>2.improve code clarity, especially when auto variables are involved。<br>3.template type deduction deduce</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cachefish.github.io/2022/03/07/13-%E5%A0%86%E7%A0%B4%E5%9D%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="来世做春风，浪漫且自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cachecatのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/07/13-%E5%A0%86%E7%A0%B4%E5%9D%8F/" class="post-title-link" itemprop="url">c++ 堆破坏</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-07 19:30:00 / 修改时间：10:13:19" itemprop="dateCreated datePublished" datetime="2022-03-07T19:30:00+08:00">2022-03-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-base/" itemprop="url" rel="index"><span itemprop="name">c++ base</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="堆破坏原因"><a href="#堆破坏原因" class="headerlink" title="堆破坏原因"></a>堆破坏原因</h2><ol>
<li>缓冲区溢出(写入超出分配的内存)</li>
<li>Double free(将指针释放两次)</li>
<li>旧指针重用(在释放后重用指针)。</li>
</ol>
<p>对堆损坏进行故障排除的困难在于，例如，当线程损坏堆时，进程不会终止或抛出错误！只要不使用损坏的堆，进程就不会崩溃，但一旦线程尝试使用堆中损坏的内存块，进程就会崩溃！进程崩溃时我们所看到的导致崩溃的“罪魁祸首”线程实际上只是一个受害者线程！比如如果你new一个大小正常的内存失败，除非系统内存用完，否则一定是出现了堆破坏。<br>备注：<br>同一个进程的所有内存都是在同一个虚拟地址空间的，理论上任何存储期的变量的越界写都会对其它地址上的数据造成破坏，这些被破坏的数据可能是任何存储期的变量或程序内部数据结构（管理堆的元数据，调用栈的返回地址等）。</p>
<hr>
<h3 id="堆的结构"><a href="#堆的结构" class="headerlink" title="堆的结构"></a>堆的结构</h3><p>参考<a target="_blank" rel="noopener" href="https://os.51cto.com/art/202107/675085.htm%E3%80%82">https://os.51cto.com/art/202107/675085.htm。</a><br>以windows下的heap为例，linux下也是类似。<br>Windows Heap概述</p>
<ul>
<li>进程默认堆。每个进程启动的时候系统会创建一个默认堆。比如LocalAlloc或者GlobalAlloc也是从进程默认堆上分配内存。你也可以使用GetProcessHeap获取进程默认堆的句柄，然后根据用这个句柄去调用HeapAlloc达到在系统默认堆上分配内存的效果。</li>
<li>自建堆。这个泛指程序通过HeapCreate去创建的堆，然后利用HeapAlloc等API去操作堆。</li>
<li>C++编程中常用的是malloc和new去申请内存，这些由CRT库提供方法。而根据查看在VS2010之前(包含)，CRT库会使用HeapCreate去创建一个堆，供CRT库自己使用。在VS2015以后CRT库的实现，并不会再去创建一个单独的堆，而使用进程默认堆。<br>堆管理器是通过调用虚拟管理器的一些方法进行堆管理的实现，比如VirtualAlloc之类的函数。同样应用程序也可以直接使用VirtualAlloc之类的函数对内存进行使用。</li>
</ul>
<p>一个堆主要由若干个Segment(段)组成，每个Segment都是一段连续的空间，然后用双向链表串起来。而一般情况下，一开始只有一个Segment，然后在这个Segment上申请空间，叫做Heap Entry(堆块)。</p>
<p>应用程序申请的内存在Segment上叫做Entry(块)，他们是连续的，可以看到一个块一般具有：<br>·前置的元数据: 这里主要存储有当前块的大小，前一个块的大小，当前块的状态等。<br>·用户数据区: 这段内存才是用户申请并且使用的内存。当然这块数据可能比你申请的内存要大一些，因为32位下面最小的分配粒度是8字节。这也是为什么有时候程序有时候溢出了几个字符，好像也没有导致程序异常或者崩溃的原因。<br>·后置的元数据: 这个一般用于调试所用。一般发布的时候不会占用这块空间。</p>
<p>如果程序写的数据越界了，修改了元数据区域，会导致后续的分配或则释放内存出现崩溃；如果错误修改了用户数据，则访问这些数据的代码就会出错。由于崩溃在于受害者一方，所以我们需要借助工具在第一现场抓住破坏者。</p>
<h3 id="AddressSanitizer"><a href="#AddressSanitizer" class="headerlink" title="AddressSanitizer"></a>AddressSanitizer</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><strong>shadow bytes</strong><br>用1字节的shadow byte来描述 8字节的内存的可访问情况：<br>(1)0 表示所有8字节可以访问。<br>(2)1-7表示1-7字节可以访问<br>(3)负数是asan运行时用于汇报诊断信息的上下文，并且也表示所有字节都不能访问。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Shadow byte legend (one shadow byte represents 8 application bytes):</span><br><span class="line"> Addressable: 00</span><br><span class="line"> Partially addressable: 01 02 03 04 05 06 07 </span><br><span class="line"> Heap left redzone:      fa</span><br><span class="line"> Freed heap region:      fd</span><br><span class="line"> Stack left redzone:      f1</span><br><span class="line"> Stack mid redzone:      f2</span><br><span class="line"> Stack right redzone:     f3</span><br><span class="line"> Stack after return:       f5</span><br><span class="line"> Stack use after scope:    f8</span><br><span class="line"> Global redzone:         f9</span><br><span class="line"> Global init order:        f6</span><br><span class="line"> Poisoned by user:       f7</span><br><span class="line"> Container overflow:     fc</span><br><span class="line"> Array cookie:           ac</span><br><span class="line"> Intra object redzone:    bb</span><br><span class="line"> ASan internal:           fe</span><br><span class="line"> Left alloca redzone:     ca</span><br><span class="line"> Right alloca redzone:    cb</span><br><span class="line"> Shadow gap:            cc</span><br></pre></td></tr></table></figure>
<h4 id="用户地址和对应的shadow-bytes的映射关系"><a href="#用户地址和对应的shadow-bytes的映射关系" class="headerlink" title="用户地址和对应的shadow bytes的映射关系"></a>用户地址和对应的shadow bytes的映射关系</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">On x86:</span><br><span class="line">char shadow_byte_value = *((Your_Address &gt;&gt; 3) + 0x30000000)</span><br><span class="line"></span><br><span class="line">On x64:</span><br><span class="line">char shadow_byte_value = *((Your_Address &gt;&gt; 3) + _asan_runtime_assigned_offset)</span><br></pre></td></tr></table></figure>
<h4 id="红色区域-red-zone"><a href="#红色区域-red-zone" class="headerlink" title="红色区域(red zone)"></a>红色区域(red zone)</h4><p>红色区域表示不可以访问的内存，对应的shadow bytes为负数，用于检测非法访问。<br>●动态存储期变量：运行时库替换malloc和free函数，用替换后的malloc分配的内存会在返回给用户的内存前后都添加红色区域(red zones)。替换后的free释放内存时，并没有直接释放内存，而是将这些内存的shadows bytes都设置为负数，并且将这些内存放入隔离区延迟释放，这样就能检测访问销毁内存的代码了。<br>●自动存储期&#x2F;全局存储期&#x2F;线程存储变量：编译器会在这些变量的前后也安插上红色区域。</p>
<h4 id="检测代码"><a href="#检测代码" class="headerlink" title="检测代码"></a>检测代码</h4><p>使用asan编译的代码，当去读写一个内存时，编译器都产生了一些额外代码来做检测。<br>当访问8个字节时，伪代码如下：<br>ShadowAddr &#x3D; (Addr &gt;&gt; 3) + Offset;<br>if (*ShadowAddr !&#x3D; 0) {<br>ReportAndCrash(Addr);<br>}<br>当访问的字节数少于8时，伪代码如下（This is guaranteed by the fact that malloc returns 8-byte aligned chunks of memory）：<br>ShadowAddr &#x3D; (Addr &gt;&gt; 3) + Offset;<br>k &#x3D; *ShadowAddr;<br>if (k !&#x3D; 0 &amp;&amp; ((Addr &amp; 7) + AccessSize &gt; k)) {<br>    ReportAndCrash(Addr);<br>}</p>
<h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>sudo dnf install libasan</p>
<h4 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h4><p>使用&#x2F;fsanitize&#x3D;address编译选项编译可执行程序，动态库或静态库。正常运行程序，运行时检测到错误就会报告。错误信息可以在调试器或者控制台下展示，也可以存储到dump中用于事后分析。&#x2F;fsanitize&#x3D;address和所有优化级别兼容(例如，&#x2F;Od, &#x2F;O1, &#x2F;O2, &#x2F;O2 &#x2F;GL, and PGO)。</p>
<p>设置环境变量ASAN_SAVE_DUMPS&#x3D;as.dmp 再运行程序就会生成dump.<br>打开dump后也会看到和直接运行相同的诊断信息。</p>
<hr>
<h3 id="Linux-1"><a href="#Linux-1" class="headerlink" title="Linux"></a>Linux</h3><p>需要检测的模块(动态库,静态库,可执行程序）编译时加上编译选项-fsanitize&#x3D;address，<br>如果运行程序出现了如下提示” ASan runtime does not come first in initial library list; you should either link runtime to your application or manually preload it with LD_PRELOAD”，表明该可执行程序没有首先链接asan运行时,或没有通过LD_PRELOAD手动加载asan运行时。 </p>
<ul>
<li>首先链接asan运行时是指需要将libasan.so放在可执行程序需要链接的库的列表的第一项。（也就是放在最左边）。<br>比如链接选项如下需要将-lasan放在最左边</li>
</ul>
<p>-lasan -ltbb -lgtest -lconcurrencpp -lpthread -ldl</p>
<ul>
<li>通过LD_PRELOAD手动加载asan运行时是指按如下方式运行程序<br>LD_PRELOAD&#x3D;&#x2F;usr&#x2F;lib64&#x2F;libasan.so.6  your_exe</li>
</ul>
<p><strong>执行rpm -ql libasan 可显示libasan安装的位置</strong><br>[leo@x x86_64r]$ rpm -ql libasan<br>&#x2F;usr&#x2F;lib&#x2F;.build-id<br>&#x2F;usr&#x2F;lib&#x2F;.build-id&#x2F;6d&#x2F;582957f402989d215d83f393d10e2e06ab4eff<br>&#x2F;usr&#x2F;lib64&#x2F;libasan.so.6<br>&#x2F;usr&#x2F;lib64&#x2F;libasan.so.6.0.0</p>
<p><strong>产生dump</strong><br>在系统中开启core： ulimit -c unlimited<br>cat &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;core_pattern 查看core生成的位置<br>设置环境变量<br>export ASAN_OPTIONS&#x3D;abort_on_error&#x3D;1:disable_coredump&#x3D;0:unmap_shadow_on_exit&#x3D;1<br>然后运行程序</p>
<h4 id="可执行程序是否必须设置-fsanitize-x3D-address？"><a href="#可执行程序是否必须设置-fsanitize-x3D-address？" class="headerlink" title="可执行程序是否必须设置-fsanitize&#x3D;address？"></a>可执行程序是否必须设置-fsanitize&#x3D;address？</h4><p>下面罗列了待测试的静态库或动态库都设置了-fsanitize&#x3D;address，可执行程序不设置的情况下是否可以检测出内存问题：<br>●vs2019<br>◇运行时加载dll：可以。<br>◇编译时链接dll：可以。<br>◇静态库: 不可以。如果可执行程序如果设置了-fsanitize&#x3D;address，也是可以检测的。<br>●g++ 11<br>◇运行时加载dll：可执行程序可以不指定-fsanitize&#x3D;address，但必须满足”ASan runtime must come first in initial library list; you should either link runtime to your application or manually preload it with LD_PRELOAD”。<br>◇编译时链接dll：同上。<br>◇静态库：可执行程序可以不指定-fsanitize&#x3D;address，但必须首先链接libasan,否则链接错误。<br>在有条件的情况下，建议所有模块都设置-fsanitize&#x3D;address，包括可执行程序。</p>
<p>检测的错误示例<br>加了-fsanitize&#x3D;address编译选项，vs2019,g++11默认都是可以检测内存泄露问题的</p>
<p><strong>heap-buffer-overflow</strong></p>
<ul>
<li>数组下标越界<ul>
<li>往前越界</li>
</ul>
</li>
<li>strncat越界<ul>
<li>错误原因：strncat一定会在目标结尾加0</li>
</ul>
</li>
<li>strncpy越界<ul>
<li>错误原因：dest未以0结尾，strncpy读取越界。</li>
</ul>
</li>
</ul>
<p><strong>heap-use-after-free</strong><br><strong>double-free</strong><br><strong>alloc-dealloc-mismatch</strong><br>alloc&#x2F;dealloc mismatch 检测在windows下默认关闭的，linux下默认开启的。windows下需要设置环境变量ASAN_OPTIONS&#x3D;alloc_dealloc_mismatch&#x3D;1来开启。<br>在控制台执行set ASAN_OPTIONS&#x3D;alloc_dealloc_mismatch&#x3D;1 </p>
<p><strong>new-delete-type-mismatch</strong><br>当释放的指针为基类类型，但基类没有虚析构，就会提示这个错误。<br>这种情况不会调用子类的析构，从而也不会调用子类数据成员的析构，造成内存泄露。如果子类自己和其数据成员都不需要通过析构函数执行内存回收，是不会造成内存泄露的。</p>
<p><strong>stack-buffer-overflow</strong><br>和堆溢出的例子类似，只是变量是在栈上分配的。<br><strong>stack-buffer-underflow</strong><br>访问了栈变量之前的错误内存地址。</p>
<p><strong>stack-use-after-return</strong><br>vs2019:<br>默认关闭，需要设置编译选项&#x2F;fsanitize-address-use-after-return打开, 运行时需要设置环境变量 ASAN_OPTIONS&#x3D;detect_stack_use_after_return&#x3D;1.（ msdn上说只要编译时打开了，即使运行时没有设置环境变量，产生的代码都会变慢。）<br>gcc11<br>编译时默认打开，运行时需要设置环境变量 ASAN_OPTIONS&#x3D;detect_stack_use_after_return&#x3D;1。</p>
<p><strong>stack-use-after-scope</strong></p>
<p><strong>global-buffer-overflow</strong></p>
<p><strong>memcpy-param-overlap</strong><br>Memcpy不支持重叠内存。memcpy的另一个支持重叠内存的替代方案:memmove</p>
<p><strong>strncat-param-overlap</strong><br>strcat， strncat也不支持源和目标重叠。</p>
<h3 id="协程的栈变量"><a href="#协程的栈变量" class="headerlink" title="协程的栈变量"></a>协程的栈变量</h3><p>栈变量越界访问在g++11和 vc2019下无法检测，不过堆越界可以检测。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">co::result&lt;void&gt; co_fun() &#123;</span><br><span class="line">int v[3];</span><br><span class="line">     v[3] = 1;</span><br><span class="line">     co::result_promise&lt;int&gt; promise;</span><br><span class="line">     auto result = promise.get_result();</span><br><span class="line">     std::cout &lt;&lt; this_thread::get_id() &lt;&lt; endl;</span><br><span class="line">     thread t([p = move(promise)]()mutable&#123;p.set_result(1);&#125;);</span><br><span class="line">     co_await result;</span><br><span class="line">     std::cout &lt;&lt; endl &lt;&lt; this_thread::get_id() &lt;&lt; endl;</span><br><span class="line">     int v2[3];</span><br><span class="line">     v2[3] = 1;</span><br><span class="line">     fun_s_1(&quot;co_fun&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="避免内存错误的防御式编程"><a href="#避免内存错误的防御式编程" class="headerlink" title="避免内存错误的防御式编程"></a>避免内存错误的防御式编程</h3><p><strong>典型错误原因：</strong></p>
<ol>
<li>数组越界</li>
<li>字符串0结尾问题(1.字符串未以0结尾，2.把非字符串当作字符串进行操作）</li>
<li>内存忘记释放</li>
<li>内存多次释放</li>
<li>memcpy, strcat, strcpy等函数的误用</li>
<li>基类未写虚析构，导致内存泄露 （基类都写上虚析构）</li>
<li>返回了销毁栈变量的地址或引用(相信理解了栈变量的生命期就不会这样写了)</li>
</ol>
<p><strong>数组越界问题</strong></p>
<ol>
<li>使用下标访问数组前一定检测下标范围是否越界。</li>
<li>循环时注意边界<br> const int num &#x3D; 3;<br> int a[num]{};<br> for (size_t i &#x3D; 0; i &lt;&#x3D; num; i++){ &#x2F;&#x2F; 应当 i &lt; num<br>  a[i] &#x3D; i + 2;<br> }</li>
<li>使用std::array和std::vector<br>std::array 替代编译期已知大小数组<br>std::vector替代运行时指定大小的数组<br>&#x3D;&#x3D;■std::array&#x3D;&#x3D;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">std::array&lt;char, 6&gt; data = &#123; 1, 2, 4, 5, 5, 6 &#125;;</span><br><span class="line">    data.at(1) = 88;// Set element 1</span><br><span class="line">    // Read element 2</span><br><span class="line"> std::cout &lt;&lt; &quot;index 2 has value &quot; &lt;&lt; data.at(2) &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">    std::cout &lt;&lt; &quot;data size = &quot; &lt;&lt; data.size() &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">    try &#123;</span><br><span class="line">        // Set element 6</span><br><span class="line">        data.at(6) = 666;</span><br><span class="line">    &#125; catch (std::out_of_range const&amp; exc) &#123;</span><br><span class="line">        std::cout &lt;&lt; exc.what() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // Print final values</span><br><span class="line">    std::cout &lt;&lt; &quot;data:&quot;;</span><br><span class="line">    for (auto elem : data) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot; &quot; &lt;&lt; elem;</span><br><span class="line">    &#125;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">char data2[6];</span><br><span class="line">int len = std::min(data.size(), sizeof(data2));</span><br><span class="line">memcpy(data2, data.data(), len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这个容器是一个聚合类型，它的语义与一个结构体相同，该结构体将c风格数组T[N]作为其唯一的非静态数据成员。与c风格的数组不同，它不会自动衰减为T*。作为一个聚合类型，它可以通过给定的最多N个初始化式进行初始化，这些初始化式可以转换为T: std::array&lt;int, 3&gt; a =&#123;1,2,3&#125;;。</span><br><span class="line">该结构结合了c风格数组的性能和可访问性，以及标准容器的优点，例如知道自己的大小、支持赋值、随机访问迭代器等。</span><br></pre></td></tr></table></figure>
■&#x3D;&#x3D;vector&#x3D;&#x3D;<br>用vector<T> 来达到 new T[n]的效果, 需要使用如下构造函数。<br>constexpr explicit vector( size_type count, const Allocator&amp; alloc &#x3D; Allocator() );</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void f(int num) &#123;</span><br><span class="line">    if (num &lt;= 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    std::vector&lt;char&gt; d1(num);</span><br><span class="line">    int i = 0;</span><br><span class="line">    for (auto&amp; e : d1)&#123;</span><br><span class="line">        e = i++ + &#x27;a&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    try&#123;</span><br><span class="line">        // Set element 6</span><br><span class="line">        d1.at(num) = 666;</span><br><span class="line">    &#125; catch (std::out_of_range const&amp; exc)&#123;</span><br><span class="line">        std::cout &lt;&lt; exc.what() &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    for (auto e : d1)&#123;</span><br><span class="line">        std::cout &lt;&lt; &quot; &quot; &lt;&lt; e;</span><br><span class="line">    &#125;</span><br><span class="line">std::vector&lt;char&gt; d2(4);</span><br><span class="line">int len = std::min(d2.size(), d1.size());</span><br><span class="line">    memcpy(d2.data(), d1.data(), len));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不使用C风格字符串及相关C函数，使用std::string -&gt; 避免问题2<br>如果使用std::string就不用考虑这些问题<br>std::string msg1(“hello string”);<br>std::string msg2 &#x3D; msg1;<br>std::string msg3 &#x3D; msg2;<br>备注：如果非要使用c字符串，请始终确保都以0结尾。<br>不使用裸指针，使用智能指针-&gt;避免问题3,4</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char* argv[])&#123;</span><br><span class="line">auto data1 = make_shared&lt;array&lt;char, 100&gt;&gt;(); //需要传递到其它地方</span><br><span class="line">    for (auto e : *data1)&#123;</span><br><span class="line">        std::cout &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">auto data2 = make_unique&lt;vector&lt;char&gt;&gt;(100);//自己使用</span><br><span class="line">    for (auto e : *data2)&#123;</span><br><span class="line">        std::cout &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#x3D;&#x3D;memcpy, strcat, strcpy等函数的误用&#x3D;&#x3D;<br>● void *memcpy(void *dest, const void *src, size_t n)<br>1.注意源和目标不能重叠，如果为同一个请用memmove.<br>2.注意源和目标长度都要大于等于n. </p>
<p>● char * strcat(char *dest, const char *src) (不建议使用）<br>1.注意源和目标不能重叠。<br>2.源必须要以0结尾，否则会访问越界<br>3.总会给目标加上结尾的0,所以要确保目标不小于strlen(dest)+strlen(src)+1</p>
<p>● char * strncat(char *dest, const char *src, size_t n);<br>1.注意源和目标不能为同一个buffer<br>2.如果源长度大于等于n,可以不以0结尾，否则必须以0结尾不然会访问越界。<br>4.总会给目标加上结尾的0,所以要确保目标不小于strlen(dest)+n+1</p>
<p>● char *strcpy(char *dest, const char *src);(不建议使用）<br>1.注意源和目标不能重叠<br>2.源必须以0结尾，否则会访问越界<br>3.目标长度必须大于等于strlen(src)+1</p>
<p>● char *strncpy(char *dest, const char *src, size_t n);<br>1.注意源和目标不能重叠<br>2.如果源的长度大于等于n，那么最终的dest将不会以0结尾。<br> char src[] &#x3D; “hello”;<br> char dest[3];<br> strncpy(dest, src, 3); &#x2F;&#x2F;dest[2]为l，非0<br>3.如果源的长度小于n，源必须以0结尾，否则源会访问越界，并且目标会被写入额外的多个0补足到n个字节。<br>char src[] &#x3D; “hello”;<br> char dest[10];<br> strncpy(dest, src, 10); &#x2F;&#x2F;dest[5] 到 dest[9]都为0<br>4.目标长度不能小于n。<br>所以为了保证dest一定以0结尾，通常按照如下方式编码：<br>strncpy(dest, str, dest_len - 1);<br>dest[dest_len - 1] &#x3D; 0;</p>
<p>● int snprintf(char *str, size_t size, const char *format, …);<br>The functions snprintf() write at most size bytes (including the terminating null byte (‘\0’)) to str.<br>snprintf总会给目标buffer加上结尾的0的，如下代码b[2]为0.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char b[3];</span><br><span class="line">snprintf(b, 3, &quot;%s&quot;, &quot;hello&quot;);</span><br></pre></td></tr></table></figure>
<p>&#x3D;&#x3D;总结，字符串c函数一定要明确对结尾0的处理方式，每个函数都不一样， 使用前应当详细阅读函数的使用说明。&#x3D;&#x3D;<br>检测工具对比<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/jinzhuojun/article/details/46659155">https://blog.csdn.net/jinzhuojun/article/details/46659155</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cachefish.github.io/2022/03/07/18-Object-and-variable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="来世做春风，浪漫且自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cachecatのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/07/18-Object-and-variable/" class="post-title-link" itemprop="url">c++ Object</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-07 19:30:00 / 修改时间：10:13:46" itemprop="dateCreated datePublished" datetime="2022-03-07T19:30:00+08:00">2022-03-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-base/" itemprop="url" rel="index"><span itemprop="name">c++ base</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ol>
<li>当隐式更改联合的成员或创建临时对象时，对象由定义、新表达式创建。</li>
<li>物体在其建造期间、整个生命周期和销毁期间都占有存储区域。(函数不是对象，不管它是否像对象那样占用存储空间。)</li>
<li>对象具有影响其生存期的存储持续时间。</li>
<li>对象可以有名称。</li>
<li>对象具有类型。 </li>
<li>对象有一个值。</li>
<li>对象有对齐要求</li>
</ol>
<h3 id="以下实体不是对象"><a href="#以下实体不是对象" class="headerlink" title="以下实体不是对象"></a>以下实体不是对象</h3><p>值、引用、函数、枚举器、类型、非静态类成员、模板、类或函数模板特化、名称空间、参数包等等。</p>
<p>为何引用不是对象？<br>例子中引用ra的地址和a的地址一样。</p>
<p>为何函数不是对象？<br>函数没有生命期，不会被销毁。</p>
<h2 id="Alignment"><a href="#Alignment" class="headerlink" title="Alignment"></a>Alignment</h2><p>每种对象的类型都有一个对齐量（always a power of 2)，表示这种类型的对象的空间需要在对齐量的倍数的地址上进行分配。<br>为了满足类的非静态成员的对齐要求，成员间可能会插入一些填充空间。整个类的对齐量为非静态数据成员的最大对齐量，并且整个类的大小要为非静态数据成员的最大对齐量的倍数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cout&lt;&lt; sizeof(char) &lt;&lt;&quot; &quot; &lt;&lt; alignof(char) &lt;&lt;endl;  1 1</span><br><span class="line">cout &lt;&lt; sizeof(short)&lt;&lt;&quot; &quot; &lt;&lt;alignof(short)&lt;&lt;endl;  2 2</span><br><span class="line">cout&lt;&lt;sizeof(int) &lt;&lt;&quot; &quot; &lt;&lt;alignof(int) &lt;&lt; endl;     4 4</span><br><span class="line">cout &lt;&lt; sizeof(float) &lt;&lt;&quot; &quot;&lt;&lt;alignof(float) &lt;&lt;endl; 4 4</span><br><span class="line">cout &lt;&lt; sizeof(double) &lt;&lt;&quot; &quot; &lt;&lt; alignof(double) &lt;&lt;endl; 8 8</span><br><span class="line">cout &lt;&lt; sizeof(int*) &lt;&lt;&quot; &quot;&lt;&lt;alignof(int *) &lt;&lt;endl;  8 8</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最大对齐量<br>每个编译环境都有一个最大对齐量，可以通过pragma pack改变这个最大对齐量。<br>每种类型的实际对齐量为自身对齐量和最大对齐量之小值。</p>
<p>#pragma pack<br>This family of pragmas control the maximum alignment for subsequently defined class and union members.wpragma pack(arg)<br>#pragma pack()<br>#pragma pack(push)<br>#pragma pack(push，arg)<br>pragma pack(pop)        </p>
<p>其中arg是2的小幂，指定以字节为单位的新对齐方式。<br>1)设置当前对齐为value arg。<br>2)设置当前对齐方式为默认值(由命令行选项指定)。<br>将当前对齐的值推送到内部堆栈上。<br>4)将当前对齐方式的值推送到内部堆栈上，然后将当前对齐方式设置为value arg。<br>5)从内部堆栈弹出顶部条目，然后设置(恢复)当前对齐的值。<br>#pragma pack可能会减少类的对齐，但是，它不能使类overaligned。</p>
<p>每种类型的实际对齐量为自身对齐量和最大对齐量之小值。</p>
<p>理解了对齐原理可以合理安排类成员顺序，节省空间，以及理解为何会因为不对齐会在一些架构上性能差或者段错误。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量是通过引用或者对象的申明引入，非静态数据成员不是变量。变量就是代码中访问对象和引用的一个媒介，变量本身并不暂用任何空间。</p>
<h3 id="非静态数据成员不是变量-is-data-member"><a href="#非静态数据成员不是变量-is-data-member" class="headerlink" title="非静态数据成员不是变量  is data member"></a>非静态数据成员不是变量  is data member</h3><p>class A{<br>public:<br>    int&amp; a;          &#x2F;&#x2F;不是变量, is data member<br>    int b;               &#x2F;&#x2F;不是变量<br>    static int sa;     &#x2F;&#x2F;变量<br>    static int&amp; sb;   &#x2F;&#x2F;变量<br>};<br>可以A::sa, A::sb访问, 但不可以使用A::a, A::b<br>类的非静态数据成员没有创建新的变量，它只是帮助你定义类的属性，如果它是变量, 就可以使用A::a &#x3D; 3访问，显然这是不可以的。</p>
<p>定义一个函数变量？<br>下面的例子中虽然可以声明ft f1; 但无法初始化f1，这个”变量”无法代表任何实体。<br>通过上面变量的定义，也可以看出函数不是一个对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void f()&#123;&#125;;</span><br><span class="line">TEST(function,2)&#123;</span><br><span class="line">    using ft = void();</span><br><span class="line">    ft f1 = f;   //error</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>在c++程序中出现的每个名称只在源代码中称为其作用域的一些可能不连续的部分中可见。为啥会出现不连续：比如中间可能会出现嵌套的块，导致外层块中的名字暂时不可见了。</p>
<h3 id="块范围"><a href="#块范围" class="headerlink" title="块范围"></a>块范围</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在块(复合语句)中声明的名称的潜在作用域从声明点开始，到块的末尾结束。实际作用域与潜在作用域相同，除非在嵌套块中声明了相同的名称</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int i = 0; // scope of outer i begins</span><br><span class="line">    ++i; // outer i is in scope</span><br><span class="line">    &#123;</span><br><span class="line">        int i = 1; // scope of inner i begins,</span><br><span class="line">                   // scope of outer i pauses</span><br><span class="line">        i = 42; // inner i is in scope</span><br><span class="line">    &#125; // block ends, scope of inner i ends,</span><br><span class="line">      // scope of outer i resumes</span><br><span class="line">&#125; // block ends, scope of outer i ends</span><br><span class="line">//int j = i; // error: i is not in scope</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">在异常处理程序中声明的名称的潜在作用域从声明点开始，在异常处理程序的末尾结束，并且不在另一个异常处理程序的作用域或封闭块中。</span><br><span class="line">try &#123;</span><br><span class="line">    f();</span><br><span class="line">&#125; catch (const std::runtime_error&amp; re) &#123;</span><br><span class="line">// scope of re begins</span><br><span class="line">    int n = 1; // scope of n begins</span><br><span class="line">    std::cout &lt;&lt; n &lt;&lt; re.what(); // re is in scope</span><br><span class="line">&#125; // scope of re ends, scope of n ends</span><br><span class="line">catch (std::exception&amp; e) &#123;</span><br><span class="line">//  std::cout &lt;&lt; re.what(); // error: re is not in scope</span><br><span class="line">//  ++n; // error: n is not in scope</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">潜在范围中声明一个名字 for循环,条件的for循环,range_declaration的范围循环,init-statement的if语句或switch语句(c++ 17),在if语句的条件,switch语句,或者while循环从声明点开始，在受控语句的末尾结束。</span><br><span class="line">Base* bp = new Derived;</span><br><span class="line">if (Derived* dp = dynamic_cast&lt;Derived*&gt;(bp)) &#123;</span><br><span class="line">    dp-&gt;f(); // dp is in scope</span><br><span class="line">&#125; // scope of dp ends</span><br><span class="line"></span><br><span class="line">for (int n = 0; // scope of n begins</span><br><span class="line">     n &lt; 10; // n is in scope</span><br><span class="line">     ++n)    // n is in scope</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; n &lt;&lt; &#x27; &#x27;; // n is in scope</span><br><span class="line">&#125; // scope of n ends</span><br></pre></td></tr></table></figure>
<h2 id="Function-parameter-scope"><a href="#Function-parameter-scope" class="headerlink" title="Function parameter scope"></a>Function parameter scope</h2><p>函数参数(包括lambda表达式的参数)或函数局部预定义变量中声明的名称的潜在作用域从声明点开始。<br>如果封闭的函数声明符不是函数定义的声明符，那么它的潜在作用域将在该函数声明符的末尾结束。<br>否则，它的潜在作用域结束在函数try块的最后一个异常处理程序的末尾，或者如果函数try块没有被使用，则结束在函数体的末尾</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">const int n = 3;</span><br><span class="line"> </span><br><span class="line">int f1(</span><br><span class="line">    int n // scope of function parameter n begins,</span><br><span class="line">          // scope of global n pauses</span><br><span class="line">//int y = n // error: default argument references a function parameter</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">int (*(*f2)(int n))[n]; // OK: scope of function parameter n</span><br><span class="line">                        // ends at the end of its function declarator</span><br><span class="line">                        // in the array declarator, global n is in scope</span><br><span class="line">// declares a pointer to function returning a pointer to an array of 3 int</span><br><span class="line"> </span><br><span class="line">//auto (*f3)(int n)-&gt;int (*)[n]; // error: function parameter n as array bound</span><br><span class="line"> </span><br><span class="line">void f(int n = 2) // scope of function parameter n begins</span><br><span class="line">try // function try block</span><br><span class="line">&#123; // function body begins</span><br><span class="line">    ++n; // function parameter n is in scope</span><br><span class="line">    &#123;</span><br><span class="line">        int n = 2; // scope of local n begins</span><br><span class="line">                   // scope of function parameter n pauses</span><br><span class="line">        ++n; // local n is in scope</span><br><span class="line">    &#125; // scope of local n ends</span><br><span class="line">      // scope of function parameter n resumes</span><br><span class="line">&#125; catch (std::exception&amp; e) &#123;</span><br><span class="line">    ++n; // function parameter n is in scope</span><br><span class="line">    throw;</span><br><span class="line">&#125; // last exception handler ends, scope of function parameter n ends</span><br><span class="line"> </span><br><span class="line">int a = n; // global n is in scope</span><br></pre></td></tr></table></figure>

<p>__func__应由编译器隐式声明，就好像紧跟在每个函数定义的大括号之后，声明static const char <strong>func</strong>[] &#x3D; “function-name”;出现，其中function-name是函数的名称。</p>
<h2 id="Namespace-scope"><a href="#Namespace-scope" class="headerlink" title="Namespace scope"></a>Namespace scope</h2><p>在一个名称空间中声明的名字开始,包括其余的名称空间和名称空间定义一个相同的名称空间的名字,另外,对于任何使用指示介绍这个名称或其整个名称空间到另一个范围,剩下的范围。翻译单元的顶级作用域(“文件作用域”或“全局作用域”)也是一个命名空间，正确地称为“全局命名空间作用域”。在全局命名空间作用域中声明的名称的潜在作用域从声明点开始，到结束点结束</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">namespace N &#123; // scope of N begins (as a member of global namespace)</span><br><span class="line">    int i; // scope of i begins</span><br><span class="line">    int g(int a) &#123; return a; &#125; // scope of g begins</span><br><span class="line">    int j(); // scope of j begins</span><br><span class="line">    void q(); // scope of q begins</span><br><span class="line">    namespace &#123;</span><br><span class="line">        int x; // scope of x begins</span><br><span class="line">    &#125; // scope of x continues (member of unnamed namespace)</span><br><span class="line">    inline namespace inl &#123; // scope of inl begins</span><br><span class="line">        int y; // scope of y begins</span><br><span class="line">    &#125; // scope of y continues (member of inline namespace)</span><br><span class="line">&#125; // scopes of i, g, j, q, inl, x, and y pause</span><br><span class="line"> </span><br><span class="line">namespace &#123;</span><br><span class="line">    int l = 1; // scope of l begins</span><br><span class="line">&#125; // scope of l continues (member of unnamed namespace)</span><br><span class="line"> </span><br><span class="line">namespace N &#123; // scopes of i, g, j, q, inl, x, and y resume</span><br><span class="line">    int g(char a) &#123; // overloads N::g(int)</span><br><span class="line">        return l + a; // l from unnamed namespace is in scope</span><br><span class="line">    &#125;</span><br><span class="line">//  int i; // error: duplicate definition (i is already in scope)</span><br><span class="line">    int j(); // OK: duplicate function declaration is allowed</span><br><span class="line">    int j() &#123; // OK: definition of the earlier-declared N::j()</span><br><span class="line">        return g(i); // calls N::g(int)</span><br><span class="line">    &#125;</span><br><span class="line">//  int q(); // error: q is already in scope with a different return type</span><br><span class="line">&#125; // scopes of i, g, j, q, inl, x, and y pause</span><br><span class="line"> </span><br><span class="line">int main() &#123;</span><br><span class="line">    using namespace N; // scopes of i, g, j, q, inl, x, and y resume</span><br><span class="line">    i = 1; // N::i is in scope</span><br><span class="line">    x = 1; // N::(anonymous)::x is in scope</span><br><span class="line">    y = 1; // N::inl::y is in scope</span><br><span class="line">    inl::y = 2; // N::inl is also in scope</span><br><span class="line">&#125; // scopes of i, g, j, q, inl, x, and y end</span><br></pre></td></tr></table></figure>

<h2 id="Class-scope"><a href="#Class-scope" class="headerlink" title="Class scope"></a>Class scope</h2><p>声明一个类名称开始,包括其他类,所有的派生类,函数体(即使定义在类定义或声明前的名字),默认参数的函数,函数异常规格(异常规格被用于指出一个函数能抛出什么样的异常。),类内的括号或相等的初始化式，以及嵌套类中的所有这些东西，都是递归的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct X &#123;</span><br><span class="line">    int f(int a = n) &#123; // n is in scope in function default argument</span><br><span class="line">         return a * n;  // n is in scope in function body</span><br><span class="line">    &#125;</span><br><span class="line">    using r = int;</span><br><span class="line">    r g();</span><br><span class="line">    int i = n * 2; // n is in scope in initializer</span><br><span class="line">//int x[n]; // error: n is not in scope in class body</span><br><span class="line">    static const int n = 1; // scope of n begins</span><br><span class="line">    int x[n]; // OK: n is now in scope in class body</span><br><span class="line">&#125;; // scope of n pauses</span><br><span class="line"> </span><br><span class="line">struct Y: X &#123; // scope of n resumes</span><br><span class="line">     int y[n]; // n is in scope</span><br><span class="line">&#125;; // scope of n ends</span><br><span class="line"> </span><br><span class="line">//r X::g() &#123;// error: r is not in scope outside</span><br><span class="line">// out-of-class function body</span><br><span class="line">auto X::g()-&gt;r &#123; // OK: trailing return type r is in scope</span><br><span class="line">     return n;// n is in scope in out-of-class function body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Enumeration-scope"><a href="#Enumeration-scope" class="headerlink" title="Enumeration scope"></a>Enumeration scope</h2><p>未作用域枚举的枚举数的潜在作用域从声明点开始，并在封闭作用域的末尾结束。<br>有作用域的枚举的枚举数的潜在作用域从声明点开始，到枚举说明符的末尾结束。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">enum e1_t &#123; // unscoped enumeration</span><br><span class="line">    A,</span><br><span class="line">    B = A * 2 // A is in scope</span><br><span class="line">&#125;; // scopes of A and B continue</span><br><span class="line"> </span><br><span class="line">enum class e2_t &#123; // scoped enumeration</span><br><span class="line">    SA,</span><br><span class="line">    SB = SA * 2 // SA is in scope</span><br><span class="line">&#125;; // scopes of SA and SB end</span><br><span class="line"> </span><br><span class="line">e1_t e1 = B; // OK: B is in scope</span><br><span class="line">//e2_t e2 = SB; // error: SB is not in scope</span><br><span class="line">e2_t e2 = e2_t::SB; // OK</span><br></pre></td></tr></table></figure>
<h2 id="Template-parameter-scope"><a href="#Template-parameter-scope" class="headerlink" title="Template parameter scope"></a>Template parameter scope</h2><p>模板形参名的潜在作用域从声明点开始，在引入它的最小模板声明的末尾结束。特别是，模板形参可以用于后续模板形参的声明和基类的规范中，但不能用于前面模板形参的声明中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;</span><br><span class="line">    typename T, // scope of T begins</span><br><span class="line">    T* p,       // T is in scope</span><br><span class="line">    class U = T // T is in scope</span><br><span class="line">&gt;</span><br><span class="line">class X: public std::vector&lt;T&gt; // T is in scope</span><br><span class="line">&#123;</span><br><span class="line">    T f(); // T is in scope</span><br><span class="line">&#125;; // scopes of T and U end</span><br></pre></td></tr></table></figure>
<p>模板模板形参的形参名称的潜在作用域是该名称出现在其中的最小模板形参列表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">template&lt;</span><br><span class="line">    template&lt; // template template parameter</span><br><span class="line">        typename Y,    // scope of Y begins</span><br><span class="line">        typename G = Y // Y is in scope</span><br><span class="line">    &gt; // scopes of Y and G end</span><br><span class="line">    class T,</span><br><span class="line">//  typename U = Y // error: Y is not in scope</span><br><span class="line">    typename U</span><br><span class="line">&gt;</span><br><span class="line">class X &#123;</span><br><span class="line">&#125;; // scopes of T and U end</span><br></pre></td></tr></table></figure>
<p>与其他嵌套作用域类似，模板形参的名称在其自身存在期间将该名称隐藏在封闭作用域之外。typedef int N;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;</span><br><span class="line">    N X, // ::N is in scope</span><br><span class="line">    typename N, // scope of N begins, scope of ::N pauses</span><br><span class="line">    template&lt;N Y&gt; class T // N is in scope</span><br><span class="line">&gt;</span><br><span class="line">struct A; // scope of N ends, scope of ::N resumes</span><br></pre></td></tr></table></figure>

<h2 id="Point-of-declaration"><a href="#Point-of-declaration" class="headerlink" title="Point of declaration"></a>Point of declaration</h2><p>一般来说，名称在其第一次声明的所在地之后可见，其位置如下。<br>在简单声明中声明的名称的轨迹紧跟在该名称的声明符之后，如果有的话，则在其初始化式之前。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">unsigned char x = 32; // outer x is in scope</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char x = x; // inner x is in scope before the initializer (= x)</span><br><span class="line">                        // this does not initialize inner x with the value of outer x,</span><br><span class="line">                       // this initializes inner x with its own,indeterminate, value</span><br><span class="line">&#125;</span><br><span class="line">std::function&lt;int(int)&gt; f = [&amp;](int n)&#123; return n &gt; 1 ? n * f(n - 1) : n; &#125;;</span><br><span class="line">// the name of the function f is in scope in the lambda and can</span><br><span class="line">// be correctly captured by reference, giving a recursive function</span><br><span class="line"></span><br><span class="line">const int x = 2; // outer x is in scope</span><br><span class="line">&#123;</span><br><span class="line">    int x[x] = &#123;&#125;; // inner x is in scope before the initializer (= &#123;&#125;),</span><br><span class="line">                   // but after the declarator (x[x])</span><br><span class="line">                   // in the declarator, outer x is still in scope</span><br><span class="line">                   // this declares an array of 2 int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类或类模板声明的轨迹紧跟在类头中命名类的标识符(或命名模板特化的模板id)之后。类或类模板名已经在基类列表的作用域中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct S: std::enable_shared_from_this&lt;S&gt; // S is in scope at the colon</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>枚举说明符或不透明枚举声明的位置紧跟在命名枚举的标识符之后。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum E: int &#123; // E is in scope at the colon</span><br><span class="line">        A = sizeof(E)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="存储期-Storage-duration"><a href="#存储期-Storage-duration" class="headerlink" title="存储期(Storage duration)"></a>存储期(Storage duration)</h2><p>程序中的所有对象都具有下列存储期之一（存储期指的是对象的存储空间何时分配和销毁）：</p>
<ul>
<li>自动（automatic）存储期。这类对象的存储在代码块（block）开始时分配，并在结束时释放。未声明为 static、extern 或 thread_local 的所有局部对象均拥有此存储期。 </li>
<li>静态（static）存储期。这类对象的存储在程序开始时分配，并在程序结束时释放。这类对象只存在一个实例。所有声明于命名空间（包含全局命名空间）作用域的对象，加上声明带有 static 或 extern 的对象均拥有此存储期。 </li>
<li>线程（thread）存储期。这类对象的存储在线程开始时分配，并在线程结束时释放。每个线程拥有其自身的对象实例。只有声明为 thread_local 的对象拥有此存储期。 thread_local 能与 static 或 extern 一同出现，它们用于调整链接。<ul>
<li>只能对具有静态存储时间的数据项指定thread_local。这包括全局数据对象(静态和extern)、局部静态对象和类的静态数据成员。如果没有提供其他存储类，则任何声明为thread_local的局部变量都是隐式静态的;换句话说，在块作用域中，thread_local等价于thread_local static。</li>
</ul>
</li>
<li>动态（dynamic）存储期。这类对象的存储是通过使用动态内存分配函数来按请求进行分配和释放。</li>
</ul>
<h2 id="生命期（Lifetime）"><a href="#生命期（Lifetime）" class="headerlink" title="生命期（Lifetime）"></a>生命期（Lifetime）</h2><ul>
<li>每个对象和引用都有一个生命期。</li>
<li>对象的生命期开始：空间分配完成并且初始化完成；</li>
<li>对象的生命期结束：对于非类对象，空间被回收；对于类对象析构函数被调用或者空间被回收。</li>
<li>引用的生命期开始于初始化完成，结束同标量对象。</li>
<li>被引用对象的生命期的结束可能早于引用的生命期。这会形成悬挂引用（ dangling references）</li>
<li>对象的生命期等于或者嵌套在它的存储期中. <h2 id="翻译单元和链接"><a href="#翻译单元和链接" class="headerlink" title="翻译单元和链接"></a>翻译单元和链接</h2>在C++程序中，一个符号，例如一个变量或函数名，可以在其范围内声明任意次数。但是它只能定义一次。声明向程序中引入（或重新引入）名称，以及足够的信息以便以后将名称与定义相关联。定义引入名称并提供创建它所需的所有信息。如果名称表示变量，则定义会显式创建存储并对其进行初始化。函数定义由签名和函数体组成。类定义由类名后跟列出所有类成员的块组成。（可以选择在另一个文件中单独定义成员函数体。）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">以下示例显示了一些声明：</span><br><span class="line">int i;</span><br><span class="line">int f(int x);</span><br><span class="line">class C;</span><br><span class="line"></span><br><span class="line">以下示例显示了一些定义：</span><br><span class="line">int i&#123;42&#125;;</span><br><span class="line">int f(int x)&#123; return x * i; &#125;</span><br><span class="line">class Dog &#123;</span><br><span class="line">public:</span><br><span class="line">void  do()&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
&#x3D;&#x3D;程序由一个或多个翻译单元链接后形成。翻译单元由一个实现文件和它直接或间接包含的所有头文件组成。每个翻译单元由编译器独立编译。编译完成后，链接器将编译的翻译单元合并到单个程序中，链接器需要为每个名字找到有且仅且一个定义。&#x3D;&#x3D;</li>
</ul>
<h3 id="链接定义"><a href="#链接定义" class="headerlink" title="链接定义"></a>链接定义</h3><p>一个名称被称为具有链接是指它表示的实体（对象、引用、函数、模板, 类型、命名空间或值）可以在其它范围（scope）通过申明的方式被引入。</p>
<ul>
<li>当名称具有外部链接时，它所表示的实体可以被其它翻译单元的范围或本翻译单元的其它范围引用。</li>
<li>当名称具有内部链接时，它所表示的实体只能在本翻译单元的其它范围内被引用。</li>
<li>当一个名称具有模块链接时，它所表示的实体可以在相同模块单元的其它范围或者同一模块的其它模块单元的范围内被引用。</li>
<li>当一个名称没有链接时，它所表示的实体不能在其他范围内被引用。</li>
</ul>
<h3 id="链接举例"><a href="#链接举例" class="headerlink" title="链接举例"></a>链接举例</h3><h4 id="内部链接"><a href="#内部链接" class="headerlink" title="内部链接"></a>内部链接</h4><p>下列具有命名空间范围的名称具有内部链接：</p>
<ul>
<li>显式声明为静态的变量、变量模板（指实例化后定义的变量）、函数或函数模板（指实例化后定义的函数）.</li>
<li>匿名枚举的数据成员</li>
<li>除了下列情况的non-volatile的const非模板变量<ul>
<li>显示申明为extern</li>
<li>inline or exported</li>
<li>先前申明过，并且先前的声明为非内部链接</li>
</ul>
</li>
</ul>
<p>(以上为标准中的定义，很难理解，个人觉得常用的如下：const 变量为内部链接， extern const变量为外部链接）<br>另外在未命名命名空间或未命名命名空间内的命名空间中声明的所有名称，即使是显式声明为extern的名称，都具有内部链接。</p>
<p>备注：内部链接的变量和函数在每个翻译单元中都存在一个实例。</p>
<p>未命名名字空间为内部链接举例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//a.cpp</span><br><span class="line">namespace &#123; namespace na &#123;</span><br><span class="line">int g_b = 0;</span><br><span class="line">extern int g_a = 3;</span><br><span class="line">&#125; // namespace na</span><br><span class="line">&#125; // namespace ::na</span><br><span class="line"></span><br><span class="line">TEST(linkage, a_1) &#123;</span><br><span class="line">    cout &lt;&lt; na::g_a;  //ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b.cpp</span><br><span class="line">namespace &#123; namespace na &#123;</span><br><span class="line">extern int g_a;</span><br><span class="line">TEST(linkage, b_1) &#123;</span><br><span class="line">    cout &lt;&lt; g_a &lt;&lt; endl; // cant find definition</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="外部链接"><a href="#外部链接" class="headerlink" title="外部链接"></a>外部链接</h4><p>声明于命名空间作用域的下列任何名字均具有外部链接，除非这些名字在无名命名空间内声明或它们声明于具名模块且未被导出 (C++20 起)： </p>
<ul>
<li>未声明为 static 的函数、命名空间作用域内未声明为 static 的非 const 变量，和所有声明为 extern 的变量； </li>
<li><del>枚举； 类,</del>（c++标准说这样的枚举和类具有外部链接，个人目前无法理解）</li>
<li>类成员函数、静态数据成员（不论是否 const），及首次以类体内的 friend 声明引入的函数的名字； </li>
<li>未声明为 static 的函数模板。 </li>
<li>任何首次声明于块作用域的下列名称拥有外部链接： <ul>
<li>声明为 extern 的变量名； </li>
<li>函数名。<br>备注：个人认为枚举为常量不存在是否需要链接。类（除静态数据成员和成员函数）也只是编译时的概念，和链接无关。<br>下面例子演示了类和枚举在多个编译单元定义的情况：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">//a.cpp</span><br><span class="line">enum class CarModel &#123; X = 1 &#125;;</span><br><span class="line">enum DogType &#123; DT_LA = 1 &#125;;</span><br><span class="line"></span><br><span class="line">class SS &#123;</span><br><span class="line">public:</span><br><span class="line">    void p() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;a&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TEST(linkage, a_6) &#123;</span><br><span class="line">    SS s;</span><br><span class="line">    s.p();</span><br><span class="line">    cout &lt;&lt; (int)CarModel::X &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; DT_LA &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//b.cpp</span><br><span class="line">enum class CarModel &#123; X = 2 &#125;;</span><br><span class="line">enum  DogType &#123; DT_LA = 2 &#125;;</span><br><span class="line"></span><br><span class="line">class SS &#123;</span><br><span class="line">public:</span><br><span class="line">    void p() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;b&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TEST(linkage, b_6) &#123;</span><br><span class="line">    SS s;</span><br><span class="line">    s.p();</span><br><span class="line">    cout &lt;&lt; (int)CarModel::X &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; DT_LA &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TEST(linkage, b2_6) &#123;</span><br><span class="line">    class SS &#123;</span><br><span class="line">    public:</span><br><span class="line">        void p() &#123;</span><br><span class="line">            cout &lt;&lt; &quot;b&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    SS s;</span><br><span class="line">    s.p();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="无链接"><a href="#无链接" class="headerlink" title="无链接"></a>无链接</h3><p>声明于块作用域的下列任何名字均无链接： </p>
<ul>
<li>未显式声明为 extern 的变量（不管有没有 static 修饰符）； </li>
<li>局部类及其成员函数； </li>
<li>声明于块作用域的其他名字，例如 typedef、枚举及枚举项。</li>
</ul>
<h2 id="Inline"><a href="#Inline" class="headerlink" title="Inline"></a>Inline</h2><p>C++中的inline是个容易被误解的关键字，即使是专家也常会犯错。<br>不信 请打开《Thinking in C++ 2rd Edition Volumn 1》，找到Chapter 9 “Inline Function”的Exercise 6： “Prove that inline functions default to internal linkage.”为什么我说这里作者犯错了呢？<br>因为C++ 标准中明确写到：“The inline keyword has no effect on the linkage of a function.“看标准明确表示inline关键字不对函数的linkage产生影响，作者却要读者试图证明inline function默认为internal linkage！</p>
<p>inline 与函数的linkage无关。inline函数同样可以用static和extern修饰，并具备同一般函数相同的linkage。标准要求 external linkage的inline函数在所有编译单元中具有相同的地址。external linkage的inline函数内定义的静态变量同样应在所有编译单元中表现为单一对象，具有相同的地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// linkage.h</span><br><span class="line">#pragma once</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">//extern linkage</span><br><span class="line">inline int eif() &#123;</span><br><span class="line">    static int n = 0;</span><br><span class="line">    return ++n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// internal linkage</span><br><span class="line">static inline int iif() &#123;</span><br><span class="line">    static int n = 0;</span><br><span class="line">    return ++n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// internal linkage no-inline</span><br><span class="line">static int nf() &#123;</span><br><span class="line">    static int n = 0;</span><br><span class="line">    return ++n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline int g_ei = 0; //extern linkage</span><br><span class="line">inline static int g_ii = 0; // internal linkage</span><br><span class="line"></span><br><span class="line">// a.cpp</span><br><span class="line">#include &quot;linkage.h&quot;</span><br><span class="line">TEST(linkage, a_5) &#123;</span><br><span class="line">    cout &lt;&lt; &amp;eif &lt;&lt; &quot; &quot; &lt;&lt; eif() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &amp;iif &lt;&lt; &quot; &quot; &lt;&lt; iif() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &amp;nf &lt;&lt; &quot; &quot; &lt;&lt; nf() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &amp;g_ei &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &amp;g_ii &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// b.cpp</span><br><span class="line">#include &quot;linkage.h&quot;</span><br><span class="line">TEST(linkage, b_5) &#123;</span><br><span class="line">    cout &lt;&lt; &amp;eif &lt;&lt; &quot; &quot; &lt;&lt; eif() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &amp;iif &lt;&lt; &quot; &quot; &lt;&lt; iif() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &amp;nf &lt;&lt; &quot; &quot; &lt;&lt; nf() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &amp;g_ei &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &amp;g_ii &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#x3D;&#x3D;只应该在头文件中定义inline函数和inline变量&#x3D;&#x3D;</p>
<p>别在多个cpp中定义具有外部链接的相同类型的inline函数或变量。虽然可以编译通过，但是运行结果可能不是你想要的。请看下面例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// a.cpp</span><br><span class="line">inline void ig() &#123;</span><br><span class="line">    static int i = 0;</span><br><span class="line">    cout &lt;&lt; &quot;ig in a &quot; &lt;&lt; ++i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">inline int g_ia = 3;</span><br><span class="line">TEST(linkage, a_4) &#123;</span><br><span class="line">cout &lt;&lt; &amp;ig &lt;&lt; endl;</span><br><span class="line">ig();</span><br><span class="line">cout &lt;&lt; &amp;g_ia &lt;&lt; &quot; &quot; &lt;&lt; g_ia &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//b.cpp</span><br><span class="line">inline void ig() &#123;</span><br><span class="line">    static int i = 0;</span><br><span class="line">    cout &lt;&lt; &quot;ig in b &quot; &lt;&lt; ++i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">inline int g_ia = 4;</span><br><span class="line"></span><br><span class="line">TEST(linkage, b_4) &#123;</span><br><span class="line">    cout &lt;&lt; &amp;ig &lt;&lt; endl;</span><br><span class="line">ig();</span><br><span class="line">cout &lt;&lt; &amp;g_ia &lt;&lt; &quot; &quot; &lt;&lt; g_ia &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cachefish.github.io/2022/03/07/12-%E4%BC%A0%E8%BE%93%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="来世做春风，浪漫且自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cachecatのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/07/12-%E4%BC%A0%E8%BE%93%E5%B1%82/" class="post-title-link" itemprop="url">传输层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-07 19:30:00 / 修改时间：10:15:52" itemprop="dateCreated datePublished" datetime="2022-03-07T19:30:00+08:00">2022-03-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/base-network/" itemprop="url" rel="index"><span itemprop="name">base network</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>为上层提供了端到端的可靠的信息传递，传输层就是建立在应用间的端到端的连接，并且为数据传输提供可靠或不可靠的连接服务，</p>
<ol>
<li>连接管理:定义了两个用户像直接连接一样开始交谈的规则，通常把连接的定义和建立的过程成为握手，传输层要建立、维持和终止一个会话。传输层与其对等系统建立面向连接的会话。</li>
<li>流量控制:以网络普遍接受的速度发送数据，从而防止网络拥塞造成数据报的丢失，传输层定义了端到端用户之间的流量控制，数据链路层定义的是两个中心的相邻结点的数据控制。</li>
<li>差错控制: 数据链路层的差错检测功能提供了可靠的链路传输，但无法保证源点和目的之间的传输完全无错(比如网络中的路由器收到了完整无缺的IP分组，但在将含有分组的帧重新格式化的过程中出现了影响分组内容的错误)。传输层的差错检测机制会检测到这种类型的错误。</li>
<li>对用户请求响应:包括对发送和接收数据请求的响应，以及特定请求的响应，和用户可能要求高吞吐量、低延迟的可靠的服务。</li>
<li>建立无连接或面向连接的通信:TCP&#x2F;IP协议的TCP提供面向连接的传输层服务，UDP提供无连接的传输层服务。</li>
<li>传输层提供了应用进程之间的端到端连接，其作用是为网络应用程序提供接口。为端到端连接提供流量控制、差错控制、服务质量等管理服务。提供多路复用、多路分解机制。</li>
</ol>
<hr>
<p>传输层为相互通信的应用进程提供了逻辑通信（如下图），分段及封装应用层递来的数据。其主要目的：一是提供可靠（传输层要向会话层提供通信服务的可靠性，避免报文的出错、丢失、延迟时间紊乱、重复、乱序等差错）的端到端（即源主机端口到目的主机端口）通信；二是向应用层提供独立于网络的传输服务，换言之，传输层利用网络层提供的服务，并通过传输层地址提供给高层用户传输数据的通信端口，使系统间高层资源的共享不必考虑数据通信方面（数据链路层）和不可靠的数据传输方面（传输层）的问题。</p>
<p><img src="https://pics5.baidu.com/feed/a6efce1b9d16fdfa41b6496e47b2785295ee7b19.jpeg?token=dfc47de2316b9011838c9ee89247dd90" alt="image"></p>
<h2 id="面向连接和无连接"><a href="#面向连接和无连接" class="headerlink" title="面向连接和无连接"></a>面向连接和无连接</h2><h3 id="面向连接"><a href="#面向连接" class="headerlink" title="面向连接"></a>面向连接</h3><p>面向连接就是通信双方在通信时，要事先建立一条通信线路，然后进行通信。其过程分为三个阶段。第一阶段是建立连接。第二阶段是连接成功建立之后，进行数据传输。第三阶段是在数据传输完毕后，释放连接。</p>
<h3 id="无连接"><a href="#无连接" class="headerlink" title="无连接"></a>无连接</h3><p>无连接是指通信双方不需要事先建立通信线路，而是把每个带有目的地址的包（报文分组）发送到线路上，由系统选定路线进行传输，不需要目标方进行回复。</p>
<h3 id="端口和套接字"><a href="#端口和套接字" class="headerlink" title="端口和套接字"></a>端口和套接字</h3><p>为了区分同一个主机上不同应用程序的数据包，传输层提供了端口和套接字概念。下面介绍端口和套接字的作用。</p>
<h4 id="端口的作用"><a href="#端口的作用" class="headerlink" title="端口的作用"></a>端口的作用</h4><p>在数据链路层中，通过 MAC 地址来寻找局域网中的主机；在网际层中，通过 IP 地址来寻找网络中互连的主机或路由器。在传输层中，需要通过端口进行寻址，来识别同一计算机中同时通信的不同应用程序。</p>
<p>端口号用来识别应用程序。</p>
<h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>应用层通过传输层进行数据通信时，TCP 和 UDP 会遇到需要同时为多个应用程序进程提供并发服务的问题。</p>
<p>多个 TCP 连接或多个应用程序进程可能需要通过同一个 TCP 协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与 TCP／IP 协议交互提供了称为套接字（Socket）的接口，区分不同应用程序进程间的网络通信和连接。</p>
<p>套接字是由主机的 IP 地址加上主机上的端口号组成的地址。例如，套接字地址 101.102.103.104：21，表示指向 IP 地址为 101.102.103.104 的计算机的 21 端口。</p>
<h3 id="多路复用和多路分解"><a href="#多路复用和多路分解" class="headerlink" title="多路复用和多路分解"></a>多路复用和多路分解</h3><p>在网络上主机与主机之间的通信实质上是主机上运行的应用进程之间的通信。在进行通信时，往往同时运行多个应用程序。</p>
<p>为了能够让一个计算机同时支持多个网络程序，并且同时保持与多台计算机进行连接，就需要使用多路复用和多路分解，其含义如下：<br>多路复用：从源主机的不同套接字中收集数据块，并为每个数据块封装首部信息，从而生成报文段，然后将报文段传递到网络层中。<br>多路分解：将传输层报文段中的数据交付到正确的套接字。</p>
<h2 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h2><p>UDP 是一种无连接的，不可靠的传输层协议。在传送数据之前不需要建立连接，对方的传输层在收到 UDP 报文后，也不需要给出任何确认。<br>它只提供了传输层需要实现的最低限度的功能，除了复用&#x2F;分解功能和少量的差错检测外，它几乎没有对 IP 增加其他的东西。<br>UDP 协议适用于对 实时性要求高 的应用场景，因为它无连接，不需要反馈，所以简单，快捷</p>
<hr>
<h3 id="特点-UDP-："><a href="#特点-UDP-：" class="headerlink" title="特点(UDP)："></a>特点(UDP)：</h3><ol>
<li>无连接<br>使用 UDP 时，在发送报文段之前，通信双方没有握手的过程，因此 UDP 被称为是无连接的传输层协议。因为没有握手过程，相对于 TCP 来说，没有建立连接的时间消耗。</li>
<li>不可靠<br>UDP 提供尽力而为的交付服务，也就是说 UDP 协议不保证数据的可靠交付。</li>
<li>发送速率无限制<br>UDP 没有拥塞控制和流量控制的机制，所以 UDP 报文段的发送速率没有限制。</li>
<li>通信方式多样<br>因为一个 UDP 套接字只使用目的地址和目的端口来标识，所以 UDP 可以支持一对一、一对多、多对一和多对多的交互通信（收发不能同时，收了才能发，发了才能收）。</li>
<li>小<br>UDP 头部小，只有 8 个字节。</li>
</ol>
<h4 id="UDP-报文段结构"><a href="#UDP-报文段结构" class="headerlink" title="UDP 报文段结构"></a>UDP 报文段结构</h4><p>UDP 报文段由头部和应用数据组成。报文段头部包含四个字段，分别是源端口号、目的端口号、长度和检验和，每个字段的长度为两个字节（头部共 8 字节）。<br>长度字段指的是整个报文段的长度，包含了首部和应用数据的大小。<br>校验和是 UDP 提供的一种差错校验机制。<br>虽然提供了差错校验的机制，但是 UDP 对于差错的恢复无能为力。<br><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-16.png" alt="image"></p>
<h2 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h2><p>TCP 协议是面向连接的，提供可靠数据传输服务的传输层协议。</p>
<h3 id="特点-TCP-："><a href="#特点-TCP-：" class="headerlink" title="特点(TCP)："></a>特点(TCP)：</h3><ol>
<li>面向连接<br>TCP 协议是面向连接的，在通信双方进行通信前，需要通过三次握手建立连接。它需要在端系统中维护双方连接的状态信息。</li>
<li>可靠<br>TCP 协议通过序列号、确认号、定时重传、检验和等机制，来提供可靠的数据传输服务。</li>
<li>一对一<br>TCP 协议提供的是点对点的服务，即它是在单个发送方和单个接收方之间的连接。</li>
<li>全双工服务<br>TCP 协议提供的是全双工的服务，也就是说连接的双方的能够向对方发送和接收数据。</li>
<li>拥塞控制机制<br>TCP 提供了拥塞控制机制，在网络拥塞的时候会控制发送数据的速率，有助于减少数据包的丢失和减轻网络中的拥塞程度。</li>
<li>流量控制机制<br>TCP 提供了流量控制机制，保证了通信双方的发送和接收速率相同。如果接收方可接收的缓存很小时，发送方会降低发送速率，避免因为缓存填满而造成的数据包的丢失。</li>
</ol>
<h4 id="TCP-报文段结构"><a href="#TCP-报文段结构" class="headerlink" title="TCP 报文段结构"></a>TCP 报文段结构</h4><p>TCP 报文段由头部和数据组成，它的头部一般为 20 个字节。<br>源端口和目的端口号用于报文段的多路复用和分解。<br>32 比特的序列号和 32 比特的确认号，用于实现数据的可靠传输服务。<br>16 比特的接收窗口字段用于实现流量控制，该字段表示接收方愿意接收的字节的数量。<br>4 比特的头部长度字段，该字段指示了以 32 比特的字为单位的 TCP 头部的长度。<br>6 比特的标志字段，ACK 字段用于指示确认序列号的值是有效的。<br>RST、SYN 和 FIN 比特用于连接建立和拆除。<br>设置 PSH 字段指示接收方应该立即将数据交给上层。<br>URG 字段用来指示报文段里存在紧急的数据。<br>校验和提供了对数据的差错检测。<br><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-17.png" alt="image"></p>
<h3 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h3><hr>
<p>序列号 seq：占 4 个字节，用来标记数据段的顺序。<br>确认号 ack：占 4 个字节，期待收到对方下一个报文段的第一个数据字节的序号。<br>确认 ACK：占 1 位，仅当 ACK&#x3D;1 时，确认号字段才有效。ACK&#x3D;0 时，确认号无效<br>同步 SYN：连接建立时用于同步序号。当 SYN&#x3D;1，ACK&#x3D;0 时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得 SYN&#x3D;1，ACK&#x3D;1。因此，SYN&#x3D;1 表示这是一个连接请求，或连接接受报文。SYN 这个标志位只有在 TCP 建产连接时才会被置 1，握手完成后 SYN 标志位被置 0。<br>终止 FIN：用来释放一个连接。FIN&#x3D;1 表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接</p>
<hr>
<p>第一次握手：</p>
<p>客户端向服务端发送一个 SYN(seq&#x3D;x) 连接请求报文，并进入 SYN_SENT 状态 ，等待服务器确认。<br>SYN&#x3D;1，序列号 seq字段最开始是一个任选的随机数 x，它代表客户端数据的初始序列号。<br>第一次握手后，服务端知道了 自己可以与客户端连接成功，但此时客户端还不知道</p>
<p>第二次握手：</p>
<p>服务端收到 SYN 包，首先会为该连接分配 TCP 缓存和变量，然后返回 ACK(ack&#x3D;x+1)确认报文，同时自己也发送一个 SY(syn&#x3D;y)，即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态。</p>
<p>SYN&#x3D;1,ACK&#x3D;1，序列号字段是服务端产生的一个任选的随机数 y，它代表服务端数据的初始序列号。确认号字段为客户端发送的序列号+1。<br>第二次握手后，客户端收到了服务端的反馈，确定了自己可以于服务端连接成功</p>
<p>第三次握手</p>
<p>客户端收到服务器的 SYN+ACK 包，也会为这次 TCP 连接分配缓存和变量，然后向服务器发送确认包ACK(ack&#x3D;y+1)(seq&#x3D;x+1)，此包发送完毕，客户端和服务器进入ESTABLISHED（TCP 连接成功）状态，完成三次握手。</p>
<p>ACK&#x3D;1，序列号字段为客户端 x+1，确认号字段为服务端发送的序列号 y+1<br>第三次握手，防止失效的请求报文段被服务端接收</p>
<p>TCP 三次握手的建立连接的过程就是相互确认初始序列号的过程，告诉对方，什么样序列号的报文段能够被正确接收。<br>第三次握手的作用是客户端对服务端的初始序列号的确认。如果只使用两次握手，那么服务端就没有办法知道自己的序列号是否已被确认。同时这样也是为了防止失效的请求报文段被服务端接收，而出现错误的情况。<br>比如：</p>
<p>客户端发出去的第一个连接请求由于某些原因在网络节点中滞留了导致延迟，<br>直到连接释放的某个时间点才到达服务端，这是一个早已失效的报文，<br>但此时服务端仍然认为这是客户端的 第一次握手，于是服务端回应了客户端，第二次握手。</p>
<hr>
<h3 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h3><hr>
<p>因为 TCP 连接是全双工的，也就是说通信的双方都可以向对方发送和接收消息，所以断开连接需要双方的确认。</p>
<p>第一次挥手</p>
<p>客户端认为没有数据要再发送给服务端，它就向服务端发送一个 FIN 报文段，申请断开客户端到服务端的连接。<br>发送后客户端进入 FIN_WAIT_1 状态。<br>第二次挥手</p>
<p>服务端收到后，向客户端发送一个确认报文段ACK，表示已经接收到了客户端释放连接的请求，以后不再接收客户端发送过来的数据。但是因为连接是全双工的，所以此时，服务端还可以向客户端发送数据。<br>服务端进入 CLOSE_WAIT 状态。<br>客户端收到确认后，进入 FIN_WAIT_2 状态。<br>第三次挥手</p>
<p>服务端发送完所有数据后，向客户端发送 FIN ACK 报文段，申请断开服务端到客户端的连接。<br>发送后进入 LAST_ACK 状态。<br>第四次挥手</p>
<p>客户端接收到 FIN 请求后，向服务端发送一个确认报文段 ACK ，并进入 TIME_WAIT 阶段 。<br>服务端收到客户端的确认报文段后就立即进入 CLOSED 状态。<br>客户端 TIME_WAIT 阶段 会持续一段时间，这个时间为报文段在网络中的最大生存时间，如果该时间内服务端没有重发请求的话，客户端就进入 CLOSED 状态。如果收到服务端的重发请求就重新发送确认报文。<br>这样全双工的连接就被释放了。</p>
<p>TCP 使用四次挥手的原因是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代表不能再向对方发送数据，连接处于的是半释放的状态。</p>
<p>最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务端的确认报文段丢失或者出错，从而导致服务端不能正常关闭。</p>
<h2 id="ARP-协议"><a href="#ARP-协议" class="headerlink" title="ARP 协议"></a>ARP 协议</h2><p>ARQ 协议指的是自动重传请求，它通过超时和重传来保证数据的可靠交付，它是 TCP 协议实现可靠数据传输的一个很重要的机制。</p>
<p>它分为停止等待 ARQ 协议和连续 ARQ 协议。</p>
<h3 id="一、停止等待-ARQ-协议"><a href="#一、停止等待-ARQ-协议" class="headerlink" title="一、停止等待 ARQ 协议"></a>一、停止等待 ARQ 协议</h3><p>停止等待 ARQ 协议的基本原理是，对于发送方来说发送方每发送一个分组，就为这个分组设置一个定时器。当确认回答返回了，则清除定时器，发送下一个分组。如果在规定的时间内没有收到确认回答，则重新发送上一个分组。</p>
<p>对于接受方来说，每次接受到一个分组，就返回对这个分组的肯定应答，当收到重复的分组时，就直接丢弃，并重新返回 确认报文。当收到分组损坏的情况的时候，直接丢弃。</p>
<p>使用停止等待 ARQ 协议的缺点是每次发送分组必须等到分组确认后才能发送下一个分组，这样会造成信道的利用率过低。</p>
<hr>
<p>举例（发送方问题）</p>
<p>如果 A 发送的过程中出现差错，B 在接收 M1 时检测出了差错，就丢弃 M1，其他什么都不做（也不会通知 A 收到有差错的分组）。又或者 A 传送的过程中分组丢失了，以上这两种情况下，B 不会发送任何信息。<br>如果发生以上的情况，A 只要超过了一段时间仍然没有收到确认，就认为刚才发送的分组丢失了，所以它会重传刚刚的发送过的分组，也就是所谓的超时重传。<br>超时重传的原理：发送方发送完一个分组后，就会设置一个超时计时器，如果超时计时器到期之前没有收到接收方发来的确认信息，则会重发刚发送过的分组；如果收到确认信息，则撤销该超时计时器。</p>
<p>举例（接收方问题）</p>
<p>如果 A 发送了 M1 分组，到达 B，B 发送了 M1 确认信息，但由于网络原因，该确认信息丢失。那么这个时候，A 在超时重传时间内，没有收到 B 的确认信息，而且它并不知道是自己的分组有差错、丢失，还是 B 发生的确认丢失了。因此，A 会在超时重传过后，重传 M1 分组。<br>接收方 B 会采取这两个行动：<br>① B 会丢弃 M1 分组，不向上层交付。（B 之前已经收到过 M1 分组了）<br>② 向 A 发送确认（因为 A 重发了，肯定重传时间内没有收到确认信息）</p>
<hr>
<h3 id="二、连续-ARQ-协议"><a href="#二、连续-ARQ-协议" class="headerlink" title="二、连续 ARQ 协议"></a>二、连续 ARQ 协议</h3><p>连续 ARQ 协议是为了解决停止等待 ARQ 协议对于信道的利用率过低的问题。它通过连续发送一组分组，然后再等待对分组的确认回答，对于如何处理分组中可能出现的差错恢复情况，一般可以使用滑动窗口协议和选择重传协议来实现。</p>
<h4 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h4><p>在在发送方和接收方之间各自维持一个滑动窗口，发送发是发送窗口，接收方是接收窗口，而且这个窗口是随着时间变化可以向前滑动的。它允许发送方发送多个分组而不需等待确认。TCP 的滑动窗口是以字节为单位的。<br>连续 ARQ 协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。当发送方收到第一个分组的确认，就把发送窗口向前移动一个分组的位置。如果收到的是第 5 个分组的确认，那么移动到第六 6 个分组。</p>
<p>接收方一般都是采用累积确认的方式。也就是说接收方不必对收到的分组逐个发送确认。而是在收到几个分组后，对按序到达的最后一个分组发送确认。如果收到了这个分组确认信息，则表示到这个分组为止的所有分组都已经正确接收到了。</p>
<h4 id="累积确认"><a href="#累积确认" class="headerlink" title="累积确认"></a>累积确认</h4><p>优点是容易实现，即使确认丢失也不必重传。<br>缺点是，不能正确的向发送方反映出接收方已经正确收到的所以分组的信息。<br>比如发送方发送了前 5 个分组，而中间的第 3 个分组丢失了，这时候接收方只能对前 2 个发出确认。而不知道后面 3 个分组的下落，因此只能把后面的 3 个分组都重传一次，这种机制叫 Go-back-N（回退 N），表示需要再退回来重传已发送过的 N 个分组。</p>
<h3 id="选择重传协议"><a href="#选择重传协议" class="headerlink" title="选择重传协议"></a>选择重传协议</h3><p>接收端总会缓存所有收到的帧，当某个帧出现错误时，只会要求重传这一个帧，只有当某个序号后的所有帧都正确收到后，才会一起提交给高层应用。重传协议的缺点在于接受端需要更多的缓存。<br>TCP 的可靠运输机制<br>TCP 的可靠运输机制是基于连续 ARQ 协议和滑动窗口协议的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">已经发送并确认 |============= 发送窗口 ===========| 缓存中还不允许发送的 |</span><br><span class="line">============= |已经发送但未确认 | 允许发送但还未发送| ===================|</span><br></pre></td></tr></table></figure>
<p>TCP 协议在发送方维持了一个发送窗口，发送窗口以前的报文段是已经发送并确认了的报文段，发送窗口中包含了已经发送但未确认的报文段和允许发送但还未发送的报文段，发送窗口以后的报文段是缓存中还不允许发送的报文段。当发送方向接收方发送报文时，会依次发送窗口内的所有报文段，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的报文段。</p>
<p>&#x3D;&#x3D;TCP 协议的可靠传输机制更像是窗口滑动协议和选择重传协议的一个混合体。&#x3D;&#x3D;</p>
<h3 id="TCP-的流量控制机制"><a href="#TCP-的流量控制机制" class="headerlink" title="TCP 的流量控制机制"></a>TCP 的流量控制机制</h3><p>TCP 提供了流量控制的服务，这个服务的主要目的是控制发送方的发送速率，保证接收方来得及接收。因为一旦发送的速率大于接收方所能接收的速率，就会造成报文段的丢失。接收方主要是通过接收窗口来告诉发送方自己所能接收的大小，发送方根据接收方的接收窗口的大小来调整发送窗口的大小，以此来达到控制发送速率的目的。</p>
<h3 id="TCP-的拥塞控制机制"><a href="#TCP-的拥塞控制机制" class="headerlink" title="TCP 的拥塞控制机制"></a>TCP 的拥塞控制机制</h3><p>TCP 的拥塞控制主要是根据网络中的拥塞情况来控制发送方数据的发送速率，如果网络处于拥塞的状态，发送方就减小发送的速率，这样一方面是为了避免继续增加网络中的拥塞程度，另一方面也是为了避免网络拥塞可能造成的报文段丢失。</p>
<p>TCP 的拥塞控制主要使用了四个机制，分别是&#x3D;&#x3D;慢启动、拥塞避免、快速重传和快速恢复。&#x3D;&#x3D;</p>
<p>慢启动的基本思想是，因为在发送方刚开始发送数据的时候，并不知道网络中的拥塞程度，所以先以较低的速率发送，进行试探，每次收到一个确认报文，就将发送窗口的长度加一，这样每个 RTT 时间后，发送窗口的长度就会加倍。当发送窗口的大小达到一个阈值的时候就进入拥塞避免算法。</p>
<p>拥塞避免算法是为了避免可能发生的拥塞，将发送窗口的大小由每过一个 RTT 增长一倍，变为每过一个 RTT ，长度只加一。这样将窗口的增长速率由指数增长，变为加法线性增长。</p>
<p>快速重传指的是，当发送方收到三个冗余的确认应答时，因为 TCP 使用的是累计确认的机制，所以很有可能是发生了报文段的丢失，因此采用立即重传的机制，在定时器结束前发送所有已发送但还未接收到确认应答的报文段。</p>
<p>快速恢复是对快速重传的后续处理，因为网络中可能已经出现了拥塞情况，所以会将慢启动的阀值减小为原来的一半，然后将拥塞窗口的值置为减半后的阀值，然后开始执行拥塞避免算法，使得拥塞窗口缓慢地加性增大。简单来理解就是，乘性减，加性增。</p>
<p>TCP 认为&#x3D;&#x3D;网络拥塞的主要依据是报文段的重传次数，它会根据网络中的拥塞程度，通过调整慢启动的阀值，然后交替使用上面四种机制来达到拥塞控制的目的。&#x3D;&#x3D;</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cachefish.github.io/2022/03/03/10-%E8%A1%A8%E8%BE%BE%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="来世做春风，浪漫且自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cachecatのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/03/10-%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="post-title-link" itemprop="url">c++ 表达式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-03 19:30:00" itemprop="dateCreated datePublished" datetime="2022-03-03T19:30:00+08:00">2022-03-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-07 10:10:36" itemprop="dateModified" datetime="2022-03-07T10:10:36+08:00">2022-03-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-base/" itemprop="url" rel="index"><span itemprop="name">c++ base</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="表达式（Expressions）"><a href="#表达式（Expressions）" class="headerlink" title="表达式（Expressions）"></a>表达式（Expressions）</h2><p>表达式定义<br>表达式（expression）是C++语言的基石，是C++表达计算的主要机制。表达式的求值可以产生一个值（比如 2+2 的求值产生值 4），也可能产生副作用（比如对 std::printf(“%d”,4) 的求值在标准输出上打印字符 ‘4’）。</p>
<h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>1.表达式是由运算符和它们的操作数的构成的序列，它指定一项计算。<br>2.任何运算符的操作数都可以是其他的表达式或初等表达式。（例如，1+2<em>3 中 operator+ 的操作数是子表达式 2</em>3 和初等表达式 1）。 </p>
<p>初等表达式<br>初等表达式包括以下各项： </p>
<ul>
<li>字面量（例如 2 或 “Hello, world”） </li>
<li>标识表达式，包括 <ul>
<li>经过适当声明的无限定的标识符（例如 n 或 cout），以及 </li>
<li>经过适当声明的有限定的标识符（例如 std::string::npos）</li>
</ul>
</li>
<li>lambda 表达式 (C++11) </li>
<li>折叠表达式 (C++17) </li>
<li>requires 表达式 (C++20)<br>括号中的任何表达式也被归类为初等表达式：这确保了括号具有比任何运算符更高的优先级。括号保持值、类型和值类别不变。</li>
</ul>
<p>标识符表达式可以出现在 . 和 -&gt;运算符后面。</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul>
<li>static_cast转换—个类型为另—相关类型</li>
<li>dynamic_cast在继承层级中转换</li>
<li>const_cast 添加或移除cv限定符</li>
<li>reinterpret_cast转换类型到无关类型</li>
<li>C风格转型以static_cast , const_cast 及 reinterpret_cast的混合转换一个类型到另一类型new创建有动态存f储其期的对象</li>
<li>delete销毁先前由new表达式创建的对象，并释放其所拥有的内存区域sizeof查询类型的大小</li>
<li>sizeof. ..查询形参包的大小C++11起)typeid查询类型的类型信息</li>
<li>noexcept查询表达式是否能抛出异常(C++11起)alignof查询类型的对齐要求(C++11起)</li>
</ul>
<h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><p>字面量是 C++ 程序中用以直接写在源代码中的常量值。 </p>
<ul>
<li>整数字面量是整数类型的十进制、八进制、十六进制或二进制 (C++14 起)的数值 </li>
<li>字符字面量是有下列类型之一的单个字符： </li>
<li>char 或 wchar_t </li>
<li>char16_t 或 char32_t (C++11 起) </li>
<li>char8_t (C++20 起) </li>
<li>浮点字面量是float、double 或 long double 类型的值 </li>
<li>字符串字面量是有下列类型之一的字符序列： </li>
<li>const char[] 或 const wchar_t[] </li>
<li>const char16_t[] 或 const char32_t[]  </li>
<li>const char8_t[] (C++20 起) </li>
<li>布尔字面量是 bool 类型的值，即 true 和 false </li>
<li>nullptr 是指针字面量，指定一个空指针值 。</li>
<li>用户定义字面量是用户指定的类型的常量值 。operator “”<br>备注：<ul>
<li>对于字符串一般存储在只读数据段，然后通过地址引用。（lvalue）</li>
<li>其它字面量被直接编码成汇编指令的常量，所以在代码段。(prvalue)</li>
</ul>
</li>
</ul>
<h3 id="不求值表达式"><a href="#不求值表达式" class="headerlink" title="不求值表达式"></a>不求值表达式</h3><p>运算符 typeid、sizeof、noexcept 和 decltype 的操作数是不求值表达式（除非运算符为 typeid 而操作数是多态泛左值），因为这些运算符仅查询其操作数的编译期性质。因此，std::size_t n &#x3D; sizeof(std::cout &lt;&lt; 42); 不进行控制台输出。<br>当typeid操作数是polymorphic glvalues，该表达式需要求值。 </p>
<h3 id="弃值表达式"><a href="#弃值表达式" class="headerlink" title="弃值表达式"></a>弃值表达式</h3><p>弃值表达式是仅用来实施其副作用的表达式。&#x3D;&#x3D;从这种表达式计算的值被舍弃。&#x3D;&#x3D;这样的表达式包括任何表达式语句的完整表达式，内建逗号运算符的左边的操作数。</p>
<h3 id="值类别"><a href="#值类别" class="headerlink" title="值类别"></a>值类别</h3><p>每一个表达式都有一个类型（type）,该类型描述了表达式求值得到的结果的静态类型。表达式：7，拥有类型: int。表达式：5+2，它的类型也是 int。如果一个变量 x 的类型为int，那么表达式：x 的类型也是int。</p>
<p>每一个表达式还拥有一个值类别（value category）,值类别描述了表达式的值是如何形成的，同时也影响表达式的行为。尽管值类别称呼上有个值，但是这个术语用来分类表达式，而不是值。（Despite their names, these terms classify expressions, not values）。</p>
<hr>
<ol>
<li>● 泛左值 (glvalue)（“泛化 (generalized)”的左值）：表达式的求值确定一个对象、位域或函数的身份。（这样的实体拥有存储空间）； </li>
<li>● 纯右值 (prvalue)（“纯 (pure)”的右值）：根据表达式所处于的上下文，其求值是用来初始化一个对象或者位域，或者用来计算一个内置操作符的操作数的值；或者这个表达式是void类型。</li>
<li>● 亡值 (xvalue)（“将亡 (expiring)”的值）：是一个代表其资源能够被重新使用的对象或位域的泛左值； (通常因为它处于生命期的终结)</li>
<li>● 左值 (lvalue)：是非亡值的泛左值。（如此称呼的历史原因是，左值可以出现于赋值表达式的左边）； </li>
<li>● 右值 (rvalue)：是纯右值或者亡值。（如此称呼的历史原因是，右值可以出现于赋值表达式的右边）。</li>
</ol>
<p>备注：C++中初始化和赋值是两个独立的概念。初始化的一些场景：1.初始化函数参数；2.初始化函数返回值；3.在声明符后跟一个初始化器。见上面的定义prvalue的一个作用就是用作初始化。</p>
<p>lvalue, xvalue和prvalue是基本值类别，每个表达式只能属于其中一个类别。内置运算对其操作数的值类别和其生成值的值类别都有规定，比如内置的赋值运算符期待左边的操作数为lvalue,右边的操作数为prvalue，并且生成一个lvalue作为其结果。重载的操作符相当于函数调用，其期待的操作数的值类别 和结果的值类别有它们的参数和返回类型决定。</p>
<h3 id="表达式的结果（result）"><a href="#表达式的结果（result）" class="headerlink" title="表达式的结果（result）"></a>表达式的结果（result）</h3><ul>
<li>glvalue的结果是这个表达式表示的实体(对象、位域或函数)。</li>
<li>prvalue的结果是表达式存储在它上下文中的值；类型为void的prvalue没有结果。</li>
</ul>
<h4 id="prvalue的结果对象（result-object）："><a href="#prvalue的结果对象（result-object）：" class="headerlink" title="prvalue的结果对象（result object）："></a>prvalue的结果对象（result object）：</h4><ul>
<li>prvalue的结果对象是被prvalue初始化的对象。</li>
<li>用来计算内置运算符的操作数的值的prvalue没有结果对象，void类型的prvalue也没有结果对象。</li>
<li>类和数组类型的prvalue总是有一个结果对象，除非它作为decltype的操作数。</li>
<li>对于非void类型的prvalue弃值表达式，一个被物化的零时对象做为它的结果对象。</li>
</ul>
<h4 id="典型值类型举例"><a href="#典型值类型举例" class="headerlink" title="典型值类型举例"></a>典型值类型举例</h4><h5 id="左值表达式："><a href="#左值表达式：" class="headerlink" title="左值表达式："></a>左值表达式：</h5><ol>
<li>关联一个变量或一个函数的表达式。即使变量的类型是右值引用，由其名字构成的表达式仍是左值表达式；例如int&amp;&amp; a,  当a作为表达式时为lvalue； void(f)(), 当f作为表达式时也是lvalue;</li>
<li>返回类型为左值引用的函数调用或重载运算符表达式，例如 std::getline(std::cin, str)、std::cout &lt;&lt; 1、str1 &#x3D; str2 或 ++it；</li>
<li>内建的间接寻址表达式，例如*p；  </li>
<li>a &#x3D; b，a +&#x3D; b，a %&#x3D; b，以及所有其他内建的赋值及复合赋值表达式； </li>
<li>++a 和 –a，内建的前置自增与前置自减表达式；</li>
<li>数组下标表达式，数组为lvaue时. </li>
<li>逗号表达式，第二个操作数为lvalue； </li>
<li>三元条件表达式 ，返回操作数为lvalue. 例如 a ? b:c</li>
<li>字符串字面量，例如 “Hello, world!”；但它不可修改 。</li>
<li>返回函数右值引用的函数调用表达式或重载的运算符表达式</li>
</ol>
<h5 id="纯右值表达式："><a href="#纯右值表达式：" class="headerlink" title="纯右值表达式："></a>纯右值表达式：</h5><ol>
<li>包含字面量的表达式。这个字面量，不是字符串字面值，也不是用户自定义的字面值。 </li>
<li>调用一个函数的表达式.这个函数返回的是值类型或void，不是引用类型.</li>
<li>用一元运算符 &amp; 的表达式（获得内存地址）</li>
<li>内置的算术运算符表达式;例如：a + b, a % b, a &amp; b, a &lt;&lt; b,</li>
<li>内置后加，后减表达式;例如：a++ and a—</li>
<li>内置的逻辑表达式;例如： a &amp;&amp; b, a || b, !a</li>
<li>内置的比较表达式：例如：a &lt; b, a &#x3D;&#x3D; b, a &gt;&#x3D; b</li>
<li>逗号表达式，第二个操作数为pralue</li>
<li>三元条件表达式，返回操作数为prvalue. 例如 a ? b:c</li>
<li>this 指针</li>
<li>枚举值</li>
<li>lambda表达式 <h5 id="亡值表达式："><a href="#亡值表达式：" class="headerlink" title="亡值表达式："></a>亡值表达式：</h5></li>
<li>返回类型为对象的右值引用的函数调。</li>
<li>向对象的右值引用的类型转化。例如 std::move(x)； </li>
<li>数组下标表达式，数组为xvalue。例如a[1]； </li>
<li>对象成员表达式，对象是xvalue类类型的对象，该成员是非静态的非引用数据成员。例如a.m;</li>
<li>对象成员指针表达式，对象是xvalue类类型的对象，指针为数据成员指针。例如a.*m;</li>
<li>临时量物化后，指代该临时对象的表达式。<br>例子：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">   int m;</span><br><span class="line"> &#125;;</span><br><span class="line">A&amp;&amp; operator+(A, A);</span><br><span class="line">A&amp;&amp; f()；</span><br><span class="line">A a;</span><br><span class="line">A&amp;&amp; ar = static_cast&lt;A&amp;&amp;&gt;(a);</span><br><span class="line">the expressions f(), f().m, static_cast&lt;A&amp;&amp;&gt;(a), and a + a are xvalues. The expression ar is an lvalue.</span><br></pre></td></tr></table></figure>
<h3 id="临时量物化（temporary-materialization）"><a href="#临时量物化（temporary-materialization）" class="headerlink" title="临时量物化（temporary materialization）"></a>临时量物化（temporary materialization）</h3>当pvalue作为一个操作符的操作数，并且这个操作数期待一个glvaue，这个pvalue被临时量物化转化为xvalue.<br>类型为T的prvalue转为为类型为T的xvalue，此转换以该纯右值初始化一个 T 类型的临时对象（以临时对象作为求值该纯右值的结果对象），并产生一个亡值代表（denoting)该临时对象。 T必须是完全类型。若T是类类型或类类型的数组，则它必须有可访问且未被删除的析构函数</li>
</ol>
<p>当pvalue作为一个操作符的操作数，并且这个操作数期待一个glvaue，这个pvalue被临时量物化转化为xvalue.<br>类型为T的prvalue转为为类型为T的xvalue，此转换以该纯右值初始化一个 T 类型的临时对象（以临时对象作为求值该纯右值的结果对象），并产生一个亡值代表（denoting)该临时对象。 T必须是完全类型。若T是类类型或类类型的数组，则它必须有可访问且未被删除的析构函数 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct S &#123; int m; &#125;;</span><br><span class="line">int k = S().m; // C++17 起成员访问期待泛左值；S() 纯右值被转换为亡值。</span><br></pre></td></tr></table></figure>
<p>例如临时量物化在下例情况下发生： </p>
<ol>
<li>引用绑定到prvalue时； </li>
<li>在类prvalue上进行成员访问时； </li>
<li>数组prvalue转换为指针;</li>
<li>数组prvalue使用下标表达式时； </li>
<li>prvalue作为弃值表达式时；</li>
</ol>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>&#x3D;&#x3D;prvalue表示一个纯的值，没有存储空间;  glvalue有存储空间且有值，因为有空间所以有身份。&#x3D;&#x3D;</p>
<h3 id="各种值类别的特性："><a href="#各种值类别的特性：" class="headerlink" title="各种值类别的特性："></a>各种值类别的特性：</h3><h4 id="泛左值"><a href="#泛左值" class="headerlink" title="泛左值"></a>泛左值</h4><p>glvalue可以通过lvalue-to-rvalue, array-to-pointer,或function-to-pointer隐式转换为prvalue，</p>
<h4 id="Lvalue-to-rvalue-conversion"><a href="#Lvalue-to-rvalue-conversion" class="headerlink" title="Lvalue to rvalue conversion"></a>Lvalue to rvalue conversion</h4><p>任何非函数、非数组类型T的glvalue都可以隐式转换为相同类型的prvalue<br>这种转换模拟了将一个值从内存位置读入CPU寄存器的过程</p>
<h4 id="Array-to-pointer-conversion"><a href="#Array-to-pointer-conversion" class="headerlink" title="Array to pointer conversion"></a>Array to pointer conversion</h4><p>类型为“N T 数组”或“未知T边界数组”的左值或右值可以隐式转换为类型为“T指针”的prvalue。如果数组是prvalue，则会发生临时物化。(因为c++ 17)指针指向数组的第一个元素。</p>
<h4 id="Function-to-pointer"><a href="#Function-to-pointer" class="headerlink" title="Function to pointer"></a>Function to pointer</h4><p>函数类型T的左值可以隐式转换为指向该函数的prvalue指针。这不适用于非静态成员函数，因为引用非静态成员函数的左值不存在。</p>
<h3 id="左值"><a href="#左值" class="headerlink" title="左值"></a>左值</h3><p>可以对lvalue取地址。例如 &amp;++I and &amp;std::endl是有效的表达式。<br>可修改的lvalue可以作为赋值操作符的左操作数。<br>lvalue可以初始化左值引用,</p>
<h3 id="右值"><a href="#右值" class="headerlink" title="右值"></a>右值</h3><p>rvalue不能被取地址。例如： &amp;int(), &amp;i++[3], &amp;42, and &amp;std::move(x) 是无效的。<br>rvalue不能当赋值运算符的左操作数<br>rvalue可以初始化常量左值引用<br>rvalue可以初始化右值引用</p>
<h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><h4 id="CPL"><a href="#CPL" class="headerlink" title="CPL"></a>CPL</h4><p>编程语言 CPL 率先为表达式引入了值类别：所有 CPL 表达式都能以“右侧模式 (right-hand mode)”求值，但只有某些类型的表达式在“左侧模式 (left-hand mode)”有意义。在右侧模式中求值时，表达式的效果为计算出一个值（右侧值，或右值）。在左侧模式中求值时，表达式的效果则为给出一个地址（左侧值，或左值）。“左”和“右”代表“赋值之左”和“赋值之右”。 </p>
<h4 id="C"><a href="#C" class="headerlink" title="C"></a>C</h4><p>C 编程语言遵循相似的分类法，但赋值的作用不再重要：C 的表达式被分为“左值 (lvalue) 表达式”和其他（函数和非对象值），其中“左值 (lvalue)”的含义为标识一个对象的表达式，即“定位器值 (locator value)”[4]。 </p>
<h4 id="C-98"><a href="#C-98" class="headerlink" title="C++98"></a>C++98</h4><p>2011 年前的 C++ 遵循 C 模型，但做了如下改变：<br>1.恢复了用“右值 (rvalue)”来称呼非左值表达式。<br>2.规定函数为左值。<br>3.引用能绑定到左值，但只有 const 的引用能绑定到右值。<br>4.几种非左值的 C 表达式在 C++ 中成为了左值表达式。 </p>
<h4 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h4><p>随着移动语义引入到 C++11 之中，值类别被重新进行了定义，以区别表达式的两种独立的性质[5]：<br>·拥有身份 (identity)：可以确定表达式是否与另一表达式指代同一实体，例如通过比较它们所标识的对象或函数的（直接或间接获得的）地址；<br>·可被移动：移动构造函数、移动赋值运算符或实现了移动语义的其他函数能够绑定于这个表达式。<br>C++11 中：<br>·拥有身份且不可被移动的表达式被称作左值 (lvalue)表达式；<br>·拥有身份且可被移动的表达式被称作亡值 (xvalue)表达式；<br>·不拥有身份且可被移动的表达式被称作纯右值 (prvalue)表达式；<br>·不拥有身份且不可被移动的表达式未被使用。<br>拥有身份的表达式被称作“泛左值 (glvalue) 表达式”。左值和亡值都是泛左值表达式。<br>可被移动的表达式被称作“右值 (rvalue) 表达式”。纯右值和亡值都是右值表达式。 </p>
<h4 id="C-17"><a href="#C-17" class="headerlink" title="C++17"></a>C++17</h4><p>C++17 中，某些场合强制要求进行复制消除，而这要求将纯右值表达式从被它们所初始化的临时对象中分离出来，这就是我们现有的系统。<br> &#x3D;&#x3D;要注意，与 C++11 的方案相比，纯右值已不再是可被移动&#x3D;&#x3D;</p>
<h3 id="decltype-specifier"><a href="#decltype-specifier" class="headerlink" title="decltype specifier"></a>decltype specifier</h3><p>检查实体的声明类型，或表达式的类型和值类别。<br>语法<br>decltype ( 实体 )     (1)<br>decltype ( 表达式 )     (2)                                 </p>
<p>1)如果实参是没有括号的标识表达式或没有括号的类成员访问表达式，那么 decltype 产生以该表达式命名的实体的类型。<br>2)如果实参是其他类型为 T 的任何表达式，且<br>a) 如果 表达式 的值类别是亡值，将会 decltype 产生 T&amp;&amp;；<br>b) 如果 表达式 的值类别是左值，将会 decltype 产生 T&amp;；<br>c) 如果 表达式 的值类别是纯右值，将会 decltype 产生 T。 </p>
<p>注意如果对象的名字带有括号，那么它会被当做通常的左值表达式，从而 decltype(x) 和 decltype((x)) 通常是不同的类型。 </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cachefish.github.io/2022/03/03/11-%E5%88%9D%E5%A7%8B%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="来世做春风，浪漫且自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cachecatのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/03/11-%E5%88%9D%E5%A7%8B%E5%8C%96/" class="post-title-link" itemprop="url">c++ 初始化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-03 19:30:00" itemprop="dateCreated datePublished" datetime="2022-03-03T19:30:00+08:00">2022-03-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-07 10:13:08" itemprop="dateModified" datetime="2022-03-07T10:13:08+08:00">2022-03-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-base/" itemprop="url" rel="index"><span itemprop="name">c++ base</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="初始化（Initialization）"><a href="#初始化（Initialization）" class="headerlink" title="初始化（Initialization）"></a>初始化（Initialization）</h2><p>a1.a和a2.a的值一样么？pa1-&gt;a和pa2-&gt;a的值一样么？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">int a;</span><br><span class="line">&#125;;</span><br><span class="line">A a1 ;</span><br><span class="line">A a2&#123;&#125; ;</span><br><span class="line">auto pa1 = new A;</span><br><span class="line">auto pa2 = new A();</span><br></pre></td></tr></table></figure>

<h3 id="用户定义的转换函数："><a href="#用户定义的转换函数：" class="headerlink" title="用户定义的转换函数："></a>用户定义的转换函数：</h3><p>具有如下形式的没有参数和返回值的非静态成员函数或者成员函数模板<br>(explicit) operator (expression) conversion-type-id</p>
<p>conversion-type-id是一个类型ID，函数和数组操作符（[ ]， ( )）不允许出现在conversion-type-id的声明中（也就是说conversion-type-id要表示函数指针和数组指针需要使用别名），并且conversion-type-id不能是数组和函数类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct X &#123;</span><br><span class="line">// implicit conversion</span><br><span class="line">operator int() const &#123; return 7; &#125;</span><br><span class="line">// explicit conversion</span><br><span class="line">explicit operator int*() const &#123; return nullptr; &#125;</span><br><span class="line"></span><br><span class="line">// Error: [] not allowed in conversion-type-id</span><br><span class="line">//operator int(*)[3]() const &#123; return nullptr; &#125;</span><br><span class="line"></span><br><span class="line">using arr_t = int[3];</span><br><span class="line">// OK if done through using</span><br><span class="line">operator arr_t*() const &#123; return nullptr; &#125; </span><br><span class="line">// Error: conversion to array not allowed </span><br><span class="line">// operator arr_t () const; </span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">X x;</span><br><span class="line">int n = static_cast&lt;int&gt;(x); // OK: sets n to 7</span><br><span class="line">int m = x;                   // OK: sets m to 7</span><br><span class="line">// OK: sets p to null 直接初始化</span><br><span class="line">int* p = static_cast&lt;int*&gt;(x); </span><br><span class="line">// Error: no implicit conversion   拷贝初始化</span><br><span class="line">// int* q = x;    </span><br><span class="line">int (*pa)[3] = x;  // OK 转换为数组指针为implicit </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>概述<br>● 初始化是指在构造变量时为其提供初始值，在许多场景下都存在初始化，比如：</p>
<ol>
<li>初始化函数参数</li>
<li>初始化函数返回值</li>
<li>在声明符后跟一个初始化器</li>
</ol>
<p>● 初始化器有三种形式</p>
<ol>
<li>( )<br>例如int x(0)</li>
<li>&#x3D; , 包括 &#x3D;{ }<br>例如 int x &#x3D; 0;<br>int y &#x3D;{0};</li>
<li>{ }<br>例如 int x{0}</li>
</ol>
<p>●关于”&#x3D;”的误区：<br>区分是用作初始化还是赋值。创建对象时才是初始化，对象已经存在就是赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Widget w1;            // call default constructor</span><br><span class="line">Widget w2 = w1;  // not an assignment; calls copy ctor</span><br><span class="line">w1 = w2;              // an assignment; calls copy operator=</span><br></pre></td></tr></table></figure>
<p>● 初始化的种类：</p>
<ul>
<li>1.常量初始化</li>
<li>2.零初始化</li>
<li>3.列表初始</li>
<li>4.默认初始化</li>
<li>5.值初始化</li>
<li>6.直接初始化</li>
<li>7.拷贝初始化</li>
<li>8.聚合初始化</li>
<li>9.引用初始化</li>
</ul>
<h3 id="常量初始化"><a href="#常量初始化" class="headerlink" title="常量初始化"></a>常量初始化</h3><p>常量初始化指用常量表达式去初始化静态和线程存储期变量。常量初始化通常（但不一定）发生在编译期。<br>static T object&#x3D; constexpr<br>常量表达式是在编译期进行计算的表达式，最简单的常量表达式比如int类型的字面值2, 例如 static int i &#x3D; 2; i就是执行的常量初始化。又比如函数<br>constexpr int f(){<br>return 2 * 3;<br>}</p>
<h2 id="constexpr-vs-const"><a href="#constexpr-vs-const" class="headerlink" title="constexpr vs const"></a>constexpr vs const</h2><p>constexpr 不光可以修饰变量还可以修饰函数，修饰函数时表示该函数的调用可用作常量表达式。修饰变量时不仅表示该变量必须在编译时初始化，而且该变量为const。const修饰变量只表明该变量指向的内容不可修改，该变量可以在程序运行时动态初始化。</p>
<p>常量表达式种类繁多，也没必要一次都学会，如果定义了一个常量表达式但不满足常量表达式的条件或者在需要常量表达式的地方提供了非常量表达式编译器会报错提示的，一般我们可以通过这些提示来完成修改，也可参考这个链接 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/constant_expression">https://en.cppreference.com/w/cpp/language/constant_expression</a></p>
<h3 id="零初始化"><a href="#零初始化" class="headerlink" title="零初始化"></a>零初始化</h3><h4 id="零初始化场景："><a href="#零初始化场景：" class="headerlink" title="零初始化场景："></a>零初始化场景：</h4><ol>
<li>在所有其他初始化前，对每个具有静态或线程局部存储期的，不进行常量初始化的变量进行零初始化。</li>
<li>作为某些场景下的值初始化的一部分。</li>
<li>以不够长的字符串字面量初始化任何字符类型数组时，零初始化数组的剩余部分。</li>
</ol>
<h4 id="零初始化的效果："><a href="#零初始化的效果：" class="headerlink" title="零初始化的效果："></a>零初始化的效果：</h4><p>假设变量的类型为T</p>
<ol>
<li>如果 T 是标量类型，那么对象初值是整型常量零显式转换到 T 的值。 </li>
<li>如果 T 是非联合体类类型，那么零初始化它的所有基类和非静态数据成员，并初始化所有填充位为零位。忽略可能存在的构造函数。 </li>
<li>如果 T 是联合体类型，那么零初始化首个非静态的具名数据成员，并零初始化所有填充位为零位。 </li>
<li>如果 T 是数组类型，那么零初始化每个元素。<br>如果 T 是引用类型，那么不做任何事。</li>
</ol>
<h3 id="静态初始化和动态初始化"><a href="#静态初始化和动态初始化" class="headerlink" title="静态初始化和动态初始化"></a>静态初始化和动态初始化</h3><p><strong>静态初始化</strong>：如果能执行常量初始化就执行常量初始化，否则执行零初始化。常量初始化通常在编译期进行，这些预先计算好的初始值存储在程序的代码段。如果编译器不能做到，必须保证常量初始化在动态初始化之前发生。<br><strong>动态初始化</strong>：非静态初始化的其它初始化。动态初始化发生在静态初始化之后，并且是在程序运行时进行的。</p>
<h3 id="静态存储期和线程存储期变量的初始化"><a href="#静态存储期和线程存储期变量的初始化" class="headerlink" title="静态存储期和线程存储期变量的初始化"></a>静态存储期和线程存储期变量的初始化</h3><p>初始化过程如下：</p>
<ol>
<li>先进行静态初始化(常量或者零初始化）。</li>
<li>对于静态初始化阶段没有执行常量初始化（也即执行了零初始化）的变量进行动态初始化。动态初始化时机：<br>(1)全局静态存储期变量发生在main函数执行之前。<br>(2)全局线程存储期变量在线程创建时执行。<br>(3)局部静态存储期变量和局部线程存储期变量在第一次运行到变量定义的代码处时执行。</li>
</ol>
<p>关于局部静态存储期和局部线程存储期变量的补充说明：</p>
<ol>
<li>c++11之后，编译器会保证即使多线程同时初始化这样的变量也只会执行一次初始化</li>
<li>如果初始化时因为抛出了异常而没有成功，下次在执行到这行代码还会执行初始化。</li>
<li>如果没有初始化成功，变量空间释放时不会执行执行反初始化。</li>
<li>变量正在初始化时又进入到变量定义语句，行为未定义。例如：</li>
<li>int foo(int i) {<br>static int s &#x3D; foo(2*i); &#x2F;&#x2F; undefined behavior: recursive call<br>return i+1;<br>}<h4 id="静态存储期和线程存储期变量的反初始化："><a href="#静态存储期和线程存储期变量的反初始化：" class="headerlink" title="静态存储期和线程存储期变量的反初始化："></a>静态存储期和线程存储期变量的反初始化：</h4>在它们的存储空间被释放之前执行反初始化。在存储期章节讲过静态存储期变量实在程序开始运行时分配（main函数之前），程序结束时释放（main函数之后）；线程存储期变量的空间在线程开始时分配，并在线程结束时释放。</li>
</ol>
<p>推荐一个关于静态初始化的参考：<br><a target="_blank" rel="noopener" href="https://pabloariasal.github.io/2020/01/02/static-variable-initialization/#thats-all-folks">https://pabloariasal.github.io/2020/01/02/static-variable-initialization/#thats-all-folks</a></p>
<h4 id="自动存储期和动态存储期变量的初始化"><a href="#自动存储期和动态存储期变量的初始化" class="headerlink" title="自动存储期和动态存储期变量的初始化"></a>自动存储期和动态存储期变量的初始化</h4><p>这两类变量不进行静态初始化，只执行动态初始化。</p>
<ul>
<li>自动存储期这类对象的空间在代码块（block）开始时分配，并在结束时释放。初始化是在定义该变量这个条语句被执行时进行。</li>
<li>动态存储期对象则比较直观，执行到动态创建该对象是分配空间然后初始化。释放和反初始化同理。</li>
</ul>
<h4 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h4><p>默认初始化场景：没有初始化器。</p>
<p>例子：</p>
<ol>
<li>定义一个自动存储期，静态存储期和线程局部存储期对象时没有初始化器<br>T object;</li>
<li>创建一个动态存储期对象时没有初始化器.<br>new T;</li>
<li>当一个类的基类或者非静态数据成员没有出现在构造函数初始化列表中，或者非静态数据成员没有默认成员初始化器，该构造函数被调用时，基类和这些非静态数据成员执行默认初始化。<br>class A{int a;}</li>
</ol>
<h5 id="默认初始化的效果："><a href="#默认初始化的效果：" class="headerlink" title="默认初始化的效果："></a>默认初始化的效果：</h5><ol>
<li>如果T是一个类类型，那么执行默认构造函数。</li>
<li>如果T是一个数组，对其每个元素执行默认初始化。</li>
<li>否则，没有初始化动作被执行。 （例如int a; a的默认初始化就是未被初始化）</li>
</ol>
<h4 id="值初始化"><a href="#值初始化" class="headerlink" title="值初始化"></a>值初始化</h4><p><strong>值初始化场景</strong>：初始化器是空的{ } 或 ( )。<br><strong>例外场景</strong>：假设T是被初始化变量的类型，当使用空 的{}去初始化变量时：</p>
<ol>
<li>如果T 是聚合类型，则进行聚合初始化而非值初始化。</li>
<li>如果T 是没有默认构造函数但带有接受 std::initializer_list 的构造函数的类类型，则进行列表初始化。</li>
</ol>
<p>例子： </p>
<ol>
<li>创建无名临时对象时；<br> T() ; T{}; </li>
<li>创建具有动态存储期的对象时；<br> new T(); new T{}</li>
<li>初始化非静态数据成员或基类时；<br>struct A{<br>A():b(){}  &#x2F;&#x2F;初始化列表<br>T a{};     &#x2F;&#x2F;默认成员初始化器<br>T b;<br>}</li>
<li>创建具名对象（自动、静态或线程局部）。<br> T a{ }</li>
</ol>
<h5 id="值初始化的效果是："><a href="#值初始化的效果是：" class="headerlink" title="值初始化的效果是："></a>值初始化的效果是：</h5><ol>
<li>如果 T 为拥有用户提供的默认构造函数的类类型，则对象被默认初始化；</li>
<li>如果 T为拥有隐式定义的默认构造函数的类类型，则零初始化对象然后则默认初始化它；</li>
<li>如果 T 是数组类型，则值初始化数组的每个元素；</li>
<li>否则，零初始化对象。</li>
</ol>
<h3 id="拷贝初始化"><a href="#拷贝初始化" class="headerlink" title="拷贝初始化"></a>拷贝初始化</h3><p>拷贝初始化时构造函数和转换函数都只能使用non-explicit版本。</p>
<p>拷贝初始化发生的场景：</p>
<ol>
<li>初始化器为 &#x3D; 。例如：<br> (1)int a &#x3D; 2;<br> (2)成员默认初始化器使用&#x3D;的形式class A{int a&#x3D;2; int b&#x3D;{3};}</li>
<li>以值的方式传递函数参数。</li>
<li>函数中按值返回一个对象。</li>
<li>按值的方式throw 或catch 一个异常. throw object; catch(T object)</li>
<li>作为聚合初始化的一部分，初始化聚合体的每项元素时使用的是拷贝初始化。例如：<br>T array[N] &#x3D; { other-sequence};<br>T array[N]{ other-sequence};<br>备注：此时有无 &#x3D; 内部元素都为拷贝初始化</li>
</ol>
<h4 id="拷贝初始化的效果："><a href="#拷贝初始化的效果：" class="headerlink" title="拷贝初始化的效果："></a>拷贝初始化的效果：</h4><ol>
<li>如果T是类类型，other去除cv的类型为T或T的子类，T的非exlicit构造函数被调用来初始化对象。</li>
<li>如果T是类类型，other去除cv的类型既不是T也不是T的子类; 或者T为非类类型，other为类类型，用户定义的转换被调用（A user-defined conversion consists of zero or one non-explicit converting constructor or no-explicit conversion function call）。</li>
<li>如果T和other都不是类类型，使用标准转换来初始化对象。比如double转换为int.</li>
</ol>
<p>例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct A&#123;</span><br><span class="line">    explicit A()&#123;&#125;</span><br><span class="line">    explicit A(const A&amp;)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void fc(A v)&#123;&#125;</span><br><span class="line"></span><br><span class="line">TEST(init, copy4)&#123;</span><br><span class="line">// A v1 = &#123;&#125;; error 拷贝初始化不能调用显示构造函数</span><br><span class="line">A v2&#123;&#125;;     // 直接初始化</span><br><span class="line">A v3 = A(); // 没有调用拷贝构造，copy elision,</span><br><span class="line">// 效果同A v3&#123;&#125;</span><br><span class="line">// fc(v3);  error 拷贝初始化不能调用显示拷贝构造函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct A&#123;</span><br><span class="line">    explicit A(int )&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct B&#123;</span><br><span class="line">// A a = 1; error 拷贝初始化不能调用显示构造函数</span><br><span class="line">    A b&#123;1&#125;;  // 直接初始化，可以调用显示构造函数</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>● 用户定义的转换函数优先级高于转换构造函数</p>
<h4 id="直接初始化"><a href="#直接初始化" class="headerlink" title="直接初始化"></a>直接初始化</h4><p>直接初始化时构造函数和转换函数都可以使用explicit版本，其它方面同拷贝初始化。</p>
<p>直接初始化场景：</p>
<ol>
<li>初始化器为非空的( )或{ }。如果为{ }且被初始的对象是聚合体时执行聚合初始化。</li>
<li>初始化lambda表达式中按值捕获的对象<br>例子：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">struct A&#123;</span><br><span class="line">A()&#123; &#125;</span><br><span class="line">explicit A(int a, int b = 0)&#123;&#125;;</span><br><span class="line">explicit A(const A&amp; )&#123;&#125;</span><br><span class="line"> &#125;;</span><br><span class="line">static_cast&lt;A&gt;(1); // 调用A::A(int a, int b=0)</span><br><span class="line">                   // 显示转换理所当然可以调用显示构造函数</span><br><span class="line">A(1, 2);  //直接初始化纯右值的结果对象</span><br><span class="line">A&#123;1, 2&#125;;  //直接初始化纯右值的结果对象</span><br><span class="line">new A(1, 2);</span><br><span class="line">new A&#123;1, 2&#125;;</span><br><span class="line"></span><br><span class="line">//lambda例子</span><br><span class="line">A a;</span><br><span class="line">auto f = [a]()&#123; &#125;; //直接初始化可以调用显示拷贝构造函数</span><br><span class="line">// auto f = [a1 = a]()&#123; &#125;; //拷贝初始化不能调用显示拷贝构造函数</span><br><span class="line">// A a2 = a; 拷贝初始化 不能调用显示拷贝构造函数</span><br><span class="line"></span><br><span class="line">//数据成员例子</span><br><span class="line">struct B&#123;</span><br><span class="line">B():a(1)&#123;&#125; //初始化列表 </span><br><span class="line">A a;</span><br><span class="line">A b&#123;3&#125;;  //默认成员初始化器</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="聚合初始化"><a href="#聚合初始化" class="headerlink" title="聚合初始化"></a>聚合初始化</h3><p>如下类型称为聚合(aggregate)：</p>
<ul>
<li>● 数组类型</li>
<li>● 满足如下条件的类类型（struct, class, union)：<ul>
<li>没有用户定义的构造函数。</li>
<li>没有直接的private或protected非静态数据成员。（基类可以有）</li>
<li>没有虚函数（自己没有同时基类也没有）。</li>
<li>没有虚的，private或者protected的基类。</li>
<li></li>
</ul>
</li>
</ul>
<p><strong>聚合初始化场景</strong>：使用{ }或 &#x3D;{ }初始化聚合体时。<br>例：<br>T object&#x3D;{arg1, arg2, …};<br>T object{arg1, arg2, …};<br>T object &#x3D;{.designator&#x3D;arg1,  .designator{arg2}… };<br>T object{.designator&#x3D;arg1, .designator{arg2}… };    </p>
<h3 id="聚合的元素次序："><a href="#聚合的元素次序：" class="headerlink" title="聚合的元素次序："></a>聚合的元素次序：</h3><p>● 对于数组，按下标的升序排列<br>● 对于类（静态数据成员和匿名的位域不是聚合体的元素），直接基类（如果有多个基类，按声明先后排序），然后是按声明先后排列的元素。对于union只取第一个元素。</p>
<p>用初始化器(initializer-list)列表（即{…}）初始化去聚合体时，{ }中的每个元素以&#x3D;&#x3D;拷贝初始化&#x3D;&#x3D;的方式去初始化聚合体的每个元素。{ }中的元素和聚合体中元素的对应规则如下：</p>
<ol>
<li>如果{ }是designated-initializer-list, 聚合体必须是类，指示器指示的类中的非静态成员被初始化。比如 T{.a&#x3D; 1;.c&#x3D;3;}</li>
<li>如果{ }是initializer-list，则依次初始化聚合体中前n个元素，n为初始化器列表的元素个数。</li>
<li>对于聚合体中没有对应初始化器的元素的初始化下面单独讨论。</li>
</ol>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Base&#123;</span><br><span class="line">public:</span><br><span class="line">    Base()&#123;&#125; //有用户定义构造函数，不是聚合体</span><br><span class="line">    int a;</span><br><span class="line">private:</span><br><span class="line">    int b;   //有私有成员，不是聚合体</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Agg :public Base&#123;</span><br><span class="line">public:</span><br><span class="line">    // virtual void f()&#123;&#125;   如果有了虚函数就不是聚合了</span><br><span class="line">    int c = 3;</span><br><span class="line">    union&#123;</span><br><span class="line">        int d;</span><br><span class="line">        double e;</span><br><span class="line">    &#125;;</span><br><span class="line">    int f;</span><br><span class="line">&#125;;</span><br><span class="line">Agg a&#123;&#123;&#125;,1, 2, 3&#125;; </span><br></pre></td></tr></table></figure>
<p>对于聚合体中没有对应初始化器的元素按如下规则初始化：</p>
<h4 id="●-对于非unoin聚合体："><a href="#●-对于非unoin聚合体：" class="headerlink" title="● 对于非unoin聚合体："></a>● 对于非unoin聚合体：</h4><p>如果元素有默认成员初始化器，就使用该初始化器进行初始化;否则如果元素非引用使用空的{ }拷贝初始化;(对于非类类型执行值初始化，对于非聚合类调用默认构造函数，对于聚合类执行聚合初始化)；如果没有初始化器的元素是引用程序非法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct A&#123;</span><br><span class="line">int a;</span><br><span class="line">int b;</span><br><span class="line">int c = 3;</span><br><span class="line">&#125;;</span><br><span class="line">A a&#123;1&#125;;     // a.a = 1, a.b = 0, a.c =3</span><br><span class="line">A b&#123;.b = 2&#125;;// a.a=0, a.b = 2 , a.c = 3</span><br><span class="line"></span><br><span class="line">struct B&#123;</span><br><span class="line">explicit B()&#123;&#125;;</span><br><span class="line">B(int v):a(v)&#123;&#125;;</span><br><span class="line">int a;</span><br><span class="line">&#125;; </span><br><span class="line">// B x[2]&#123;1&#125;; 没有初始化器对应的元素x[1]，是非聚合类，应该调</span><br><span class="line">用默认构造函数，由于是拷贝初始化，不能调用显示默</span><br><span class="line">认构造函数.</span><br></pre></td></tr></table></figure>
<h4 id="●-对于unoin聚合体："><a href="#●-对于unoin聚合体：" class="headerlink" title="● 对于unoin聚合体："></a>● 对于unoin聚合体：</h4><p>如果任何成员有默认初始化器，该成员使用默认成员初始化器进行初始化;否则使用空的{ }拷贝初始化第一个元素.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">union A&#123;</span><br><span class="line">double a = 1;</span><br><span class="line">int b;</span><br><span class="line">&#125;;</span><br><span class="line">A a&#123; &#125;; // a.a = 1.0;</span><br></pre></td></tr></table></figure>

<p>其它一些规则：<br>●对于union只有一个成员能出现在designated-initializer-list中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">union A&#123;</span><br><span class="line">int a;</span><br><span class="line">double b;</span><br><span class="line">&#125;;</span><br><span class="line">A a&#123;.b = 2.0&#125;;</span><br><span class="line">A a&#123;.a = 1, .b = 2.0&#125;; // error 只能出现一个成员</span><br></pre></td></tr></table></figure>

<p>●对于非union类，出现在designated-initializer-list中成员的顺序必须和类中声明的顺序一致。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct A&#123;</span><br><span class="line">int a;</span><br><span class="line">int b;</span><br><span class="line">   int c;</span><br><span class="line">&#125;;</span><br><span class="line">A a&#123;.a = 1, .c = 2&#125;;</span><br><span class="line">A b&#123;.c = 1, .a = 2&#125;;  // error  c不能出现在a之前</span><br></pre></td></tr></table></figure>
<p>●initializer-list支持嵌套的形式，初始化聚合体的成员也是聚合体的情况会出现。如果子聚合体有元素，嵌套的列表初始化的{ }可以省略。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct A&#123;</span><br><span class="line">int a;</span><br><span class="line">int b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct B&#123;</span><br><span class="line">int a;</span><br><span class="line">A b;</span><br><span class="line">&#125;;</span><br><span class="line">B a&#123;1, &#123;2, 3&#125;&#125;;</span><br><span class="line">B b&#123;1, 2, 3&#125;; //效果一样，但是可读性方面较差，建议不省略。</span><br></pre></td></tr></table></figure>
<p>●初始化未知边界数组时，数组的元素个数等于初始化列表的元素个数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int x[] = &#123; 1, 3, 5 &#125;;  // x的类型为int[3];</span><br></pre></td></tr></table></figure>
<p>vc2019的非标准实现<br>vc2019聚合初始化时, 可以收缩转换<br>int d[2]{1.0,  2.0};<br>vc2019在某些情况下可以使用( )来表示聚合初始化<br>int d[2](1.0, 2.0);<br>备注：为了提高代码可移植性建议按照标准来</p>
<h3 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h3><p><strong>列表初始化场景</strong>:初始化器中有{ }的场景,包括单独的 { } 和 &#x3D;{ }。</p>
<p>列表初始化其实是一种通用的初始化，前面讲的值初始化，拷贝初始化，直接初始化，聚合初始化都出现了列表初始化的身影(使用了{ })，可以和其它初始化类型叠加，比如拷贝列表初始化，直接列表初始化，叠加时保留不光具有该类型初始化的特性，还具有列表初始化的特性。列表初始化的独特特性如下：</p>
<ol>
<li><strong>列表初始化不容许顶层的收缩转换</strong>。</li>
<li>int a( ); 这样的声明c++理解为函数声明而不是变量定义，但int a{ };则理解为变量定义。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int x = 999; // x is not a constant expression</span><br><span class="line">const int y = 999;</span><br><span class="line">const int z = 99;</span><br><span class="line">char c1 = x; // OK, though it does narrow</span><br><span class="line">char c2&#123;x&#125;; // error: might narrow</span><br><span class="line">char c3&#123;y&#125;; // error: narrows (assuming char is 8 bits)</span><br><span class="line">char c4&#123;z&#125;; // OK: no narrowing needed</span><br><span class="line">unsigned char uc1 = &#123;5&#125;; // OK: no narrowing needed</span><br><span class="line">unsigned char uc2 = &#123;-1&#125;; // error: narrows</span><br><span class="line">unsigned int ui1 = &#123;-1&#125;; // error: narrows</span><br><span class="line">signed int si1 =&#123; (unsigned int)-1 &#125;; // error: narrows</span><br><span class="line">int ii = &#123;2.0&#125;; // error: narrows</span><br><span class="line">float f1 &#123; x &#125;; // error: might narrow</span><br><span class="line">float f2 &#123; 7 &#125;; // OK: 7 can be exactly represented as a float</span><br><span class="line">int f(int);</span><br><span class="line">// OK: the double-to-int conversion is not at the top</span><br><span class="line"> level</span><br><span class="line">int a[] = &#123; 2, f(2), f(2.0) &#125;; </span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="列表初始化规则："><a href="#列表初始化规则：" class="headerlink" title="列表初始化规则："></a>列表初始化规则：</h4><p>假设T为被初始化对象的类型</p>
<ol>
<li><p>[初始化聚合体的特殊语法] 如果{ }为designated-initializer-list，则T必须为聚合类，执行聚合初始化。</p>
</li>
<li><p>[初始化聚合体的特例] 否则,如果T为聚合类，并且{ }中只有一项类型为cv U的元素，如果U是T或U的子类，用该元素初始化对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct A&#123;</span><br><span class="line">int a = 1;</span><br><span class="line">int b;</span><br><span class="line">&#125;;</span><br><span class="line">struct B:public A&#123;</span><br><span class="line">int a;</span><br><span class="line">&#125;;</span><br><span class="line">B b&#123;&#123;1,2&#125;,3&#125;;</span><br><span class="line">A a&#123;b&#125;; // a 被b初始化， a.a = 1, a.b = 2;</span><br><span class="line">        // 没按照一般聚合初始化的规则，</span><br><span class="line">// 也没按照非聚合类调用拷贝构造函数的方式初始化</span><br></pre></td></tr></table></figure>
</li>
<li><p>[初始化字符数组] 否则，如果T是一个字符数组，并且{ }中是一个字符串，按照下面介绍的字符数组的初始化规则进行。</p>
</li>
<li><p>[初始化聚合] 否则，如果T是一个聚合体，执行聚合初始化。</p>
</li>
<li><p>[默认构造函数的特殊处理] 否则，如果初始化器列表为空，并且T为一个有默认构造函数的类，调用该默认构造函数，并且执行的是值初始化。<br>即使存在std::initializer_list作为参数的构造函数存在也是调用的默认构造函数。也就是说空的{} 表示没有参数而不是空的std::initializer_list.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">A(int a = 0) &#123;</span><br><span class="line">cout &lt;&lt; &quot;1&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">A(std::initializer_list&lt;int&gt;) &#123;</span><br><span class="line">       cout &lt;&lt; &quot;2&quot; &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line">A a&#123;&#125;; // 输出 1</span><br></pre></td></tr></table></figure></li>
<li><p>[初始化std::initializer_list的规则] 否则，如果T是std::initializer_list<E>的一个特化类型，用初始化器列表的每一项元素拷贝初始化T的每一项元素。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct C&#123;</span><br><span class="line">//explicit C(int)&#123;&#125;  </span><br><span class="line">    C(int)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">// T的类型为std::initializer_list&lt;C&gt; </span><br><span class="line">std::initializer_list&lt;C&gt; a&#123;1, 2&#125;; </span><br><span class="line">std::initializer_list&lt;C&gt; b = &#123;1, 2&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>[构造函数重载选择的规则] 否则，如果T是一个类，调用构造函数来初始化。<br>(1) 如果存在构造函数以std::initializer_list作为其唯一参数，或则作为第一个参数其余都为默认参数，那么优先匹配这些构造函数。如果需要进行收缩转换来匹配std::initializer_list,那么程序非法。<br>(2) 否则以初始化器列表的每一项元素作为参数去匹配构造函数。<br>例子：</p>
<ul>
<li>优先匹配std::initializer_list的构造函数，即使存在更匹配的非std::initializer_list参数的构造函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct A&#123;</span><br><span class="line"> A(int a, bool b)&#123; &#125;</span><br><span class="line"> A(int a, double b)&#123;&#125;</span><br><span class="line"> A(std::initializer_list&lt;double&gt; )&#123;&#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> A a&#123;1, true&#125;; // A::A(std::initializer_list&lt;double&gt;)</span><br><span class="line"> A b&#123;1, 5.0&#125;;  // A::A(std::initializer_list&lt;double&gt;)</span><br><span class="line"> A c(1, true); // A::A(int a, bool b)</span><br><span class="line"> A d(1, 5.0);  // A::A(int a, double b)</span><br></pre></td></tr></table></figure>
<ul>
<li>如果存在需要收缩转换来匹配std::initializer_list，那么程序非法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct A&#123;</span><br><span class="line"> A(int a, bool b)&#123; &#125;</span><br><span class="line"> A(int a, double b)&#123; &#125;</span><br><span class="line"> A(std::initializer_list&lt;bool&gt; )&#123;&#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> A a&#123;1, true&#125;;</span><br><span class="line"> A b&#123;1, 5.0&#125;; // 即使第2个构造函数完全匹配，也会优先去匹配</span><br><span class="line"> // std::initializer_list，但需要做收缩转换，</span><br><span class="line"> // 所以程序非法，编译错误</span><br><span class="line"> A c(1, true);</span><br><span class="line"> A d(1, 5.0);</span><br></pre></td></tr></table></figure></li>
<li>如果完全不可能存在转换去匹配std::initializer_list，那么会去匹配非std::initializer_list参数的构造函数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct A&#123;</span><br><span class="line"> A(int a, bool b)&#123; &#125;</span><br><span class="line"> A(int a, double b)&#123;&#125;</span><br><span class="line"> A(std::initializer_list&lt;std::string&gt; )&#123;&#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> A a&#123;1, true&#125;;</span><br><span class="line"> A b&#123;1, 5.0&#125;;  //调用A(int a, double b)</span><br><span class="line"> A c(1, true);</span><br><span class="line"> A d(1, 5.0);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>[初始化枚举类型] 否则，如果T是具有固定底层类型U的枚举，并且初始化器列表只有一个元素v，v可以非收缩隐式转换为U，并且是直接初始化，则对象被初始化为T(v)。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// byte is a new integer type</span><br><span class="line">enum byte : unsigned char &#123;&#125;; </span><br><span class="line">byte b &#123; 42 &#125;;       // OK </span><br><span class="line">byte c = &#123; 42 &#125;;     // error，拷贝初始化</span><br><span class="line">byte d = byte&#123; 42 &#125;; // OK same value as b</span><br><span class="line">byte e &#123; -1 &#125;;   // error int到 unsigned char收缩转换</span><br><span class="line"></span><br><span class="line">struct A &#123; </span><br><span class="line">byte b; </span><br><span class="line">&#125;;</span><br><span class="line">A a1 = &#123; &#123; 42 &#125; &#125;;   // error聚合体元素执行的是拷贝初始化</span><br><span class="line">A a2 = &#123; byte&#123; 42 &#125; &#125;; // OK </span><br><span class="line"></span><br><span class="line">void f(byte);</span><br><span class="line">f(&#123; 42 &#125;); // error 函数参数是拷贝初始化</span><br></pre></td></tr></table></figure></li>
<li><p>[初始化非枚举的非类类型] 否则，如果T不是一个类类型，并且初始化器列表只有一个元素，则对象被该元素直接初始化或拷贝初始化。如果存在收缩转换程序非法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int x&#123;1&#125; ;     // OK 直接初始化</span><br><span class="line">int x2 = &#123;2&#125;;  // OK 拷贝初始化</span><br><span class="line">int x3&#123;2.0&#125; ;  // erorr 收缩转换</span><br></pre></td></tr></table></figure>
</li>
<li><p>[初始化相关引用] 否则，如果T是引用类型，且初始化器列表只有一个类型为E元素，如果T引用的类型和E相同或是E的基类，则该引用被该元素初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct A&#123;</span><br><span class="line">explicit A()&#123; cout &lt;&lt; &quot;1&quot; &lt;&lt; endl; &#125;;</span><br><span class="line">explicit A(const A&amp;)&#123; cout &lt;&lt; &quot;2&quot; &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">const A&amp; a1 = &#123;A()&#125;; //纯右值直接初始化a1,不会调用拷贝构造函数</span><br><span class="line">const A&amp; a2&#123;A()&#125;;  //效果同上</span><br></pre></td></tr></table></figure>
</li>
<li><p>[初始化非相关引用] 否则，如果T是引用类型，以拷贝初始化的方式生成一个类型为T临时对象，引用绑定到该临时对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct A&#123;&#125;;</span><br><span class="line">struct B&#123;</span><br><span class="line">explicit B(const A&amp;)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">A a&#123;&#125;;</span><br><span class="line">const B&amp; b&#123;a&#125;; // error 拷贝初始化，不能调用显示构造函数。</span><br><span class="line"></span><br><span class="line">struct C&#123;</span><br><span class="line">     explicit C(int)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> const C(&amp;arr)[3] = &#123; 1, 3, 4 &#125;; // error，拷贝初始化，</span><br><span class="line">// 不能调用显示构造函数。</span><br></pre></td></tr></table></figure>
<p>12 否则，如果初始化器列表为空，执行值初始化。<br>● 字符数组<br>普通字符类型(char、signed char、unsigned char)、char8_t (since c++ 20)、char16_t、char32_t (since c++ 11)或wchar_t可以分别从普通字符串字面值、UTF-8字符串字面值(since c++ 20)、UTF-16字符串字面值、UTF-32字符串字面值(since c++ 11)或宽字符串字面值初始化。可选地用大括号括起来。<br>字符串字面值的连续字符(包括隐式终止空字符)初始化数组的元素。如果指定了数组的大小，且数组的大小大于字符串中的字符数</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">char a[] = &quot;abc&quot;;</span><br><span class="line">// equivalent to char a[4] = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;\0&#x27;&#125;;</span><br><span class="line"></span><br><span class="line">//unsigned char b[3] = &quot;abc&quot;; // Error: initializer string too long</span><br><span class="line">unsigned char b[5]&#123;&quot;abc&quot;&#125;;</span><br><span class="line">// equivalent to unsigned char b[5] = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;\0&#x27;, &#x27;\0&#x27;&#125;;</span><br><span class="line"></span><br><span class="line">wchar_t c[] = &#123;L&quot;кошка&quot;&#125;; // optional braces</span><br><span class="line">// equivalent to wchar_t c[6] = &#123;L&#x27;к&#x27;, L&#x27;о&#x27;, L&#x27;ш&#x27;, L&#x27;к&#x27;, L&#x27;а&#x27;, L&#x27;\0&#x27;&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description">来世做春风，浪漫且自由</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/cachefish" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cachefish" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/cachefish@163g.com" title="E-Mail → cachefish@163g.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
